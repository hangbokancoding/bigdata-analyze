name,code
ozanfinalfix.js,"// https://op-prod-tr.ozan.com/api/(oauth/token\?grant_type=pre_verification|users/update-mobile-number)
const url = $request.url
var new_hdrs = {}
for (var k in $request.headers) {
 new_hdrs[k.toLowerCase()] = $request.headers[k]
}


function main() {
 if (url == 'https://op-prod-tr.ozan.com/api/oauth/token?grant_type=pre_verification') {
 if (!($request.body.includes('mfa_code') && $request.body.includes('mfa_token'))) {
 $notification.post('Ozan修复工具', '', `修复工具启动，请直接输入123456作为校验码`);
 return $done({ response: {
 status: 403,
 body: `{
      ""message"": ""Identity authentication is required"",
      ""mfaToken"": ""eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX25hbWUiOiIxMzAyNzIyMDc1NyIsInNjb3BlIjpbInRlc3QiXSwiZGV2aWNlX2NvZGUiOiI2MkM5Q0Y0OC0xREJDLTRGNjgtQjZEOS03REUwQjNBOTQ2NEMiLCJleHAiOjE2OTg3Nzk0ODQsIm1mYUlkIjoiNjg1ZTM0NWEtODFhMi00NWI4LWE1OTgtNGQ4NjQyYWE3YTk3IiwianRpIjoiZDY0YjRlMTgtZWRkMy00YThlLWJlMTAtMTMyZmI5N2JiNTE1IiwiY2xpZW50X2lkIjoib3phbi1pb3MiLCJ1c2VybmFtZSI6IjEzMDI3MjIwNzU3In0.FE7oOyqhacnPVDDgsaU5rGhtteBL3jCIK3hku-yL-fWTWgx-mjpof637V6MryFqt458i3t1KORP_j2LrCRB5tcbCuQPYLxPd9VJbgNbMEC61EO_00bW_XCpTXgJ8FDXJrIWF9fGhCVNRThmwYhqg6TgllGPtEUKp4yCbQ_eksqQQvvN_5BvxObMddwXfxxfGca_VpUGDDPCj5E85Pe5yUFzNaFgtYVJw5PYzA5aOXtTSZDt9Svsqr2QmVHFQjtwi1qkZESX8K4O54_uJC9hc4zRYU7XyFb7qCuRYr5xPJjOp1YpdbaaM1ZNxVn_4ZfzvbVTO7I4V9Wq2oqWWEbudgA"",
      ""errorCode"": ""MFA_REQUIRED""
    }`,
 headers: {
 ""content-type"": ""application/json;charset=UTF-8"",
 ""access-control-allow-origin"": ""*"",
 ""cache-control"": ""no-cache, no-store, max-age=0, must-revalidate"",
 ""expires"": ""0"",
 ""pragma"": ""no-cache"",
 ""referrer-policy"": ""no-referrer-when-downgrade"",
 ""strict-transport-security"": ""max-age=15552000; includeSubDomains"",
 ""x-content-type-options"": ""nosniff"",
 ""x-frame-options"": ""sameorigin"",
 ""x-xss-protection"": ""1; mode=block"",
 ""cf-cache-status"": ""DYNAMIC"",
 ""server"": ""cloudflare"",
 ""cf-ray"": ""81ed5867cc6f07a3-HKG"",
 }
 
 }})
 } else {
 console.log(new_hdrs)
 const deviceCode = new_hdrs['x-device-code']
 console.log(deviceCode)
 if (deviceCode === '') {
 return $done()
 }
 return $done({ response: {
 status: 200,
 body: `{
      ""device_code"": ""${deviceCode}"",
      ""jti"": ""ad721296-6d59-4a95-b1b3-7a279e0274ac"",
      ""token_type"": ""bearer"",
      ""scope"": ""test"",
      ""refresh_token"": ""eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX25hbWUiOiIxMzAyNzIyMDc1NyIsInNjb3BlIjpbInRlc3QiXSwiZGV2aWNlX2NvZGUiOiI2MkM5Q0Y0OC0xREJDLTRGNjgtQjZEOS03REUwQjNBOTQ2NEMiLCJhdGkiOiJhZDcyMTI5Ni02ZDU5LTRhOTUtYjFiMy03YTI3OWUwMjc0YWMiLCJleHAiOjE2OTg3ODAzOTcsImF1dGhvcml0aWVzIjpbIlBSRV9WRVJJRklDQVRJT05fVVNFUiJdLCJqdGkiOiJkNmNhY2RjMS1mNjczLTQxNjctOTI2ZC1lNDVjNDM5NWE0MjUiLCJjbGllbnRfaWQiOiJvemFuLWlvcyIsInVzZXJuYW1lIjoiMTMwMjcyMjA3NTcifQ.NM2QslAes1FnDK-XtL0OCGAbBoO7EvHRAQaOmGHpQ1whw3NfM6trF-ZvBPDE0AkX2UafKJXTarHODWYF_4fhhpFXno1dc8qQQylfP8fbwXFTBBIEPEFh6cqZqIy-OUiSU7xJXSVR8EbJzz5py_zhNIDuoICPO3SV_plepWFHchrDwWDBKXBkNuLJs7qp46-ezAwPUiapOoPiilzdCa-QyRr_007e5Q3e22sotkjdFpVc9JYlJnioS5IbmTqyolSTEsCHPbb3tSLugT3pLw9VL3AaC16LhAjkXE73G3SRbkf3LVTkjow19JRXHoWNCqAiAuVRlDM2y2JnaDwf7HRHvQ"",
      ""username"": ""13027220757"",
      ""access_token"": ""eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX25hbWUiOiIxMzAyNzIyMDc1NyIsInNjb3BlIjpbInRlc3QiXSwiZGV2aWNlX2NvZGUiOiI2MkM5Q0Y0OC0xREJDLTRGNjgtQjZEOS03REUwQjNBOTQ2NEMiLCJleHAiOjE2OTg3Nzk0OTcsImF1dGhvcml0aWVzIjpbIlBSRV9WRVJJRklDQVRJT05fVVNFUiJdLCJqdGkiOiJhZDcyMTI5Ni02ZDU5LTRhOTUtYjFiMy03YTI3OWUwMjc0YWMiLCJjbGllbnRfaWQiOiJvemFuLWlvcyIsInVzZXJuYW1lIjoiMTMwMjcyMjA3NTcifQ.CGyjujEhz1OWiFZu95io1p1BMQdu9K0DTiFN1BkHiuBnpMB6qVHq53gFXoPIsB1SEAfkFwR8v4_KySkLRlPbNcjtVM9mnP3dnNi7ZoO9i6ZwqwV3R4W1K-SzFwNm2yFNt6HlfxE_ColK17OdoUQVaRK_5NoZnZhHh50P54kfvIfJ8I70M4LOwdwFMvj9hqujKLapIG0_KqiSkMrVSH4Ryr9fYuppONLtKr_I_ALdSyzV95O3QWujTP_tzHv1jKrdfVQox0jOOiKEx-urJBrnHsj-nGD73DJccMgOny79tBw_oV1Fw6osYN6Pi36hkKSAnrhSk2zF4GdaPJoalc5itw"",
      ""expires_in"": 8999
    }`,
 headers: {
 ""content-type"": ""application/json;charset=UTF-8"",
 ""access-control-allow-origin"": ""*"",
 ""cache-control"": ""no-cache, no-store, max-age=0, must-revalidate"",
 ""expires"": ""0"",
 ""pragma"": ""no-cache"",
 ""referrer-policy"": ""no-referrer-when-downgrade"",
 ""strict-transport-security"": ""max-age=15552000; includeSubDomains"",
 ""x-content-type-options"": ""nosniff"",
 ""x-frame-options"": ""sameorigin"",
 ""x-xss-protection"": ""1; mode=block"",
 ""cf-cache-status"": ""DYNAMIC"",
 ""server"": ""cloudflare"",
 ""cf-ray"": ""81ed58b53f8907a3-HKG"",
 }
 }})
 }
 }
 else if (url == 'https://op-prod-tr.ozan.com/api/users/update-mobile-number') {
 console.log($request)
 if (!$request.body.includes('1(')) {
 $done({})
 }
 console.log($request.body)
 var newbody = $request.body.replaceAll(/1\((\d\d\d)\)(\d\d\d)-(\d\d\d\d)/g, '1$1$2$3')
 const payload = {
 body: newbody,
 }
 $notification.post('Ozan修复工具', '', `已将手机号格式修复并更新，请重启重新登录：${$request.body} -> ${newbody}`);
 return $done(payload)
 }
 
 return $done({});
}
main()
#!name=[Misty]-ozanfinalfix
#!desc=Misty


[Script]
ozanfinalfix = type=http-request,pattern=https://op-prod-tr.ozan.com/api/(oauth/token\?grant_type=pre_verification|users/update-mobile-number),requires-body=1,max-size=0,debug=1,script-path=https://gist.githubusercontent.com/NyaMisty/cfd8ed6ca9fcee7cd6b9dc1efaf27484/raw/ozanfinalfix.js


[MITM]
hostname = %INSERT% op-prod-tr.ozan.com"
PygletWX.py,"""""""
LICENSE

Copyright (c) 2014, Rachel Powers All rights reserved.

This program is free software; you can redistribute it and/or modify it under
the terms of the BSD license: http://opensource.org/licenses/BSD-3-Clause
""""""


import wx
from wx import glcanvas
import pyglet


# this line is very important, we're tricking pyglet into thinking there is a context avalible
# but we can't make it work with the shadow window that alows sharing of
# object between contexts
pyglet.options['shadow_window'] = False


# now that that is set we can import gl and get on our way
from pyglet import gl




class PygletGLPanel(wx.Panel):


 '''A simple class for using pyglet OpenGL with wxPython.'''


 def __init__(self, parent, id, pos=wx.DefaultPosition,
 size=wx.DefaultSize, style=0):
 # Forcing a no full repaint to stop flickering
 style = style | wx.NO_FULL_REPAINT_ON_RESIZE
 self.FIRST_PAINT = False
 # call super function
 super(PygletGLPanel, self).__init__(parent, id, pos, size, style)
 # init gl canvas data
 self.GLinitialized = False
 attribList = (glcanvas.WX_GL_RGBA,  # RGBA
 glcanvas.WX_GL_DOUBLEBUFFER,  # Double Buffered
 glcanvas.WX_GL_DEPTH_SIZE, 24)  # 24 bit
 # Create the canvas
 self.sizer = wx.BoxSizer(wx.HORIZONTAL)
 self.canvas = glcanvas.GLCanvas(self, attribList=attribList)
 if wx.VERSION >= (2, 9):
 self.context = glcanvas.GLContext(self.canvas)
 self.sizer.Add(self.canvas, 1, wx.EXPAND)
 self.SetSizer(self.sizer)
 self.Layout()
 # bind events
 self.canvas.Bind(
 wx.EVT_ERASE_BACKGROUND, self.processEraseBackgroundEvent)
 self.canvas.Bind(wx.EVT_SIZE, self.processSizeEvent)
 self.canvas.Bind(wx.EVT_PAINT, self.processPaintEvent)


 #==========================================================================
 # Canvas Proxy Methods
 #==========================================================================


 def GetGLExtents(self):
 '''Get the extents of the OpenGL canvas.'''
 return self.canvas.GetClientSize()


 def SwapBuffers(self):
 '''Swap the OpenGL buffers.'''
 self.canvas.SwapBuffers()


 #==========================================================================
 # wxPython Window Handlers
 #==========================================================================


 def processEraseBackgroundEvent(self, event):
 '''Process the erase background event.'''
 pass # Do nothing, to avoid flashing on MSWin


 def processSizeEvent(self, event):
 '''Process the resize event.'''


 if wx.VERSION >= (2, 9):
 wx.CallAfter(self.doSetViewport)
 else:
 self.doSetViewport()
 event.Skip()


 def doSetViewport(self):
 if wx.VERSION >= (2, 9):
 self.Show()
 self.PrepareGL()
 # Make sure the frame is shown before calling SetCurrent.
 self.canvas.SetCurrent(self.context)
 size = self.GetGLExtents()
 self.winsize = (size.width, size.height)
 self.width, self.height = size.width, size.height
 if self.width < 0:
 self.width = 1
 if self.height < 0:
 self.height = 1
 self.OnReshape(size.width, size.height)
 self.canvas.Refresh(False)
 else:
 if self.canvas.GetContext():
 # Make sure the frame is shown before calling SetCurrent.
 self.Show()
 self.PrepareGL()
 self.canvas.SetCurrent()
 size = self.GetGLExtents()
 self.winsize = (size.width, size.height)
 self.width, self.height = size.width, size.height
 if self.width < 0:
 self.width = 1
 if self.height < 0:
 self.height = 1
 self.OnReshape(size.width, size.height)
 self.canvas.Refresh(False)


 def PrepareGL(self):
 if wx.VERSION >= (2, 9):
 self.canvas.SetCurrent(self.context)
 else:
 self.canvas.SetCurrent()


 # initialize OpenGL only if we need to
 if not self.GLinitialized:
 self.OnInitGL()
 self.GLinitialized = True
 size = self.GetGLExtents()
 self.OnReshape(size.width, size.height)


 self.pygletcontext.set_current()


 def processPaintEvent(self, event):
 '''Process the drawing event.'''
 if not self.FIRST_PAINT:
 self.FIRST_PAINT = True
 self.PrepareGL()
 self.OnDraw()
 event.Skip()


 def Destroy(self):
 # clean up the pyglet OpenGL context
 self.pygletcontext.destroy()
 # call the super metho
 super(wx.Panel, self).Destroy()


 #==========================================================================f
 # GLFrame OpenGL Event Handlers
 #==========================================================================


 def OnInitGL(self):
 '''Initialize OpenGL for use in the window.'''
 # create a pyglet context for this panel
 #self.pygletcontext = gl.Context(gl.current_context)
 if pyglet.version > ""1.1.4"":
 self.pygletcontext = PygletWXContext()
 else:
 self.pygletcontext = gl.Context()
 self.pygletcontext.set_current()
 # normal gl init
 gl.glEnable(gl.GL_BLEND)
 gl.glBlendFunc(gl.GL_SRC_ALPHA, gl.GL_ONE_MINUS_SRC_ALPHA)
 gl.glEnable(gl.GL_TEXTURE_2D)
 gl.glClearColor(1, 1, 1, 1)


 # create objects to draw
 self.create_objects()


 def OnReshape(self, width, height):
 '''Reshape the OpenGL viewport based on the dimensions of the window.'''
 # CORRECT WIDTH AND HEIGHT
 if width <= 0:
 width = 1
 if height <= 0:
 height = 1
 if self.GLinitialized:
 self.pygletcontext.set_current()
 gl.glViewport(0, 0, width, height)
 gl.glMatrixMode(gl.GL_PROJECTION)
 gl.glLoadIdentity()
 gl.glOrtho(0, width, 0, height, 1, -1)
 gl.glMatrixMode(gl.GL_MODELVIEW)
 if self.GLinitialized:
 self.update_object_resize(width, height)


 def OnDraw(self, *args, **kwargs):
 ""Draw the window.""
 # clear the context
 gl.glClear(gl.GL_COLOR_BUFFER_BIT | gl.GL_DEPTH_BUFFER_BIT)
 # draw objects
 self.draw_objects()
 # update screen
 self.SwapBuffers()


 #==========================================================================
 # To be implemented by a sub class
 #==========================================================================


 def create_objects(self):
 '''create opengl objects when opengl is initialized'''
 pass


 def update_object_resize(self, width, height):
 '''called when the window receives only if opengl is initialized'''
 pass


 def draw_objects(self):
 '''called in the middle of ondraw after the buffer has been cleared'''
 pass




class PygletWXContext(gl.Context):


 def __init__(self, config=None, context_share=None):
 self.config = config
 self.context_share = context_share
 self.canvas = None


 if context_share:
 self.object_space = context_share.object_space
 else:
 self.object_space = gl.ObjectSpace()


 def attach(self, canvas=None):
 pass


 def detach(self):
 pass


 def set_current(self):
 # XXX not per-thread
 gl.current_context = self


 # XXX
 gl.gl_info.set_active_context()
 gl.glu_info.set_active_context()


 # Implement workarounds
 if not self._info:
 self._info = gl.gl_info.GLInfo()
 self._info.set_active_context()
 for attr, check in self._workaround_checks:
 setattr(self, attr, check(self._info))


 # Release textures and buffers on this context scheduled for deletion.
 # Note that the garbage collector may introduce a race condition,
 # so operate on a copy of the textures/buffers and remove the deleted
 # items using list slicing (which is an atomic operation)
 if self.object_space._doomed_textures:
 textures = self.object_space._doomed_textures[:]
 textures = (gl.GLuint * len(textures))(*textures)
 gl.glDeleteTextures(len(textures), textures)
 self.object_space._doomed_textures[0:len(textures)] = []
 if self.object_space._doomed_buffers:
 buffers = self.object_space._doomed_buffers[:]
 buffers = (gl.GLuint * len(buffers))(*buffers)
 gl.glDeleteBuffers(len(buffers), buffers)
 self.object_space._doomed_buffers[0:len(buffers)] = []


#-------------------------------------------------------------------------
# EditorGLPanel
#-------------------------------------------------------------------------




class EditorGLPanel(PygletGLPanel):


 def __init__(self, parent, id=wx.ID_ANY, rows=1, columns=1, coord=(0, 0), drawmode=1):
 """"""Basic constructor for the wxGLCanvas

        Arguments:
        parent -- The wxWindow instance to set as this panel's parent
        id -- The ID of the panel
        rows -- The number of horizontal rows used for tiles
        columns -- The number of vertical columns used for tiles
        coord -- The coordinate of the tile that the image will draw from the source
        drawmode -- An integer to decide what drawing mode will be used.
            0: CropAndShrink -- Images will be both scaled down and cropped to fit
            1: Shrink -- Scales image down if too large, else the image is simply centered
            2: StretchAspect -- The image will be stretched to fill panel while maintaining aspect ratio
            3: Cropped -- Oversized images too large for the panel will simply be cropped
            4: Stretch -- The entire image is stretched, and aspect ratio is ignored
            5: TopLeft -- Image is anchored to top left corner and cropped
        Returns:
        None

        """"""
 super(EditorGLPanel, self).__init__(parent, id)
 self._rows = rows
 self._columns = columns
 self._coord = coord
 self._drawmode = drawmode
 self._image = None
 self.draw_objects()
 self._contextMenu = None
 self.canvas.Bind(wx.EVT_RIGHT_DOWN, self.canvas_RightClicked)


 def SetRows(self, rows):
 if rows < 1:
 rows = 1
 self._rows = rows


 def SetColumns(self, columns):
 if columns < 1:
 columns = 1
 self._columns = columns


 def canvas_RightClicked(self, event):
 """"""Creates the context menu if necessary, then displays it""""""
 if self._contextMenu is None:
 self._createContextMenu()
 self._contextMenu.Check(self._drawmode, True)
 self.canvas.PopupMenu(self._contextMenu, event.GetPosition())


 def menuItem_SelectionChanged(self, event):
 """"""updates the draw mode""""""
 self.SetDrawMode(event.GetId())


 def _createContextMenu(self):
 """"""Creates the context menu on demand""""""
 self._contextMenu = wx.Menu()
 self.menuItemCropAndShrink = wx.MenuItem(
 self._contextMenu, 0, ""Crop and Shrink"", ""Oversized images will be scaled and cropped evenly"", wx.ITEM_RADIO)
 self._contextMenu.AppendItem(self.menuItemCropAndShrink)
 self.menuItemCropAndShrink.Check(True)
 self.menuItemShrink = wx.MenuItem(
 self._contextMenu, 1, ""Shrink"", ""Oversized images will scale to the windows size while maintaining aspect ratio"", wx.ITEM_RADIO)
 self._contextMenu.AppendItem(self.menuItemShrink)
 self.menuItemStretchAspect = wx.MenuItem(
 self._contextMenu, 2, ""Stretch Aspect"", ""Images will expand to fill the window while maintaining aspect ratio"", wx.ITEM_RADIO)
 self._contextMenu.AppendItem(self.menuItemStretchAspect)
 self.menuItemCrop = wx.MenuItem(
 self._contextMenu, 3, ""Crop"", ""Image will be cropped to the window's size"", wx.ITEM_RADIO)
 self._contextMenu.AppendItem(self.menuItemCrop)
 self.menuItemStretch = wx.MenuItem(
 self._contextMenu, 4, ""Stretch"", ""Image will be stretched to fill the window and ignore the aspect ratio"", wx.ITEM_RADIO)
 self._contextMenu.AppendItem(self.menuItemStretch)
 self.menuItemNone = wx.MenuItem(
 self._contextMenu, 5, ""None"", ""No resizing, cropping, or centering will be performed"", wx.ITEM_RADIO)
 self._contextMenu.AppendItem(self.menuItemNone)
 self.Bind(wx.EVT_MENU, self.menuItem_SelectionChanged,
 id=self.menuItemCropAndShrink.GetId())
 self.Bind(wx.EVT_MENU, self.menuItem_SelectionChanged,
 id=self.menuItemShrink.GetId())
 self.Bind(wx.EVT_MENU, self.menuItem_SelectionChanged,
 id=self.menuItemStretchAspect.GetId())
 self.Bind(wx.EVT_MENU, self.menuItem_SelectionChanged,
 id=self.menuItemCrop.GetId())
 self.Bind(wx.EVT_MENU, self.menuItem_SelectionChanged,
 id=self.menuItemStretch.GetId())
 self.Bind(wx.EVT_MENU, self.menuItem_SelectionChanged,
 id=self.menuItemNone.GetId())


 def ChangeImage(self, pilImage):
 """"""Changes the displayed image""""""
 self._image = pilImage
 del (pilImage)
 if self.FIRST_PAINT:
 self.PrepareGL()
 self.OnDraw()


 def GetDrawMode(self):
 """"""Returns the integer value that represents the current drawing mode""""""
 return self._drawmode


 def SetDrawMode(self, drawmode):
 """"""Sets the drawing mode and refreshes the display""""""
 self._drawmode = drawmode
 if self.FIRST_PAINT:
 self.PrepareGL()
 self.OnDraw()


 def draw_objects(self):
 """"""Draws the objects on the canvas""""""
 if not self.GLinitialized:
 return


 # clear the screen
 gl.glClearColor(0.93, 0.93, 0.93, 1)
 gl.glClear(gl.GL_COLOR_BUFFER_BIT | gl.GL_DEPTH_BUFFER_BIT)


 if self._image is None:
 return
 # Convert PIL image to pyglet image
 srcImage = pyglet.image.create(*self._image.size).get_image_data()
 pitch = -len('RGBA') * srcImage.width
 data = self._image.tostring()
 srcImage.set_data('RGBA', pitch, data)
 # Clear the canvas and calculate the region to draw
 tile_width = srcImage.width // self._rows
 tile_height = srcImage.height // self._columns
 x = self._coord[0] * tile_width
 y = self._coord[1] * tile_height
 y = srcImage.height - y - tile_height
 subimage = srcImage.get_region(x, y, tile_width, tile_height)
 subimage.align_x = subimage.align_y = 0
 # Branch by what mode is selected to draw
 if self._drawmode == 0:
 self.CropAndShrink(subimage)
 elif self._drawmode == 1:
 self.Shrink(subimage)
 elif self._drawmode == 2:
 self.StretchAspect(subimage)
 elif self._drawmode == 3:
 self.Cropped(subimage)
 elif self._drawmode == 4:
 self.Stretch(subimage)
 else:
 self.TopLeft(subimage)
 del (srcImage)


 #---------------------------------------------------------------
 # Draw Modes
 #---------------------------------------------------------------
 def CropAndShrink(self, pygletimage):
 """"""Images will be both scaled down and cropped to fit""""""
 width, height = self.GetClientSize()
 w, h = pygletimage.width, pygletimage.height
 x, y, = (width - w) // 2, (height - h) // 2
 if width < w or height < h:
 diff_w = (w - width) // 2
 diff_h = (h - height) // 2
 pygletimage.blit(x // 2, y // 2, 0, w - diff_w, h - diff_h)
 else:
 pygletimage.blit(x, y, 0, w, h)
 del (pygletimage)


 def Shrink(self, pygletimage):
 """"""Scales image down if too large, else the image is simply centered""""""
 width, height = self.GetClientSize()
 w, h = pygletimage.width, pygletimage.height
 x, y, = (width - w) // 2, (height - h) // 2
 if width < w or height < h:
 self.StretchAspect(pygletimage)
 else:
 pygletimage.blit(x, y, 0, w, h)
 del (pygletimage)


 def StretchAspect(self, pygletimage):
 """"""The image will be stretched to fill panel while maintaining aspect ratio""""""
 width, height = self.GetClientSize()
 w, h = pygletimage.width, pygletimage.height
 x_ratio = float(width) / w
 y_ratio = float(height) / h
 if y_ratio > x_ratio:
 ch = h * x_ratio
 pygletimage.blit(0, (height - ch) // 2, 0, width, ch)
 else:
 cw = w * y_ratio
 pygletimage.blit((width - cw) // 2, 0, 0, cw, height)
 del (pygletimage)


 def Cropped(self, pygletimage):
 """"""Oversized images too large for the panel will simply be cropped""""""
 width, height = self.GetClientSize()
 w, h = pygletimage.width, pygletimage.height
 x, y = (width - w) // 2, (height - h) // 2
 if w > width:
 x = (width - w) // 2
 if h > height:
 y = (height - h) // 2
 pygletimage.blit(x, y, 0, w, h)
 del (pygletimage)


 def Stretch(self, pygletimage):
 """"""The entire image is stretched, and aspect ratio is ignored""""""
 width, height = self.GetClientSize()
 pygletimage.blit(0, 0, 0, width, height)


 def TopLeft(self, pygletimage):
 """"""Image is anchored to top left corner and cropped""""""
 y = self.GetClientSize()[1] - pygletimage.height
 pygletimage.blit(0, y, 0, pygletimage.width, pygletimage.height)
 del (pygletimage)"
webdriver_video.py,"# Copyright 2008-2009 WebDriver committers
# Copyright 2008-2009 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


from selenium.common.exceptions import StaleElementReferenceException


def stale(fn):
 def wrapper(self, *args):
 if self.changed:
 raise StaleElementReferenceException()
 return fn(self, *args)
 return wrapper


class HTML5Media(object):
 # error state
 @property
 def error(self):
 if self.changed:
 raise StaleElementReferenceException()
 errors = {
 1: ""MEDIA_ERR_ABORTED"",
 2: ""MEDIA_ERR_NETWORK"",
 3: ""MEDIA_ERR_DECODE"",
 4: ""MEDIA_ERR_SRC_NOT_SUPPORTED""
        }
 return errors[self._el._parent.execute_script(""return arguments[0].error"", self._el)]
 
 # network state
 @property
 @stale
 def src(self):
 return self._el._parent.execute_script(""return arguments[0].src"", self._el)


 @src.setter
 def src(self, value):
 if isinstance(value, str):
 self._el._parent.execute_script(""arguments[0].src = arguments[1]"", self._el, value)
 self.changed = True
 else:
 raise ValueError(""value needs to be a string"")


 @property
 @stale
 def current_source(self):
 """"""Returns the current source of the video""""""
 return self._el._parent.execute_script(""return arguments[0].currentSrc"", self._el)


 @property
 @stale
 def cross_origin(self):
 return self._el._parent.execute_script(""return arguments[0].crossOrigin"", self._el)


 @cross_origin.setter
 def cross_origin(self, value):
 if isinstance(value, str):
 self._el._parent.execute_script(""arguments[0].crossOrigin = arguments[1]"", self._el, value)
 self.changed = True
 else:
 raise ValueError(""value needs to be a string"")


 @property
 @stale
 def network_state(self):
 """"""Returns the string representation of the current network state""""""
 states = {
 0: ""NETWORK_EMPTY"",
 1: ""NETWORK_IDLE"",
 2: ""NETWORK_LOADING"",
 3: ""NETWORK_NO_SOURCE"",
        }
 return states[self._el._parent.execute_script(""return arguments[0].networkState"", self._el)]


 @property
 @stale
 def preload(self):
 return self._el._parent.execute_script(""return arguments[0].preload"", self._el)


 @preload.setter
 def preload(self, value):
 if value in [""none"", ""metadata"", ""auto""]:
 self._el._parent.execute_script(""arguments[0].preload = arguments[1]"", self._el, value)
 self.changed = True
 else:
 raise ValueError(""value needs to be either 'none', 'metadata' or 'auto'"")


 @property
 @stale
 def buffered(self):
 """"""Returns the current source of the video""""""
 return self._el._parent.execute_script(""return arguments[0].buffered"", self._el)


 @stale
 def load(self):
 self._el._parent.execute_script(""arguments[0].load()"", self._el)


 @stale
 def can_play_type(self, media_type):
 return self._el._parent.execute_script(""return arguments[0].canPlayType(arguments[1])"", self._el, media_type)


 # ready state
 @property
 @stale
 def ready_state(self):
 states = {
 0: ""HAVE_NOTHING"",
 1: ""HAVE_METADATA"",
 2: ""HAVE_CURRENT_DATA"",
 3: ""HAVE_FUTURE_DATA"",
 4: ""HAVE_ENOUGH_DATA""
        }
 return states[self._el._parent.execute_script(""return arguments[0].readyState"", self._el)]


 @property
 @stale
 def seeking(self):
 return self._el._parent.execute_script(""return arguments[0].seeking"", self._el)
 
 # playback state
 @property
 @stale
 def current_time(self):
 return self._el._parent.execute_script(""return arguments[0].currentTime"", self._el)


 @current_time.setter
 def current_time(self, value):
 if isinstance(value, int):
 self._el._parent.execute_script(""arguments[0].currentTime = arguments[1]"", self._el, value)
 self.changed = True
 else:
 raise ValueError(""value needs to be a boolean"")


 @property
 @stale
 def initial_time(self):
 return self._el._parent.execute_script(""return arguments[0].initialTime"", self._el)
 
 @property
 @stale
 def duration(self):
 return self._el._parent.execute_script(""return arguments[0].duration"", self._el)


 @property
 @stale
 def start_offset_time(self):
 return self._el._parent.execute_script(""return arguments[0].startOffsetTime"", self._el)


 @property
 @stale
 def paused(self):
 return self._el._parent.execute_script(""return arguments[0].paused"", self._el)


 @property
 @stale
 def default_playback_rate(self):
 return self._el._parent.execute_script(""return arguments[0].defaultPlaybackRate"", self._el)


 @default_playback_rate.setter
 def default_playback_rate(self, value):
 if isinstance(value, int):
 self._el._parent.execute_script(""arguments[0].defaultPlaybackRate = arguments[1]"", self._el, value)
 self.changed = True
 else:
 raise ValueError(""value needs to be a int"")


 @property
 @stale
 def playback_rate(self):
 return self._el._parent.execute_script(""return arguments[0].playbackRate"", self._el)


 @playback_rate.setter
 def playback_rate(self, value):
 if isinstance(value, int):
 self._el._parent.execute_script(""arguments[0].playbackRate = arguments[1]"", self._el, value)
 self.changed = True
 else:
 raise ValueError(""value needs to be a int"")


 @property
 @stale
 def played(self):
 return self._el._parent.execute_script(""return arguments[0].played"", self._el)


 @property
 @stale
 def seekable(self):
 return self._el._parent.execute_script(""return arguments[0].seekable"", self._el)


 @property
 @stale
 def ended(self):
 return self._el._parent.execute_script(""return arguments[0].ended"", self._el)


 @property
 @stale
 def autoplay(self):
 return self._el._parent.execute_script(""return arguments[0].autoplay"", self._el)


 @autoplay.setter
 def autoplay(self, value):
 if isinstance(value, bool):
 self._el._parent.execute_script(""arguments[0].autoplay = arguments[1]"", self._el, value)
 self.changed = True
 else:
 raise ValueError(""value needs to be a boolean"")


 @property
 @stale
 def loop(self):
 return self._el._parent.execute_script(""return arguments[0].loop"", self._el)


 @loop.setter
 def loop(self, value):
 if isinstance(value, bool):
 self._el._parent.execute_script(""arguments[0].loop = arguments[1]"", self._el, value)
 self.changed = True
 else:
 raise ValueError(""value needs to be a boolean"")


 @stale
 def play(self):
 x = self._el._parent.execute_script(""arguments[0].play()"", self._el)


 @stale
 def pause(self):
 x = self._el._parent.execute_script(""arguments[0].pause()"", self._el)


 # media controller
 @property
 @stale
 def mediagroup(self):
 return self._el._parent.execute_script(""return arguments[0].mediagroup"", self._el)


 @mediagroup.setter
 def mediagroup(self, value):
 if isinstance(value, str):
 self._el._parent.execute_script(""arguments[0].mediagroup = arguments[1]"", self._el, value)
 self.changed = True
 else:
 raise ValueError(""value needs to be a string"")


 # controls
 @property
 @stale
 def controls(self):
 return self._el._parent.execute_script(""return arguments[0].controls"", self._el)


 @controls.setter
 def controls(self, value):
 if isinstance(value, bool):
 self._el._parent.execute_script(""arguments[0].controls = arguments[1]"", self._el, value)
 self.changed = True
 else:
 raise ValueError(""value needs to be a boolean"")


 @property
 @stale
 def volume(self):
 return self._el._parent.execute_script(""return arguments[0].volume"", self._el)


 @volume.setter
 def volume(self, value):
 if isinstance(value, int):
 self._el._parent.execute_script(""arguments[0].volume = arguments[1]"", self._el, value)
 self.changed = True
 else:
 raise ValueError(""value needs to be a int"")


 @property
 @stale
 def muted(self):
 return self._el._parent.execute_script(""return arguments[0].muted"", self._el)


 @muted.setter
 def muted(self, value):
 if isinstance(value, bool):
 self._el._parent.execute_script(""arguments[0].muted = arguments[1]"", self._el, value)
 self.changed = True
 else:
 raise ValueError(""value needs to be a boolean"")


 @property
 @stale
 def default_muted(self):
 return self._el._parent.execute_script(""return arguments[0].defaultMuted"", self._el)


 @default_muted.setter
 def default_muted(self, value):
 if isinstance(value, bool):
 self._el._parent.execute_script(""arguments[0].defaultMuted = arguments[1]"", self._el, value)
 self.changed = True
 else:
 raise ValueError(""value needs to be a boolean"")


class Video(HTML5Media):
 def __init__(self, webelement):
 """"""
        Constructor. A check is made that the given element is, indeed, a VIDEO tag. If it is not,
        then an UnexpectedTagNameException is thrown.

        :Args:
         - webelement - element VIDEO element to wrap
 
        Example:
            from selenium.webdriver.support.ui import Select \n
            Video(driver.find_element_by_tag_name(""video"")).play()
        """"""
 if webelement.tag_name.lower() != ""video"":
 raise UnexpectedTagNameException(
 ""Video only works on <video> elements, not on <%s>"" % 
 webelement.tag_name)
 self._el = webelement
 self.changed = False


 @property
 @stale
 def width(self):
 """"""Returns the width in px of the video""""""
 return self._el._parent.execute_script(""return arguments[0].width"", self._el)


 @width.setter
 def width(self, value):
 """"""Sets the width in px of the video""""""
 self._el._parent.execute_script(""arguments[0].width = arguments[1]"", self._el, value)
 self.changed = True


 @property
 @stale 
 def video_width(self):
 """"""Returns the width in px of the video""""""
 return self._el._parent.execute_script(""return arguments[0].videoWidth"", self._el)


 @property
 @stale
 def height(self):
 """"""Returns the height in px of the video""""""
 return self._el._parent.execute_script(""return arguments[0].height"", self._el)


 @height.setter
 def height(self, value):
 """"""Sets the width in px of the video""""""
 self._el._parent.execute_script(""arguments[0].height = arguments[1]"", self._el, value)
 self.changed = True


 @property
 @stale
 def video_height(self):
 """"""Returns the height in px of the video""""""
 return self._el._parent.execute_script(""return arguments[0].videoHeight"", self._el)


 @property
 @stale
 def poster(self):
 return self._el._parent.execute_script(""return arguments[0].poster"", self._el)


 @poster.setter
 def poster(self, value):
 self._el._parent.execute_script(""arguments[0].poster = arguments[1]"", self._el, value)
 self.changed = True


class Audio(HTML5Media):
 def __init__(self, webelement):
 """"""
        Constructor. A check is made that the given element is, indeed, a Audio tag. If it is not,
        then an UnexpectedTagNameException is thrown.

        :Args:
         - webelement - element Audio element to wrap

        Example:
            from selenium.webdriver.support.ui import Select \n
            Audi(driver.find_element_by_tag_name(""audio"")).play()
        """"""
 if webelement.tag_name.lower() != ""audio"":
 raise UnexpectedTagNameException(
 ""Audio only works on <audio> elements, not on <%s>"" % 
 webelement.tag_name)
 self._el = webelement
 self.changed = False


if __name__ == ""__main__"":
 from selenium import webdriver
 
 driver = webdriver.Firefox()


 driver.get(""http://html5demos.com/video"")
 e = driver.find_element_by_css_selector(""video"")
 v = Video(e)
 v.play()


 import time
 time.sleep(5)


 v.pause()
 v.width = 600
 e = driver.find_element_by_css_selector(""video"")
 v = Video(e)
 print(""Width: {0}"".format(v.width))
 v.height = 500
 e = driver.find_element_by_css_selector(""video"")
 v = Video(e)
 print(""Height: {0}"".format(v.height))
 print(""Current Source: {0}"".format(v.current_source))
 print(""Network State: {0}"".format(v.network_state))
 print(""Ready State: {0}"".format(v.ready_state))
 print(""Buffered: {0}"".format(v.buffered))
 print(""Can Play Type? (video/ogg): {0}"".format(v.can_play_type(""video/ogg"")))
 print(""Can Play Type? (video/mp4): {0}"".format(v.can_play_type(""video/mp4"")))
 print(""Can Play Type? (video/webm): {0}"".format(v.can_play_type(""video/webm"")))
 print(""Seeking: {0}"".format(v.seeking))
 print(""Duration: {0}"".format(v.duration))
 print(""Paused?: {0}"".format(v.paused))
 print(""Played: {0}"".format(v.played))
 print(""Seekable: {0}"".format(v.seekable))
 print(""Ended?: {0}"".format(v.ended))


 driver.quit()"
ozanfinalfix.js,"// https://op-prod-tr.ozan.com/api/(oauth/token\?grant_type=pre_verification|users/update-mobile-number)
const url = $request.url
var new_hdrs = {}
for (var k in $request.headers) {
 new_hdrs[k.toLowerCase()] = $request.headers[k]
}


function main() {
 if (url == 'https://op-prod-tr.ozan.com/api/oauth/token?grant_type=pre_verification') {
 if (!($request.body.includes('mfa_code') && $request.body.includes('mfa_token'))) {
 $notification.post('Ozan修复工具', '', `修复工具启动，请直接输入123456作为校验码`);
 return $done({ response: {
 status: 403,
 body: `{
      ""message"": ""Identity authentication is required"",
      ""mfaToken"": ""eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX25hbWUiOiIxMzAyNzIyMDc1NyIsInNjb3BlIjpbInRlc3QiXSwiZGV2aWNlX2NvZGUiOiI2MkM5Q0Y0OC0xREJDLTRGNjgtQjZEOS03REUwQjNBOTQ2NEMiLCJleHAiOjE2OTg3Nzk0ODQsIm1mYUlkIjoiNjg1ZTM0NWEtODFhMi00NWI4LWE1OTgtNGQ4NjQyYWE3YTk3IiwianRpIjoiZDY0YjRlMTgtZWRkMy00YThlLWJlMTAtMTMyZmI5N2JiNTE1IiwiY2xpZW50X2lkIjoib3phbi1pb3MiLCJ1c2VybmFtZSI6IjEzMDI3MjIwNzU3In0.FE7oOyqhacnPVDDgsaU5rGhtteBL3jCIK3hku-yL-fWTWgx-mjpof637V6MryFqt458i3t1KORP_j2LrCRB5tcbCuQPYLxPd9VJbgNbMEC61EO_00bW_XCpTXgJ8FDXJrIWF9fGhCVNRThmwYhqg6TgllGPtEUKp4yCbQ_eksqQQvvN_5BvxObMddwXfxxfGca_VpUGDDPCj5E85Pe5yUFzNaFgtYVJw5PYzA5aOXtTSZDt9Svsqr2QmVHFQjtwi1qkZESX8K4O54_uJC9hc4zRYU7XyFb7qCuRYr5xPJjOp1YpdbaaM1ZNxVn_4ZfzvbVTO7I4V9Wq2oqWWEbudgA"",
      ""errorCode"": ""MFA_REQUIRED""
    }`,
 headers: {
 ""content-type"": ""application/json;charset=UTF-8"",
 ""access-control-allow-origin"": ""*"",
 ""cache-control"": ""no-cache, no-store, max-age=0, must-revalidate"",
 ""expires"": ""0"",
 ""pragma"": ""no-cache"",
 ""referrer-policy"": ""no-referrer-when-downgrade"",
 ""strict-transport-security"": ""max-age=15552000; includeSubDomains"",
 ""x-content-type-options"": ""nosniff"",
 ""x-frame-options"": ""sameorigin"",
 ""x-xss-protection"": ""1; mode=block"",
 ""cf-cache-status"": ""DYNAMIC"",
 ""server"": ""cloudflare"",
 ""cf-ray"": ""81ed5867cc6f07a3-HKG"",
 }
 
 }})
 } else {
 console.log(new_hdrs)
 const deviceCode = new_hdrs['x-device-code']
 console.log(deviceCode)
 if (deviceCode === '') {
 return $done()
 }
 return $done({ response: {
 status: 200,
 body: `{
      ""device_code"": ""${deviceCode}"",
      ""jti"": ""ad721296-6d59-4a95-b1b3-7a279e0274ac"",
      ""token_type"": ""bearer"",
      ""scope"": ""test"",
      ""refresh_token"": ""eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX25hbWUiOiIxMzAyNzIyMDc1NyIsInNjb3BlIjpbInRlc3QiXSwiZGV2aWNlX2NvZGUiOiI2MkM5Q0Y0OC0xREJDLTRGNjgtQjZEOS03REUwQjNBOTQ2NEMiLCJhdGkiOiJhZDcyMTI5Ni02ZDU5LTRhOTUtYjFiMy03YTI3OWUwMjc0YWMiLCJleHAiOjE2OTg3ODAzOTcsImF1dGhvcml0aWVzIjpbIlBSRV9WRVJJRklDQVRJT05fVVNFUiJdLCJqdGkiOiJkNmNhY2RjMS1mNjczLTQxNjctOTI2ZC1lNDVjNDM5NWE0MjUiLCJjbGllbnRfaWQiOiJvemFuLWlvcyIsInVzZXJuYW1lIjoiMTMwMjcyMjA3NTcifQ.NM2QslAes1FnDK-XtL0OCGAbBoO7EvHRAQaOmGHpQ1whw3NfM6trF-ZvBPDE0AkX2UafKJXTarHODWYF_4fhhpFXno1dc8qQQylfP8fbwXFTBBIEPEFh6cqZqIy-OUiSU7xJXSVR8EbJzz5py_zhNIDuoICPO3SV_plepWFHchrDwWDBKXBkNuLJs7qp46-ezAwPUiapOoPiilzdCa-QyRr_007e5Q3e22sotkjdFpVc9JYlJnioS5IbmTqyolSTEsCHPbb3tSLugT3pLw9VL3AaC16LhAjkXE73G3SRbkf3LVTkjow19JRXHoWNCqAiAuVRlDM2y2JnaDwf7HRHvQ"",
      ""username"": ""13027220757"",
      ""access_token"": ""eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX25hbWUiOiIxMzAyNzIyMDc1NyIsInNjb3BlIjpbInRlc3QiXSwiZGV2aWNlX2NvZGUiOiI2MkM5Q0Y0OC0xREJDLTRGNjgtQjZEOS03REUwQjNBOTQ2NEMiLCJleHAiOjE2OTg3Nzk0OTcsImF1dGhvcml0aWVzIjpbIlBSRV9WRVJJRklDQVRJT05fVVNFUiJdLCJqdGkiOiJhZDcyMTI5Ni02ZDU5LTRhOTUtYjFiMy03YTI3OWUwMjc0YWMiLCJjbGllbnRfaWQiOiJvemFuLWlvcyIsInVzZXJuYW1lIjoiMTMwMjcyMjA3NTcifQ.CGyjujEhz1OWiFZu95io1p1BMQdu9K0DTiFN1BkHiuBnpMB6qVHq53gFXoPIsB1SEAfkFwR8v4_KySkLRlPbNcjtVM9mnP3dnNi7ZoO9i6ZwqwV3R4W1K-SzFwNm2yFNt6HlfxE_ColK17OdoUQVaRK_5NoZnZhHh50P54kfvIfJ8I70M4LOwdwFMvj9hqujKLapIG0_KqiSkMrVSH4Ryr9fYuppONLtKr_I_ALdSyzV95O3QWujTP_tzHv1jKrdfVQox0jOOiKEx-urJBrnHsj-nGD73DJccMgOny79tBw_oV1Fw6osYN6Pi36hkKSAnrhSk2zF4GdaPJoalc5itw"",
      ""expires_in"": 8999
    }`,
 headers: {
 ""content-type"": ""application/json;charset=UTF-8"",
 ""access-control-allow-origin"": ""*"",
 ""cache-control"": ""no-cache, no-store, max-age=0, must-revalidate"",
 ""expires"": ""0"",
 ""pragma"": ""no-cache"",
 ""referrer-policy"": ""no-referrer-when-downgrade"",
 ""strict-transport-security"": ""max-age=15552000; includeSubDomains"",
 ""x-content-type-options"": ""nosniff"",
 ""x-frame-options"": ""sameorigin"",
 ""x-xss-protection"": ""1; mode=block"",
 ""cf-cache-status"": ""DYNAMIC"",
 ""server"": ""cloudflare"",
 ""cf-ray"": ""81ed58b53f8907a3-HKG"",
 }
 }})
 }
 }
 else if (url == 'https://op-prod-tr.ozan.com/api/users/update-mobile-number') {
 console.log($request)
 if (!$request.body.includes('1(')) {
 $done({})
 }
 console.log($request.body)
 var newbody = $request.body.replaceAll(/1\((\d\d\d)\)(\d\d\d)-(\d\d\d\d)/g, '1$1$2$3')
 const payload = {
 body: newbody,
 }
 $notification.post('Ozan修复工具', '', `已将手机号格式修复并更新，请重启重新登录：${$request.body} -> ${newbody}`);
 return $done(payload)
 }
 
 return $done({});
}
main()
#!name=[Misty]-ozanfinalfix
#!desc=Misty


[Script]
ozanfinalfix = type=http-request,pattern=https://op-prod-tr.ozan.com/api/(oauth/token\?grant_type=pre_verification|users/update-mobile-number),requires-body=1,max-size=0,debug=1,script-path=https://gist.githubusercontent.com/NyaMisty/cfd8ed6ca9fcee7cd6b9dc1efaf27484/raw/ozanfinalfix.js


[MITM]
hostname = %INSERT% op-prod-tr.ozan.com"
deno_half_duplex_relay_server.js,"const responseInit = {
 headers: {
 ""Cache-Control"": ""no-cache"",
 ""Content-Type"": ""text/plain; charset=UTF-8"",
 ""Cross-Origin-Opener-Policy"": ""unsafe-none"",
 ""Cross-Origin-Embedder-Policy"": ""unsafe-none"",
 ""Access-Control-Allow-Origin"": ""*"",
 ""Access-Control-Allow-Private-Network"": ""true"",
 ""Access-Control-Allow-Headers"": ""Access-Control-Request-Private-Network"",
 ""Access-Control-Allow-Methods"": ""OPTIONS,POST,GET,HEAD,QUERY"",
 },
};


const map = new Map();


class HalfDuplexStreamController {
 constructor(request) {
 this.request = request;
 ({ readable: this.readable, writable: this.writable } =
 new TransformStream());
 this.writer = this.writable.getWriter();
 this.pendingHalfDuplexStreamController;
 this.pendingHalfDuplexStream = new ReadableStream({
 start: (controller) => {
 this.pendingHalfDuplexStreamController = controller;
 return controller.enqueue(""Done Streaming"");
 },
 }).pipeThrough(new TextEncoderStream());


 this.request.body.pipeThrough(new TextDecoderStream()).pipeTo(
 new WritableStream({
 write: async (value) => {
 console.log(value);
 await this.writer.write(value.toUpperCase());
 },
 close: async () => {
 await this.writer.close();
 this.pendingHalfDuplexStreamController.close();
 console.log(""closed"");
 },
 abort: async (reason) => {
 await this.writer.abort(reason);
 },
 }),
 );
 }
}


for await (
 const conn of Deno.listenTls({
 alpnProtocols: [""h2"", ""http/1.1""],
 port: 8443,
 certFile: ""cert.pem"",
 keyFile: ""key.key"",
 })
) {
 // https://github.com/denoland/deno/issues/10419#issuecomment-830032091
 // https://github.com/denoland/deno/issues/10419#issuecomment-830032911
 (async () => {
 for await (
 const {
        request,
        respondWith,
 } of Deno.serveHttp(conn)
 ) {
 const { value: id } = new URL(request.url).searchParams.values().next();
 console.log(request.method, id);
 if (request.method === ""OPTIONS"" || request.method === ""HEAD"") {
 respondWith(new Response(null, responseInit));
 }
 if (request.method === ""GET"") {
 respondWith(
 new Response(
 map.get(id).readable.pipeThrough(new TextEncoderStream()),
 responseInit,
 ),
 );
 }
 if (request.method === ""POST"" || /^query$/i.test(request.method)) {
 try {
 map.set(id, new HalfDuplexStreamController(request));
 await Promise.race([
 respondWith(
 new Response(map.get(id).pendingHalfDuplexStream, responseInit),
 ),
 Promise.resolve(),
 ]);
 } catch (e) {
 console.log(e);
 }
 }
 }
 })();
}
// Chromium-based browsers
async function halfDuplexStream(id = self.crypto.randomUUID()) {
 const { readable, writable } = new TransformStream();
 const writer = writable.getWriter();


 const request = fetch(""https://localhost:8443?="" + id, {
 duplex: ""half"",
 method: ""POST"",
 headers: {
 ""Content-Type"": ""text/plain; charset=UTF-8"",
 },
 body: readable.pipeThrough(new TextEncoderStream()),
 }).then((r) => r.body.pipeThrough(new TextDecoderStream())).then((r) =>
 r.pipeTo(
 new WritableStream({
 write(value) {
 console.log(value);
 },
 }),
 )
 ).then(() => ""Done writing stream"").catch((e) => e);


 await new Promise((resolve) => setTimeout(resolve, 1000));
 const response = fetch(""https://localhost:8443?="" + id, {
 headers: {
 ""Content-Type"": ""text/plain; charset=UTF-8"",
 ""Access-Control-Request-Private-Network"": true,
 },
 }).then((r) => r.body.pipeThrough(new TextDecoderStream())).then((r) =>
 r.pipeTo(
 new WritableStream({
 write(value) {
 console.log(value); // ""STREAM""
 },
 }),
 )
 ).then(() => ""Done reading stream"").catch((e) => e);
 return {
    writer,
 promise: Promise.allSettled([request, response]),
 };
}


var { writer, promise } = await halfDuplexStream();
promise.then(console.log, console.error);
// await writer.write(""stream""); "
AmazonS3TransferService.java,"import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import lombok.Getter;
import lombok.RequiredArgsConstructor;


import java.util.Arrays;
import java.util.Map;
import java.util.Optional;
import java.util.concurrent.CompletableFuture;


public interface AmazonS3TransferService {


 String JSON_RECORDS_FIELD = ""Records"";
 String JSON_EVENT_NAME_FIELD = ""eventName"";
 String JSON_S3_FIELD = ""s3"";
 String JSON_S3_OBJECT_FIELD = ""object"";
 String JSON_KEY_FIELD = ""key"";


 CompletableFuture<Void> transferFileFromBucket(AwsAction action, String key);


 CompletableFuture<Void> downloadPodTemplateBucket();


 default Optional<Map.Entry<AwsAction, String>> parseDirectoryAltered(JsonObject provided) {
 if (!provided.has(JSON_RECORDS_FIELD)) {
 return Optional.empty();
        }


 JsonArray recordsArray = provided.get(JSON_RECORDS_FIELD).getAsJsonArray();
 JsonObject eventInfoObject = recordsArray.get(0).getAsJsonObject();


 if (eventInfoObject == null) {
 return Optional.empty();
        }


 AwsAction action = AwsAction.getByAwsEventName(eventInfoObject.get(JSON_EVENT_NAME_FIELD).getAsString()).orElse(null);
 if (action == null) {
 return Optional.empty();
        }


 Optional<JsonObject> optional = recordsArray.asList()
                .stream()
                .filter(JsonElement::isJsonObject)
                .map(JsonElement::getAsJsonObject)
                .filter(filtered -> filtered.has(JSON_S3_FIELD))
                .map(filtered -> filtered.get(JSON_S3_FIELD).getAsJsonObject())
                .findFirst();


 if (optional.isEmpty()) {
 return Optional.empty();
        }


 JsonObject s3Object = optional.get();
 if (!s3Object.has(JSON_S3_OBJECT_FIELD)) {
 return Optional.empty();
        }


 JsonObject infoObject = s3Object.get(JSON_S3_OBJECT_FIELD).getAsJsonObject();
 if (infoObject == null) {
 return Optional.empty();
        }


 if (!infoObject.has(JSON_KEY_FIELD)) {
 return Optional.empty();
        }


 String key = infoObject.get(JSON_KEY_FIELD).getAsString();
 return Optional.of(Map.entry(action, key));
    }


 @RequiredArgsConstructor
 @Getter
 enum AwsAction {
 DELETE(""ObjectRemoved:DeleteMarkerCreated""),
 CREATE(""ObjectCreated:Put"");


 private final String awsEventName;


 public static Optional<AwsAction> getByAwsEventName(String name) {
 return Arrays.stream(AwsAction.values())
                    .filter(action -> action.getAwsEventName().equalsIgnoreCase(name))
                    .findFirst();
        }
    }
}"
HTML5StorageMultidimensional.js,"/**
 *
 * MOVED TO: https://github.com/iFind/html5MultidimensionalStorage
 *
 * This methods extends the default HTML5 Storage object and add support
 * to set and get multidimensional data
 * 
 * @example Storage.setObj('users.albums.sexPistols',""blah"");
 * @example Storage.setObj('users.albums.sexPistols',{ sid : ""My Way"", nancy : ""Bitch"" });
 * @example Storage.setObj('users.albums.sexPistols.sid',""Other songs"");
 * 
 * @example Storage.getObj('users');
 * @example Storage.getObj('users.albums');
 * @example Storage.getObj('users.albums.sexPistols');
 * @example Storage.getObj('users.albums.sexPistols.sid');
 * @example Storage.getObj('users.albums.sexPistols.nancy');
 * 
 * This is just a prototype and is not recommended to use at production apps
 * USE AT YOUR OWN RISK
 * 
 * @author Klederson Bueno <klederson@klederson.com>
 */
//Add Storage support for objects
Storage.prototype.__walker = function(path,o) {
 //Validate if path is an object otherwise returns false
 if(typeof path !== ""object"")
 return false;
 
 if(path.length == 0)
 return o;
 
 for(i in path){
 var prop = path[i]; 
 //Check if path step exists
 if(o.hasOwnProperty(prop)){
 var val = o[prop]; 
 if(typeof val == 'object'){
 path.splice(0,1);
 return this.__walker(path,val);
 } else {
 return val;
 }
 }
 }
}


Storage.prototype.setObj = function(key, value) {
 
 var path = key.split('.');


 //First level is always the localStorage key pair item
 var _key = path[0];
 var os = JSON.parse(this.getItem(_key)); //general storage key pair element
 path.splice(0,1);
 
 if(os == null) {
 os = {};
 this.setItem(_key,JSON.stringify(os));
 }
 
 var innerWalker = function(path,o) {
 
 //Validate if path is an object otherwise returns false
 if(typeof path !== ""object"")
 return false;
 
 if(path.length == 1) {
 o[path[0]] = value;
 return o;
 }
 
 var val = null;
 
 for(i in path){
 var prop = path[i]; 
 //Check if path step exists
 if(o.hasOwnProperty(prop)) {
 val = o[prop]; 
 if(typeof val == 'object'){
 path.splice(0,1);
 return innerWalker(path,val);
 }
 } else {
 //create depth
 o[prop] = {};
 val = o[prop];
 path.splice(0,1);
 return innerWalker(path,val);
 }
 }
 }
 
 innerWalker(path,os);
 
 this.setItem(_key,JSON.stringify(os));
}


Storage.prototype.getObj = function(key) {
 key = key.split('.');


 //First level is always the localStorage key pair item
 var _key = key[0];
 var o = JSON.parse(this.getItem(_key)); 
 
 if(o == null)
 return false;


 key.splice(0,1);
 
 return this.__walker(key,o);
}"
js-mask-cpf-cnpj.js,"function cnpj(v){
 v=v.replace(/\D/g,"""") //Remove tudo o que não é dígito
 v=v.replace(/^(\d{2})(\d)/,""$1.$2"") //Coloca ponto entre o segundo e o terceiro dígitos
 v=v.replace(/^(\d{2})\.(\d{3})(\d)/,""$1.$2.$3"") //Coloca ponto entre o quinto e o sexto dígitos
 v=v.replace(/\.(\d{3})(\d)/,"".$1/$2"") //Coloca uma barra entre o oitavo e o nono dígitos
 v=v.replace(/(\d{4})(\d)/,""$1-$2"") //Coloca um hífen depois do bloco de quatro dígitos
 return v
}


function cpf(v){
 v=v.replace(/\D/g,"""") //Remove tudo o que não é dígito
 v=v.replace(/(\d{3})(\d)/,""$1.$2"") //Coloca um ponto entre o terceiro e o quarto dígitos
 v=v.replace(/(\d{3})(\d)/,""$1.$2"") //Coloca um ponto entre o terceiro e o quarto dígitos
 //de novo (para o segundo bloco de números)
 v=v.replace(/(\d{3})(\d{1,2})$/,""$1-$2"") //Coloca um hífen entre o terceiro e o quarto dígitos
 return v
}"
plist2hashcat.py,"#!/usr/bin/env python


""""""Utilities for writing code that runs on Python 2 and 3""""""


import operator
import sys
import types


__author__ = ""Benjamin Peterson <benjamin@python.org>""
__version__ = ""1.2.0""


""""""
six is under MIT License

Copyright (c) 2010-2011 Benjamin Peterson

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the ""Software""), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
the Software, and to permit persons to whom the Software is furnished to do so,
subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.""""""




# True if we are running on Python 3.
PY3 = sys.version_info[0] == 3


if PY3:
 string_types = str,
 integer_types = int,
 class_types = type,
 text_type = str
 binary_type = bytes


 MAXSIZE = sys.maxsize
else:
 string_types = basestring,
 integer_types = (int, long)
 class_types = (type, types.ClassType)
 text_type = unicode
 binary_type = str


 if sys.platform == ""java"":
 # Jython always uses 32 bits.
 MAXSIZE = int((1 << 31) - 1)
 else:
 # It's possible to have sizeof(long) != sizeof(Py_ssize_t).
 class X(object):
 def __len__(self):
 return 1 << 31
 try:
 len(X())
 except OverflowError:
 # 32-bit
 MAXSIZE = int((1 << 31) - 1)
 else:
 # 64-bit
 MAXSIZE = int((1 << 63) - 1)
 del X




def _add_doc(func, doc):
 """"""Add documentation to a function.""""""
 func.__doc__ = doc




def _import_module(name):
 """"""Import module, returning the module after the last dot.""""""
 __import__(name)
 return sys.modules[name]




class _LazyDescr(object):


 def __init__(self, name):
 self.name = name


 def __get__(self, obj, tp):
 result = self._resolve()
 setattr(obj, self.name, result)
 # This is a bit ugly, but it avoids running this again.
 delattr(tp, self.name)
 return result




class MovedModule(_LazyDescr):


 def __init__(self, name, old, new=None):
 super(MovedModule, self).__init__(name)
 if PY3:
 if new is None:
 new = name
 self.mod = new
 else:
 self.mod = old


 def _resolve(self):
 return _import_module(self.mod)




class MovedAttribute(_LazyDescr):


 def __init__(self, name, old_mod, new_mod, old_attr=None, new_attr=None):
 super(MovedAttribute, self).__init__(name)
 if PY3:
 if new_mod is None:
 new_mod = name
 self.mod = new_mod
 if new_attr is None:
 if old_attr is None:
 new_attr = name
 else:
 new_attr = old_attr
 self.attr = new_attr
 else:
 self.mod = old_mod
 if old_attr is None:
 old_attr = name
 self.attr = old_attr


 def _resolve(self):
 module = _import_module(self.mod)
 return getattr(module, self.attr)






class _MovedItems(types.ModuleType):
 """"""Lazy loading of moved objects""""""




_moved_attributes = [
 MovedAttribute(""cStringIO"", ""cStringIO"", ""io"", ""StringIO""),
 MovedAttribute(""filter"", ""itertools"", ""builtins"", ""ifilter"", ""filter""),
 MovedAttribute(""input"", ""__builtin__"", ""builtins"", ""raw_input"", ""input""),
 MovedAttribute(""map"", ""itertools"", ""builtins"", ""imap"", ""map""),
 MovedAttribute(""reload_module"", ""__builtin__"", ""imp"", ""reload""),
 MovedAttribute(""reduce"", ""__builtin__"", ""functools""),
 MovedAttribute(""StringIO"", ""StringIO"", ""io""),
 MovedAttribute(""xrange"", ""__builtin__"", ""builtins"", ""xrange"", ""range""),
 MovedAttribute(""zip"", ""itertools"", ""builtins"", ""izip"", ""zip""),


 MovedModule(""builtins"", ""__builtin__""),
 MovedModule(""configparser"", ""ConfigParser""),
 MovedModule(""copyreg"", ""copy_reg""),
 MovedModule(""http_cookiejar"", ""cookielib"", ""http.cookiejar""),
 MovedModule(""http_cookies"", ""Cookie"", ""http.cookies""),
 MovedModule(""html_entities"", ""htmlentitydefs"", ""html.entities""),
 MovedModule(""html_parser"", ""HTMLParser"", ""html.parser""),
 MovedModule(""http_client"", ""httplib"", ""http.client""),
 MovedModule(""BaseHTTPServer"", ""BaseHTTPServer"", ""http.server""),
 MovedModule(""CGIHTTPServer"", ""CGIHTTPServer"", ""http.server""),
 MovedModule(""SimpleHTTPServer"", ""SimpleHTTPServer"", ""http.server""),
 MovedModule(""cPickle"", ""cPickle"", ""pickle""),
 MovedModule(""queue"", ""Queue""),
 MovedModule(""reprlib"", ""repr""),
 MovedModule(""socketserver"", ""SocketServer""),
 MovedModule(""tkinter"", ""Tkinter""),
 MovedModule(""tkinter_dialog"", ""Dialog"", ""tkinter.dialog""),
 MovedModule(""tkinter_filedialog"", ""FileDialog"", ""tkinter.filedialog""),
 MovedModule(""tkinter_scrolledtext"", ""ScrolledText"", ""tkinter.scrolledtext""),
 MovedModule(""tkinter_simpledialog"", ""SimpleDialog"", ""tkinter.simpledialog""),
 MovedModule(""tkinter_tix"", ""Tix"", ""tkinter.tix""),
 MovedModule(""tkinter_constants"", ""Tkconstants"", ""tkinter.constants""),
 MovedModule(""tkinter_dnd"", ""Tkdnd"", ""tkinter.dnd""),
 MovedModule(""tkinter_colorchooser"", ""tkColorChooser"",
 ""tkinter.colorchooser""),
 MovedModule(""tkinter_commondialog"", ""tkCommonDialog"",
 ""tkinter.commondialog""),
 MovedModule(""tkinter_tkfiledialog"", ""tkFileDialog"", ""tkinter.filedialog""),
 MovedModule(""tkinter_font"", ""tkFont"", ""tkinter.font""),
 MovedModule(""tkinter_messagebox"", ""tkMessageBox"", ""tkinter.messagebox""),
 MovedModule(""tkinter_tksimpledialog"", ""tkSimpleDialog"",
 ""tkinter.simpledialog""),
 MovedModule(""urllib_robotparser"", ""robotparser"", ""urllib.robotparser""),
 MovedModule(""winreg"", ""_winreg""),
]
for attr in _moved_attributes:
 setattr(_MovedItems, attr.name, attr)
del attr


moves = sys.modules[""six.moves""] = _MovedItems(""moves"")




def add_move(move):
 """"""Add an item to six.moves.""""""
 setattr(_MovedItems, move.name, move)




def remove_move(name):
 """"""Remove item from six.moves.""""""
 try:
 delattr(_MovedItems, name)
 except AttributeError:
 try:
 del moves.__dict__[name]
 except KeyError:
 raise AttributeError(""no such move, %r"" % (name,))




if PY3:
 _meth_func = ""__func__""
 _meth_self = ""__self__""


 _func_code = ""__code__""
 _func_defaults = ""__defaults__""


 _iterkeys = ""keys""
 _itervalues = ""values""
 _iteritems = ""items""
else:
 _meth_func = ""im_func""
 _meth_self = ""im_self""


 _func_code = ""func_code""
 _func_defaults = ""func_defaults""


 _iterkeys = ""iterkeys""
 _itervalues = ""itervalues""
 _iteritems = ""iteritems""




try:
 advance_iterator = next
except NameError:
 def advance_iterator(it):
 return it.next()
next = advance_iterator




if PY3:
 def get_unbound_function(unbound):
 return unbound


 Iterator = object


 def callable(obj):
 return any(""__call__"" in klass.__dict__ for klass in type(obj).__mro__)
else:
 def get_unbound_function(unbound):
 return unbound.im_func


 class Iterator(object):


 def next(self):
 return type(self).__next__(self)


 callable = callable
_add_doc(get_unbound_function,
 """"""Get the function out of a possibly unbound function"""""")




get_method_function = operator.attrgetter(_meth_func)
get_method_self = operator.attrgetter(_meth_self)
get_function_code = operator.attrgetter(_func_code)
get_function_defaults = operator.attrgetter(_func_defaults)




def iterkeys(d):
 """"""Return an iterator over the keys of a dictionary.""""""
 return iter(getattr(d, _iterkeys)())


def itervalues(d):
 """"""Return an iterator over the values of a dictionary.""""""
 return iter(getattr(d, _itervalues)())


def iteritems(d):
 """"""Return an iterator over the (key, value) pairs of a dictionary.""""""
 return iter(getattr(d, _iteritems)())




if PY3:
 def b(s):
 return s.encode(""latin-1"")
 def u(s):
 return s
 if sys.version_info[1] <= 1:
 def int2byte(i):
 return bytes((i,))
 else:
 # This is about 2x faster than the implementation above on 3.2+
 int2byte = operator.methodcaller(""to_bytes"", 1, ""big"")
 import io
 StringIO = io.StringIO
 BytesIO = io.BytesIO
else:
 def b(s):
 return s
 def u(s):
 return unicode(s, ""unicode_escape"")
 int2byte = chr
 import StringIO
 StringIO = BytesIO = StringIO.StringIO
_add_doc(b, """"""Byte literal"""""")
_add_doc(u, """"""Text literal"""""")




if PY3:
 import builtins
 exec_ = getattr(builtins, ""exec"")




 def reraise(tp, value, tb=None):
 if value.__traceback__ is not tb:
 raise value.with_traceback(tb)
 raise value




 print_ = getattr(builtins, ""print"")
 del builtins


else:
 def exec_(code, globs=None, locs=None):
 """"""Execute code in a namespace.""""""
 if globs is None:
 frame = sys._getframe(1)
 globs = frame.f_globals
 if locs is None:
 locs = frame.f_locals
 del frame
 elif locs is None:
 locs = globs
 exec(""""""exec code in globs, locs"""""")




 exec_(""""""def reraise(tp, value, tb=None):
    raise tp, value, tb
"""""")




 def print_(*args, **kwargs):
 """"""The new-style print function.""""""
 fp = kwargs.pop(""file"", sys.stdout)
 if fp is None:
 return
 def write(data):
 if not isinstance(data, basestring):
 data = str(data)
 fp.write(data)
 want_unicode = False
 sep = kwargs.pop(""sep"", None)
 if sep is not None:
 if isinstance(sep, unicode):
 want_unicode = True
 elif not isinstance(sep, str):
 raise TypeError(""sep must be None or a string"")
 end = kwargs.pop(""end"", None)
 if end is not None:
 if isinstance(end, unicode):
 want_unicode = True
 elif not isinstance(end, str):
 raise TypeError(""end must be None or a string"")
 if kwargs:
 raise TypeError(""invalid keyword arguments to print()"")
 if not want_unicode:
 for arg in args:
 if isinstance(arg, unicode):
 want_unicode = True
 break
 if want_unicode:
 newline = unicode(""\n"")
 space = unicode("" "")
 else:
 newline = ""\n""
 space = "" ""
 if sep is None:
 sep = space
 if end is None:
 end = newline
 for i, arg in enumerate(args):
 if i:
 write(sep)
 write(arg)
 write(end)


_add_doc(reraise, """"""Reraise an exception."""""")




def with_metaclass(meta, base=object):
 """"""Create a base class with a metaclass.""""""
 return meta(""NewBase"", (base,), {})




""""""
biplist is under BSD license

Copyright (c) 2010, Andrew Wooster
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright notice,
      this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of biplist nor the names of its contributors may be
      used to endorse or promote products derived from this software without
      specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE""""""


""""""biplist -- a library for reading and writing binary property list files.

Binary Property List (plist) files provide a faster and smaller serialization
format for property lists on OS X. This is a library for generating binary
plists which can be read by OS X, iOS, or other clients.

The API models the plistlib API, and will call through to plistlib when
XML serialization or deserialization is required.

To generate plists with UID values, wrap the values with the Uid object. The
value must be an int.

To generate plists with NSData/CFData values, wrap the values with the
Data object. The value must be a string.

Date values can only be datetime.datetime objects.

The exceptions InvalidPlistException and NotBinaryPlistException may be
thrown to indicate that the data cannot be serialized or deserialized as
a binary plist.

Plist generation example:

    from biplist import *
    from datetime import datetime
    plist = {'aKey':'aValue',
             '0':1.322,
             'now':datetime.now(),
             'list':[1,2,3],
             'tuple':('a','b','c')
             }
    try:
        writePlist(plist, ""example.plist"")
    except (InvalidPlistException, NotBinaryPlistException), e:
        print ""Something bad happened:"", e

Plist parsing example:

    from biplist import *
    try:
        plist = readPlist(""example.plist"")
        print plist
    except (InvalidPlistException, NotBinaryPlistException), e:
        print ""Not a plist:"", e
""""""


import sys
from collections import namedtuple
import calendar
import datetime
import math
import plistlib
from struct import pack, unpack
import sys
import time


# import six


__all__ = [
 'Uid', 'Data', 'readPlist', 'writePlist', 'readPlistFromString',
 'writePlistToString', 'InvalidPlistException', 'NotBinaryPlistException'
]


apple_reference_date_offset = 978307200


class Uid(int):
 """"""Wrapper around integers for representing UID values. This
       is used in keyed archiving.""""""
 def __repr__(self):
 return ""Uid(%d)"" % self


class Data(binary_type):
 """"""Wrapper around str types for representing Data values.""""""
 pass


class InvalidPlistException(Exception):
 """"""Raised when the plist is incorrectly formatted.""""""
 pass


class NotBinaryPlistException(Exception):
 """"""Raised when a binary plist was expected but not encountered.""""""
 pass


def readPlist(pathOrFile):
 """"""Raises NotBinaryPlistException, InvalidPlistException""""""
 didOpen = False
 result = None
 if isinstance(pathOrFile, (binary_type, text_type)):
 pathOrFile = open(pathOrFile, 'rb')
 didOpen = True
 try:
 reader = PlistReader(pathOrFile)
 result = reader.parse()
 except NotBinaryPlistException as e:
 try:
 pathOrFile.seek(0)
 result = plistlib.readPlist(pathOrFile)
 result = wrapDataObject(result, for_binary=True)
 except Exception as e:
 raise InvalidPlistException(e)
 if didOpen:
 pathOrFile.close()
 return result


def wrapDataObject(o, for_binary=False):
 if isinstance(o, Data) and not for_binary:
 o = plistlib.Data(o)
 elif isinstance(o, plistlib.Data) and for_binary:
 o = Data(o.data)
 elif isinstance(o, tuple):
 o = wrapDataObject(list(o), for_binary)
 o = tuple(o)
 elif isinstance(o, list):
 for i in range(len(o)):
 o[i] = wrapDataObject(o[i], for_binary)
 elif isinstance(o, dict):
 for k in o:
 o[k] = wrapDataObject(o[k], for_binary)
 return o


def writePlist(rootObject, pathOrFile, binary=True):
 if not binary:
 rootObject = wrapDataObject(rootObject, binary)
 return plistlib.writePlist(rootObject, pathOrFile)
 else:
 didOpen = False
 if isinstance(pathOrFile, (six.binary_type, six.text_type)):
 pathOrFile = open(pathOrFile, 'wb')
 didOpen = True
 writer = PlistWriter(pathOrFile)
 result = writer.writeRoot(rootObject)
 if didOpen:
 pathOrFile.close()
 return result


def readPlistFromString(data):
 return readPlist(six.BytesIO(data))


def writePlistToString(rootObject, binary=True):
 if not binary:
 rootObject = wrapDataObject(rootObject, binary)
 if six.PY3:
 return plistlib.writePlistToBytes(rootObject)
 else:
 return plistlib.writePlistToString(rootObject)
 else:
 io = BytesIO()
 writer = PlistWriter(io)
 writer.writeRoot(rootObject)
 return io.getvalue()


def is_stream_binary_plist(stream):
 stream.seek(0)
 header = stream.read(7)
 if header == b('bplist0'):
 return True
 else:
 return False


PlistTrailer = namedtuple('PlistTrailer', 'offsetSize, objectRefSize, offsetCount, topLevelObjectNumber, offsetTableOffset')
PlistByteCounts = namedtuple('PlistByteCounts', 'nullBytes, boolBytes, intBytes, realBytes, dateBytes, dataBytes, stringBytes, uidBytes, arrayBytes, setBytes, dictBytes')


class PlistReader(object):
 file = None
 contents = ''
 offsets = None
 trailer = None
 currentOffset = 0


 def __init__(self, fileOrStream):
 """"""Raises NotBinaryPlistException.""""""
 self.reset()
 self.file = fileOrStream


 def parse(self):
 return self.readRoot()


 def reset(self):
 self.trailer = None
 self.contents = ''
 self.offsets = []
 self.currentOffset = 0


 def readRoot(self):
 result = None
 self.reset()
 # Get the header, make sure it's a valid file.
 if not is_stream_binary_plist(self.file):
 raise NotBinaryPlistException()
 self.file.seek(0)
 self.contents = self.file.read()
 if len(self.contents) < 32:
 raise InvalidPlistException(""File is too short."")
 trailerContents = self.contents[-32:]
 try:
 self.trailer = PlistTrailer._make(unpack(""!xxxxxxBBQQQ"", trailerContents))
 offset_size = self.trailer.offsetSize * self.trailer.offsetCount
 offset = self.trailer.offsetTableOffset
 offset_contents = self.contents[offset:offset+offset_size]
 offset_i = 0
 while offset_i < self.trailer.offsetCount:
 begin = self.trailer.offsetSize*offset_i
 tmp_contents = offset_contents[begin:begin+self.trailer.offsetSize]
 tmp_sized = self.getSizedInteger(tmp_contents, self.trailer.offsetSize)
 self.offsets.append(tmp_sized)
 offset_i += 1
 self.setCurrentOffsetToObjectNumber(self.trailer.topLevelObjectNumber)
 result = self.readObject()
 except TypeError as e:
 raise InvalidPlistException(e)
 return result


 def setCurrentOffsetToObjectNumber(self, objectNumber):
 self.currentOffset = self.offsets[objectNumber]


 def readObject(self):
 result = None
 tmp_byte = self.contents[self.currentOffset:self.currentOffset+1]
 marker_byte = unpack(""!B"", tmp_byte)[0]
 format = (marker_byte >> 4) & 0x0f
 extra = marker_byte & 0x0f
 self.currentOffset += 1


 def proc_extra(extra):
 if extra == 0b1111:
 #self.currentOffset += 1
 extra = self.readObject()
 return extra


 # bool, null, or fill byte
 if format == 0b0000:
 if extra == 0b0000:
 result = None
 elif extra == 0b1000:
 result = False
 elif extra == 0b1001:
 result = True
 elif extra == 0b1111:
 pass # fill byte
 else:
 raise InvalidPlistException(""Invalid object found at offset: %d"" % (self.currentOffset - 1))
 # int
 elif format == 0b0001:
 extra = proc_extra(extra)
 result = self.readInteger(pow(2, extra))
 # real
 elif format == 0b0010:
 extra = proc_extra(extra)
 result = self.readReal(extra)
 # date
 elif format == 0b0011 and extra == 0b0011:
 result = self.readDate()
 # data
 elif format == 0b0100:
 extra = proc_extra(extra)
 result = self.readData(extra)
 # ascii string
 elif format == 0b0101:
 extra = proc_extra(extra)
 result = self.readAsciiString(extra)
 # Unicode string
 elif format == 0b0110:
 extra = proc_extra(extra)
 result = self.readUnicode(extra)
 # uid
 elif format == 0b1000:
 result = self.readUid(extra)
 # array
 elif format == 0b1010:
 extra = proc_extra(extra)
 result = self.readArray(extra)
 # set
 elif format == 0b1100:
 extra = proc_extra(extra)
 result = set(self.readArray(extra))
 # dict
 elif format == 0b1101:
 extra = proc_extra(extra)
 result = self.readDict(extra)
 else:
 raise InvalidPlistException(""Invalid object found: {format: %s, extra: %s}"" % (bin(format), bin(extra)))
 return result


 def readInteger(self, bytes):
 result = 0
 original_offset = self.currentOffset
 data = self.contents[self.currentOffset:self.currentOffset+bytes]
 result = self.getSizedInteger(data, bytes)
 self.currentOffset = original_offset + bytes
 return result


 def readReal(self, length):
 result = 0.0
 to_read = pow(2, length)
 data = self.contents[self.currentOffset:self.currentOffset+to_read]
 if length == 2: # 4 bytes
 result = unpack('>f', data)[0]
 elif length == 3: # 8 bytes
 result = unpack('>d', data)[0]
 else:
 raise InvalidPlistException(""Unknown real of length %d bytes"" % to_read)
 return result


 def readRefs(self, count):
 refs = []
 i = 0
 while i < count:
 fragment = self.contents[self.currentOffset:self.currentOffset+self.trailer.objectRefSize]
 ref = self.getSizedInteger(fragment, len(fragment))
 refs.append(ref)
 self.currentOffset += self.trailer.objectRefSize
 i += 1
 return refs


 def readArray(self, count):
 result = []
 values = self.readRefs(count)
 i = 0
 while i < len(values):
 self.setCurrentOffsetToObjectNumber(values[i])
 value = self.readObject()
 result.append(value)
 i += 1
 return result


 def readDict(self, count):
 result = {}
 keys = self.readRefs(count)
 values = self.readRefs(count)
 i = 0
 while i < len(keys):
 self.setCurrentOffsetToObjectNumber(keys[i])
 key = self.readObject()
 self.setCurrentOffsetToObjectNumber(values[i])
 value = self.readObject()
 result[key] = value
 i += 1
 return result


 def readAsciiString(self, length):
 result = unpack(""!%ds"" % length, self.contents[self.currentOffset:self.currentOffset+length])[0]
 self.currentOffset += length
 return result


 def readUnicode(self, length):
 actual_length = length*2
 data = self.contents[self.currentOffset:self.currentOffset+actual_length]
 # unpack not needed?!! data = unpack("">%ds"" % (actual_length), data)[0]
 self.currentOffset += actual_length
 return data.decode('utf_16_be')


 def readDate(self):
 global apple_reference_date_offset
 result = unpack("">d"", self.contents[self.currentOffset:self.currentOffset+8])[0]
 result = datetime.datetime.utcfromtimestamp(result + apple_reference_date_offset)
 self.currentOffset += 8
 return result


 def readData(self, length):
 result = self.contents[self.currentOffset:self.currentOffset+length]
 self.currentOffset += length
 return Data(result)


 def readUid(self, length):
 return Uid(self.readInteger(length+1))


 def getSizedInteger(self, data, bytes):
 result = 0
 # 1, 2, and 4 byte integers are unsigned
 if bytes == 1:
 result = unpack('>B', data)[0]
 elif bytes == 2:
 result = unpack('>H', data)[0]
 elif bytes == 4:
 result = unpack('>L', data)[0]
 elif bytes == 8:
 result = unpack('>q', data)[0]
 else:
 raise InvalidPlistException(""Encountered integer longer than 8 bytes."")
 return result


class HashableWrapper(object):
 def __init__(self, value):
 self.value = value
 def __repr__(self):
 return ""<HashableWrapper: %s>"" % [self.value]


class BoolWrapper(object):
 def __init__(self, value):
 self.value = value
 def __repr__(self):
 return ""<BoolWrapper: %s>"" % self.value


# Libraries end here, program starts
# Written by Dhiru Kholia <dhiru at openwall.com> in September of 2012
# My code is under ""Simplified BSD License""
# Adapted by Niklas Hennigs <nueh@mac.com> for hashcat January 2014


import binascii
import getpass
import os


def process_file(filename):
 try:
 p1 = readPlist(filename)
 except IOError, e:
 print >> sys.stderr, ""%s : %s"" % (filename, str(e))
 return -1
 except InvalidPlistException:
 print >> sys.stderr, ""%s is not a plist file!"" % filename
 return -1


 s = StringIO(p1.get('ShadowHashData', [None])[0])
 if not s:
 sys.stderr.write(""%s : could not find ShadowHashData\n"" % filename)
 return -2


 try:
 p2 = readPlist(s)
 except Exception:
 e = sys.exc_info()[1]
 sys.stderr.write(""%s : %s\n"" % (filename, str(e)))
 return -3


 d = p2.get('SALTED-SHA512-PBKDF2', None)
 if not d:
 sys.stderr.write(""%s does not contain SALTED-SHA512-PBKDF2\n"" % filename)
 return -4


 salt = d.get('salt')
 entropy = d.get('entropy')
 iterations = d.get('iterations')
 salth = binascii.hexlify(salt)
 entropyh = binascii.hexlify(entropy)


 name = p1.get('name', [""user""])[0]


 sys.stdout.write(""%s:$ml$%d$%s$%s\n"" % \
            (name, iterations, salth, entropyh[0:128]))


 # from passlib.hash import grub_pbkdf2_sha512
 # hash = grub_pbkdf2_sha512.encrypt(""password"", rounds=iterations, salt=salt)
 # print hash


if __name__ == ""__main__"":
 if len(sys.argv) < 2:
 print >> sys.stderr, ""Usage: %s <Mountain Lion and later .plist files>\nUse with hashcat's '--username' option\nPlist: /private/var/db/dslocal/nodes/Default/users/%s.plist"" % (os.path.basename(__file__), getpass.getuser())
 sys.exit(-1)


 for i in range(1, len(sys.argv)):
 process_file(sys.argv[i])"
main.py,"import requests
import json
import gradio as gr


url = ""http://localhost:11434/api/generate""


headers = {
 'Content-Type': 'application/json',
}


conversation_history = []


def generate_response(prompt):
 conversation_history.append(prompt)


 full_prompt = ""\n"".join(conversation_history)


 data = {
 ""model"": ""mistral"",
 ""stream"": False,
 ""prompt"": full_prompt,
    }


 response = requests.post(url, headers=headers, data=json.dumps(data))


 if response.status_code == 200:
 response_text = response.text
 data = json.loads(response_text)
 actual_response = data[""response""]
 conversation_history.append(actual_response)
 return actual_response
 else:
 print(""Error:"", response.status_code, response.text)
 return None


iface = gr.Interface(
 fn=generate_response,
 inputs=gr.inputs.Textbox(lines=2, placeholder=""Enter your prompt here...""),
 outputs=""text""
)


iface.launch()"
export-team-membership-roster.js,"// ****************************************************************************************************************************
// Abstract:
// This script is just a quick trick to export the owners and members of a team as a CSV file without administrator permissions.
// The following properties are exported: Display name, Title, Location, Role, Tags, UPN(email)
//
// Usage:
// 1. Open the team in your web browser: https://teams.microsoft.com
// 2. Select ""Manage team"" from its menu.
// 3. Select the ""Members"" tab.
// 4. Expand the ""Owners"" and ""Members and guests"" sections.
// 5. Scroll down to the end of the owners and members lists to include all of them in the export.
// 6. Open your browser's console by pressing CTRL+SHIFT+i (developer tools).
// 7. In the developer tools, select the Console tab - at the bottom of the console is the input field.
// 8. Click the RAW button of this Gist, copy the code, and paste this script to the input field and press ""enter"" key.
// 9. The CSV file download should start automatically.
//
// Link mentioned in old blogs/posts:
// - http://web.archive.org/web/20220119111816/https://developers.salestim.com/blog/export-microsoft-teams-team-members/
// ****************************************************************************************************************************


$(function () {


 // **************
 // Initialization
 // **************
 const csvFileName = 'team-membership-roster-export.csv'
 const csvDelimiter = '"",""'
 const csvHeader = '""' + 'DisplayName' + csvDelimiter + 'Title' + csvDelimiter + 'Location' + csvDelimiter + 'Role' + csvDelimiter + 'Tags' + csvDelimiter + 'UPN' + '""' + '\r\n' // CSV header row
 let csvContent = csvHeader // Initialize CSV content
 const rosterLength = $('.td-member-display-name').length // Number of visible members


 // Check if we're an owner of the team
 let roleSelector = '.td-member-role' // Consider we're not an owner by default
 if ($('.td-member-editable-role').length > 0) {
 roleSelector = '.td-member-editable-role' // Override if we're an owner
 }


 // ************************
 // Iterate over each member
 // ************************
 for (let index = 0; index < rosterLength; index++) {
 // Extract the display name, title, location, role, and UPN
 let displayName = $('.td-member-display-name').eq(index).text()
 const title = $('.td-member-title').eq(index).text()
 const location = $('.td-member-location').eq(index).text()
 let role = $(roleSelector).eq(index).text()
 let upn = $('.td-member-photo img').eq(index).attr('upn')
 // If user is an external guest, return their email, set role to Guest, and fix up display name
 if (upn.includes(""#EXT#"")) {
 let encEmail = upn.split('#')[0];
 let lastIndex = encEmail.lastIndexOf('_');
 let extEmail = encEmail.substring(0, lastIndex) + '@' + encEmail.substring(lastIndex + 1);
 upn = extEmail;
 role = 'Guest'
 displayName = displayName.replace(' (Guest)','')
 }
 // Extract tags
 let arrTags = new Array()
 const numTags = $('.tags-container').eq(index).children().length
 for (let jndex = 0; jndex < numTags - 2; jndex++) {
 arrTags.push($('.tags-container').eq(index).children().eq(jndex).text())
 }
 let tags = arrTags.sort().join('|')
 // Append to the CSV content
 const csvRow = '""' + displayName + csvDelimiter + title + csvDelimiter + location + csvDelimiter + role + csvDelimiter + tags + csvDelimiter + upn + '""' + '\r\n'
 csvContent += csvRow
 }


 // Debug the export to console
 console.info(rosterLength + ' members exported:')
 console.info(csvContent)


 // **********************************************************
 // Dynamically generates a CSV file and triggers its download
 // **********************************************************


 // Create a dynamic ""a"" tag
 var element = document.createElement('a')
 // Set href link with content
 element.setAttribute(
 'href',
 'data:application/json;charset=utf-8,' + encodeURIComponent(csvContent)
 )
 // Set downloaded file name
 element.setAttribute('download', csvFileName)
 // Hide the element and add it to the page
 element.style.display = 'none'
 document.body.appendChild(element)
 // Launch download
 element.click()
 // Remove element
 document.body.removeChild(element)
})"
export-team-membership-roster.js,"// ****************************************************************************************************************************
// Abstract:
// This script is just a quick hack to export the owners and members of a team as a CSV file without administrator permissions.
//
// Usage:
// 1. Open your team
// 2. Select ""Manage team"" from its menu
// 3. Select the ""Members"" tab
// 4. Expand the ""Owners"" and ""Members and guests"" sections
// 5. Make sure to scroll down to the end of the owners and members lists to include all of them in your export (As the members are loaded on demand)
// 6. Open your browser console
// 7. Copy and paste all the content of this script to the console and type ""Enter""
// 8. The CSV file download should start automatically
//
// ToDo:
// - Parse tags to include them in the export
// ****************************************************************************************************************************
// 9/7/2002: added quotes around fields to cater for field values containing commas


$(function() {
 
 // **************
 // Initialization
 // **************
 const csvFileName = 'team-membership-roster-export.csv'
 const csvDelimiter = '"",""'
 const csvLineTerm = '""'
 const csvHeader = '""Display Name' + csvDelimiter + 'Title' + csvDelimiter + 'Location' + csvDelimiter + 'Role' + csvDelimiter + 'UPN""' + '\r\n' // CSV header row
 let csvContent = csvHeader // Initialize CSV content
 const rosterLength = $('.td-member-display-name').length // Number of visible members
 
 // Check if we're an owner of the team
 let roleSelector = '.td-member-role' // Consider we're not an owner by default
 if ($('.td-member-editable-role').length > 0) {
 roleSelector = '.td-member-editable-role' // Override if we're an owner
 }
 
 // ************************
 // Iterate over each member
 // ************************
 for (let index = 0; index < rosterLength; index++) {
 // Extract the display name, title, location and role
 const displayName = $('.td-member-display-name').eq(index).text()
 const title = $('.td-member-title').eq(index).text()
 const location = $('.td-member-location').eq(index).text()
 const role = $(roleSelector).eq(index).text()
 const upn = $('.td-member-photo img').eq(index).attr('upn')
 // Append to the CSV content
 const csvRow = csvLineTerm + displayName + csvDelimiter + title + csvDelimiter + location + csvDelimiter + role + csvDelimiter + upn + csvLineTerm + '\r\n'
 csvContent += csvRow
 }


 // Debug the export to console
 console.info(rosterLength + ' members exported:')
 console.info(csvContent)


 // **********************************************************
 // Dynamically generates a CSV file and triggers its download
 // **********************************************************


 // Create a dynamic ""a"" tag
 var element = document.createElement('a')
 // Set href link with content
 element.setAttribute(
 'href',
 'data:application/json;charset=utf-8,' + encodeURIComponent(csvContent)
 )
 // Set downloaded file name
 element.setAttribute('download', csvFileName)
 // Hide the elemement and add it to the page
 element.style.display = 'none'
 document.body.appendChild(element)
 // Launch download
 element.click()
 // Remove element
 document.body.removeChild(element)
})"
export-team-membership-roster.js,"// ****************************************************************************************************************************
// Abstract:
// This script is just a quick hack to export the owners and members of a team as a CSV file without administrator permissions.
//
// Usage:
// 1. Open your team
// 2. Select ""Manage team"" from its menu
// 3. Select the ""Members"" tab
// 4. Expand the ""Owners"" and ""Members and guests"" sections
// 5. Make sure to scroll down to the end of the owners and members lists to include all of them in your export (As the members are loaded on demand)
// 6. Open your browser console
// 7. Copy and paste all the content of this script to the console and type ""Enter""
// 8. The CSV file download should start automatically
//
// ToDo:
// - Parse tags to include them in the export
// ****************************************************************************************************************************


$(function() {
 
 // **************
 // Initialization
 // **************
 const csvFileName = 'team-membership-roster-export.csv'
 const csvDelimiter = ','
 const csvHeader = 'Display Name' + csvDelimiter + 'Title' + csvDelimiter + 'Location' + csvDelimiter + 'Role' + csvDelimiter + 'UPN' + '\r\n' // CSV header row
 let csvContent = csvHeader // Initialize CSV content
 const rosterLength = $('.td-member-display-name').length // Number of visible members
 
 // Check if we're an owner of the team
 let roleSelector = '.td-member-role' // Consider we're not an owner by default
 if ($('.td-member-editable-role').length > 0) {
 roleSelector = '.td-member-editable-role' // Override if we're an owner
 }
 
 // ************************
 // Iterate over each member
 // ************************
 for (let index = 0; index < rosterLength; index++) {
 // Extract the display name, title, location and role
 const displayName = $('.td-member-display-name').eq(index).text()
 const title = $('.td-member-title').eq(index).text()
 const location = $('.td-member-location').eq(index).text()
 const role = $(roleSelector).eq(index).text()
 const upn = $('.td-member-photo img').eq(index).attr('upn')
 // Append to the CSV content
 const csvRow = displayName + csvDelimiter + title + csvDelimiter + location + csvDelimiter + role + csvDelimiter + upn + '\r\n'
 csvContent += csvRow
 }


 // Debug the export to console
 console.info(rosterLength + ' members exported:')
 console.info(csvContent)


 // **********************************************************
 // Dynamically generates a CSV file and triggers its download
 // **********************************************************


 // Create a dynamic ""a"" tag
 var element = document.createElement('a')
 // Set href link with content
 element.setAttribute(
 'href',
 'data:application/json;charset=utf-8,' + encodeURIComponent(csvContent)
 )
 // Set downloaded file name
 element.setAttribute('download', csvFileName)
 // Hide the elemement and add it to the page
 element.style.display = 'none'
 document.body.appendChild(element)
 // Launch download
 element.click()
 // Remove element
 document.body.removeChild(element)
})"
DrawBounds.cs,"void DrawBounds(Bounds b, float delay=0)
{
 // bottom
 var p1 = new Vector3(b.min.x, b.min.y, b.min.z);
 var p2 = new Vector3(b.max.x, b.min.y, b.min.z);
 var p3 = new Vector3(b.max.x, b.min.y, b.max.z);
 var p4 = new Vector3(b.min.x, b.min.y, b.max.z);


    Debug.DrawLine(p1, p2, Color.blue, delay);
    Debug.DrawLine(p2, p3, Color.red, delay);
    Debug.DrawLine(p3, p4, Color.yellow, delay);
    Debug.DrawLine(p4, p1, Color.magenta, delay);


 // top
 var p5 = new Vector3(b.min.x, b.max.y, b.min.z);
 var p6 = new Vector3(b.max.x, b.max.y, b.min.z);
 var p7 = new Vector3(b.max.x, b.max.y, b.max.z);
 var p8 = new Vector3(b.min.x, b.max.y, b.max.z);


    Debug.DrawLine(p5, p6, Color.blue, delay);
    Debug.DrawLine(p6, p7, Color.red, delay);
    Debug.DrawLine(p7, p8, Color.yellow, delay);
    Debug.DrawLine(p8, p5, Color.magenta, delay);


 // sides
    Debug.DrawLine(p1, p5, Color.white, delay);
    Debug.DrawLine(p2, p6, Color.gray, delay);
    Debug.DrawLine(p3, p7, Color.green, delay);
    Debug.DrawLine(p4, p8, Color.cyan, delay);
}
// https://forum.unity.com/threads/debug-drawbox-function-is-direly-needed.1038499/
public void DrawBox(Vector3 pos, Quaternion rot, Vector3 scale, Color c)
        {
            // create matrix
            Matrix4x4 m = new Matrix4x4();
            m.SetTRS(pos, rot, scale);
 
            var point1 = m.MultiplyPoint(new Vector3(-0.5f, -0.5f, 0.5f));
            var point2 = m.MultiplyPoint(new Vector3(0.5f, -0.5f, 0.5f));
            var point3 = m.MultiplyPoint(new Vector3(0.5f, -0.5f, -0.5f));
            var point4 = m.MultiplyPoint(new Vector3(-0.5f, -0.5f, -0.5f));
 
            var point5 = m.MultiplyPoint(new Vector3(-0.5f, 0.5f, 0.5f));
            var point6 = m.MultiplyPoint(new Vector3(0.5f, 0.5f, 0.5f));
            var point7 = m.MultiplyPoint(new Vector3(0.5f, 0.5f, -0.5f));
            var point8 = m.MultiplyPoint(new Vector3(-0.5f, 0.5f, -0.5f));
 
            Debug.DrawLine(point1, point2, c);
            Debug.DrawLine(point2, point3, c);
            Debug.DrawLine(point3, point4, c);
            Debug.DrawLine(point4, point1, c);
 
            Debug.DrawLine(point5, point6, c);
            Debug.DrawLine(point6, point7, c);
            Debug.DrawLine(point7, point8, c);
            Debug.DrawLine(point8, point5, c);
 
            Debug.DrawLine(point1, point5, c);
            Debug.DrawLine(point2, point6, c);
            Debug.DrawLine(point3, point7, c);
            Debug.DrawLine(point4, point8, c);
 
            // optional axis display
            Debug.DrawRay(m.GetPosition(), m.GetForward(), Color.magenta);
            Debug.DrawRay(m.GetPosition(), m.GetUp(), Color.yellow);
            Debug.DrawRay(m.GetPosition(), m.GetRight(), Color.red);
        }
// https://forum.unity.com/threads/how-to-see-spherecast.759233/#post-5057492
using UnityEngine;
#if UNITY_EDITOR
using Handles = UnityEditor.Handles;
using HandleUtility = UnityEditor.HandleUtility;
#endif


namespace Kit
{
 public struct ColorScope : System.IDisposable
 {
 Color oldColor;
 public ColorScope(Color color)
 {
 oldColor = Gizmos.color;
			Gizmos.color = color == default(Color) ? oldColor : color;
 }


 public void Dispose()
 {
			Gizmos.color = oldColor;
 }
 }


 /// <summary>Gizmo Extension - Static class that extends Unity's gizmo functionallity.</summary>
 public static class GizmosExtend
 {
		#region GizmoDrawFunctions
 /// <summary>- Draws a point.</summary>
 /// <param name='position'>- The point to draw.</param>
 ///  <param name='color'>- The color of the drawn point.</param>
 /// <param name='scale'>- The size of the drawn point.</param>
 public static void DrawPoint(Vector3 position, Color color = default(Color), float scale = 1.0f)
 {
 using (new ColorScope(color))
 {
				Gizmos.DrawRay(position + (Vector3.up * (scale * 0.5f)), -Vector3.up * scale);
				Gizmos.DrawRay(position + (Vector3.right * (scale * 0.5f)), -Vector3.right * scale);
				Gizmos.DrawRay(position + (Vector3.forward * (scale * 0.5f)), -Vector3.forward * scale);
 }
 }


 public static void DrawRay(Vector3 position, Vector3 direction, Color color = default(Color))
 {
 using (new ColorScope(color))
 {
				Gizmos.DrawRay(position, direction);
 }
 }


 /// <summary>Override DrawLine</summary>
 /// <param name=""from""></param>
 /// <param name=""to""></param>
 /// <param name=""color""></param>
 public static void DrawLine(Vector3 from, Vector3 to, Color color = default(Color))
 {
 using (new ColorScope(color))
 {
				Gizmos.DrawLine(from, to);
 }
 }


 /// <summary>- Draws an axis-aligned bounding box.</summary>
 /// <param name='bounds'>- The bounds to draw.</param>
 /// <param name='color'>- The color of the bounds.</param>
 public static void DrawBounds(Bounds bounds, Color color = default(Color))
 {
 Vector3
 ruf = bounds.center + new Vector3(bounds.extents.x, bounds.extents.y, bounds.extents.z),
 rub = bounds.center + new Vector3(bounds.extents.x, bounds.extents.y, -bounds.extents.z),
 luf = bounds.center + new Vector3(-bounds.extents.x, bounds.extents.y, bounds.extents.z),
 lub = bounds.center + new Vector3(-bounds.extents.x, bounds.extents.y, -bounds.extents.z),
 rdf = bounds.center + new Vector3(bounds.extents.x, -bounds.extents.y, bounds.extents.z),
 rdb = bounds.center + new Vector3(bounds.extents.x, -bounds.extents.y, -bounds.extents.z),
 lfd = bounds.center + new Vector3(-bounds.extents.x, -bounds.extents.y, bounds.extents.z),
 lbd = bounds.center + new Vector3(-bounds.extents.x, -bounds.extents.y, -bounds.extents.z);


 using (new ColorScope(color))
 {
				Gizmos.DrawLine(ruf, luf);
				Gizmos.DrawLine(ruf, rub);
				Gizmos.DrawLine(luf, lub);
				Gizmos.DrawLine(rub, lub);


				Gizmos.DrawLine(ruf, rdf);
				Gizmos.DrawLine(rub, rdb);
				Gizmos.DrawLine(luf, lfd);
				Gizmos.DrawLine(lub, lbd);


				Gizmos.DrawLine(rdf, lfd);
				Gizmos.DrawLine(rdf, rdb);
				Gizmos.DrawLine(lfd, lbd);
				Gizmos.DrawLine(lbd, rdb);
 }
 }


 /// <summary>- Draws a circle.</summary>
 /// <param name='position'>- Where the center of the circle will be positioned.</param>
 /// <param name='up'>- The direction perpendicular to the surface of the circle.</param>
 /// <param name='color'>- The color of the circle.</param>
 /// <param name='radius'>- The radius of the circle.</param>
 public static void DrawCircle(Vector3 position, Vector3 up = default(Vector3), Color color = default(Color), float radius = 1.0f)
 {
 up = ((up == default(Vector3)) ? Vector3.up : up).normalized * radius;
 Vector3
 forward = Vector3.Slerp(up, -up, 0.5f),
 right = Vector3.Cross(up, forward).normalized * radius;


 Matrix4x4 matrix = new Matrix4x4()
 {
 m00 = right.x,
 m10 = right.y,
 m20 = right.z,


 m01 = up.x,
 m11 = up.y,
 m21 = up.z,


 m02 = forward.x,
 m12 = forward.y,
 m22 = forward.z
 };


 Vector3
 lastPoint = position + matrix.MultiplyPoint3x4(new Vector3(Mathf.Cos(0), 0, Mathf.Sin(0))),
 nextPoint = Vector3.zero;


 using (new ColorScope(color))
 {
 for (int i = 0; i <= 90; i++)
 {
 nextPoint = position + matrix.MultiplyPoint3x4(
 new Vector3(
							Mathf.Cos((i * 4) * Mathf.Deg2Rad),
 0f,
							Mathf.Sin((i * 4) * Mathf.Deg2Rad)
 )
 );
					Gizmos.DrawLine(lastPoint, nextPoint);
 lastPoint = nextPoint;
 }
 }
 }


 /// <summary>- Draws a cylinder.</summary>
 /// <param name='start'>- The position of one end of the cylinder.</param>
 /// <param name='end'>- The position of the other end of the cylinder.</param>
 /// <param name='color'>- The color of the cylinder.</param>
 /// <param name='radius'>- The radius of the cylinder.</param>
 public static void DrawCylinder(Vector3 start, Vector3 end, Color color = default(Color), float radius = 1.0f)
 {
 Vector3
 up = (end - start).normalized * radius,
 forward = Vector3.Slerp(up, -up, 0.5f),
 right = Vector3.Cross(up, forward).normalized * radius;


 //Radial circles
			DrawCircle(start, up, color, radius);
			DrawCircle(end, -up, color, radius);
			DrawCircle((start + end) * 0.5f, up, color, radius);


 using (new ColorScope(color))
 {
 //Side lines
				Gizmos.DrawLine(start + right, end + right);
				Gizmos.DrawLine(start - right, end - right);


				Gizmos.DrawLine(start + forward, end + forward);
				Gizmos.DrawLine(start - forward, end - forward);


 //Start endcap
				Gizmos.DrawLine(start - right, start + right);
				Gizmos.DrawLine(start - forward, start + forward);


 //End endcap
				Gizmos.DrawLine(end - right, end + right);
				Gizmos.DrawLine(end - forward, end + forward);
 }
 }


 /// <summary>- Draws a cone.</summary>
 /// <param name='position'>- The position for the tip of the cone.</param>
 /// <param name='direction'>- The direction for the cone to get wider in.</param>
 /// <param name='color'>- The color of the cone.</param>
 /// <param name='angle'>- The angle of the cone.</param>
 public static void DrawCone(Vector3 position, Vector3 direction, Color color = default(Color), float angle = 45)
 {
 float length = direction.magnitude;
 angle = Mathf.Clamp(angle, 0f, 90f);


 Vector3
 forward = direction,
 up = Vector3.Slerp(forward, -forward, 0.5f),
 right = Vector3.Cross(forward, up).normalized * length,
 slerpedVector = Vector3.Slerp(forward, up, angle / 90.0f);


 Plane farPlane = new Plane(-direction, position + forward);
 Ray distRay = new Ray(position, slerpedVector);


 float dist;
			farPlane.Raycast(distRay, out dist);


 using (new ColorScope(color))
 {
				Gizmos.DrawRay(position, slerpedVector.normalized * dist);
				Gizmos.DrawRay(position, Vector3.Slerp(forward, -up, angle / 90.0f).normalized * dist);
				Gizmos.DrawRay(position, Vector3.Slerp(forward, right, angle / 90.0f).normalized * dist);
				Gizmos.DrawRay(position, Vector3.Slerp(forward, -right, angle / 90.0f).normalized * dist);


 }
			DrawCircle(position + forward, direction, color, (forward - (slerpedVector.normalized * dist)).magnitude);
			DrawCircle(position + (forward * 0.5f), direction, color, ((forward * 0.5f) - (slerpedVector.normalized * (dist * 0.5f))).magnitude);
 }


 /// <summary>- Draws an arrow.</summary>
 /// <param name='position'>- The start position of the arrow.</param>
 /// <param name='direction'>- The direction the arrow will point in.</param>
 /// <param name='color'>- The color of the arrow.</param>
 /// <param name=""angle"">- The angle of arrow head.0 ~ 90f</param>
 /// <param name=""headLength"">- The angle length of arrow head. 0 ~ 1 in percent</param>
 public static void DrawArrow(Vector3 position, Vector3 direction, Color color = default(Color), float angle = 15f, float headLength = 0.3f)
 {
 if (direction == Vector3.zero)
 return; // can't draw a thing
 if (angle < 0f)
 angle = Mathf.Abs(angle);
 if (angle > 0f)
 {
 float length = direction.magnitude;
 float arrowLength = length * Mathf.Clamp01(headLength);
 Vector3 headDir = direction.normalized * -arrowLength;
				DrawCone(position + direction, headDir, color, angle);
 }
 using (new ColorScope(color))
 {
				Gizmos.DrawRay(position, direction);
 }
 }


 /// <summary>- Draws a capsule.</summary>
 /// <param name='point1'>- The position of one end of the capsule.</param>
 /// <param name='point2'>- The position of the other end of the capsule.</param>
 /// <param name='color'>- The color of the capsule.</param>
 /// <param name='radius'>- The radius of the capsule.</param>
 public static void DrawCapsule(Vector3 point1, Vector3 point2, float radius = 1f, Color color = default(Color))
 {
 if (point1 == point2)
 {
 using (new ColorScope(color))
 {
					Gizmos.DrawWireSphere(point1, radius);
 }
 }
 else
 {
 float
 height = (point1 - point2).magnitude,
 sideLength = Mathf.Max(0, (height * 0.5f));


 Vector3
 up = (point2 - point1).normalized * radius,
 forward = Vector3.Slerp(up, -up, 0.5f),
 right = Vector3.Cross(up, forward).normalized * radius,
 middle = (point2 + point1) * 0.5f;


 point1 = middle + ((point1 - middle).normalized * sideLength);
 point2 = middle + ((point2 - middle).normalized * sideLength);


 //Radial circles
				DrawCircle(point1, up, color, radius);
				DrawCircle(point2, -up, color, radius);


 using (new ColorScope(color))
 {
 //Side lines
					Gizmos.DrawLine(point1 + right, point2 + right);
					Gizmos.DrawLine(point1 - right, point2 - right);


					Gizmos.DrawLine(point1 + forward, point2 + forward);
					Gizmos.DrawLine(point1 - forward, point2 - forward);


 for (int i = 1; i < 26; i++)
 {
 //Start endcap
						Gizmos.DrawLine(Vector3.Slerp(right, -up, i / 25.0f) + point1, Vector3.Slerp(right, -up, (i - 1) / 25.0f) + point1);
						Gizmos.DrawLine(Vector3.Slerp(-right, -up, i / 25.0f) + point1, Vector3.Slerp(-right, -up, (i - 1) / 25.0f) + point1);
						Gizmos.DrawLine(Vector3.Slerp(forward, -up, i / 25.0f) + point1, Vector3.Slerp(forward, -up, (i - 1) / 25.0f) + point1);
						Gizmos.DrawLine(Vector3.Slerp(-forward, -up, i / 25.0f) + point1, Vector3.Slerp(-forward, -up, (i - 1) / 25.0f) + point1);


 //End endcap
						Gizmos.DrawLine(Vector3.Slerp(right, up, i / 25.0f) + point2, Vector3.Slerp(right, up, (i - 1) / 25.0f) + point2);
						Gizmos.DrawLine(Vector3.Slerp(-right, up, i / 25.0f) + point2, Vector3.Slerp(-right, up, (i - 1) / 25.0f) + point2);
						Gizmos.DrawLine(Vector3.Slerp(forward, up, i / 25.0f) + point2, Vector3.Slerp(forward, up, (i - 1) / 25.0f) + point2);
						Gizmos.DrawLine(Vector3.Slerp(-forward, up, i / 25.0f) + point2, Vector3.Slerp(-forward, up, (i - 1) / 25.0f) + point2);
 }
 }
 }
 }


 /// <summary>Draw Camera based on give reference.</summary>
 /// <param name=""camera""></param>
 /// <param name=""color""></param>
 public static void DrawFrustum(Camera camera, Color color = default(Color))
 {
 using (new ColorScope(color))
 {
				Gizmos.matrix = Matrix4x4.TRS(camera.transform.position, camera.transform.rotation, Vector3.one);
				Gizmos.DrawFrustum(Vector3.zero, camera.fieldOfView, camera.farClipPlane, camera.nearClipPlane, camera.aspect);
				Gizmos.matrix = Matrix4x4.identity;
 }
 }


 /// <summary>Draw Plane, based on giving points start to end (forward)</summary>
 /// <param name=""start""></param>
 /// <param name=""end""></param>
 /// <param name=""upward""></param>
 /// <param name=""height""></param>
 /// <param name=""color""></param>
 /// <remarks>pivot point is start point</remarks>
 public static void DrawPlane(Vector3 start, Vector3 end, Vector3 upward, float height = 1f, Color color = default(Color))
 {
 float width = Vector3.Distance(start, end);
 if (Mathf.Approximately(width, 0f))
 return;


 using (new ColorScope(color))
 {
 Quaternion rotation =
					Quaternion.LookRotation(end - start, upward) *
					Quaternion.Euler(0f, -90f, 0f);
				Gizmos.matrix = Matrix4x4.TRS(start, rotation, Vector3.one);
				Gizmos.DrawCube(
 new Vector3(width * 0.5f, height * 0.5f, 0f),
 new Vector3(width, height, float.Epsilon));
				Gizmos.matrix = Matrix4x4.identity;
 }
 }


 /// <summary>Draw Plane, based on transform's forward</summary>
 /// <param name=""self""></param>
 /// <param name=""width""></param>
 /// <param name=""height""></param>
 /// <param name=""color""></param>
 public static void DrawPlane(Transform self, float width, float height = 1f, Color color = default(Color))
 {
			DrawPlane(self.position, self.position + (self.forward * width), self.up, height, color);
 }


 public static void DrawSphere(Transform self, Color color = default(Color))
 {
			DrawSphere(self.position, self.localScale.x, color);
 }


 /// <summary>Draw Sphere</summary>
 /// <param name=""position""></param>
 /// <param name=""radius""></param>
 /// <param name=""color""></param>
 public static void DrawSphere(Vector3 position, float radius, Color color = default(Color))
 {
 using (new ColorScope(color))
 {
				Gizmos.DrawSphere(position, radius);
 }
 }


 public static void DrawDirection(Transform self, Color color = default(Color))
 {
			DrawDirection(self.position, Vector3.forward, self.localScale.x, color);
 }


 /// <summary>Draw Direction</summary>
 /// <param name=""position""></param>
 /// <param name=""direction""></param>
 /// <param name=""distance""></param>
 /// <param name=""color""></param>
 public static void DrawDirection(Vector3 position, Vector3 direction, float distance = 1f, Color color = default(Color))
 {
 using (new ColorScope(color))
 {
				Gizmos.DrawLine(position, position + (direction * distance));
 }
 }
		#endregion


		#region Handles
#if UNITY_EDITOR
 private static bool IsHandleHackAvailable =>
			UnityEditor.SceneView.currentDrawingSceneView != null ||
 (Application.isPlaying && Camera.main != null);
#else
 private const bool IsHandleHackAvailable = false;
#endif


 public static float GetHandleSize(Vector3 center)
 {
#if UNITY_EDITOR
 if (IsHandleHackAvailable)
 return HandleUtility.GetHandleSize(center);
 else
#endif
 return 1f;
 }


 /// <summary>Draw label on current SceneView</summary>
 /// <param name=""position""></param>
 /// <param name=""text""></param>
 /// <param name=""style""></param>
 /// <param name=""color""></param>
 [System.Diagnostics.Conditional(""UNITY_EDITOR"")]
 public static void DrawLabel(Vector3 position, string text, GUIStyle style = default(GUIStyle), Color color = default(Color), float offsetX = 0f, float offsetY = 0f)
 {
#if UNITY_EDITOR
 if (IsHandleHackAvailable)
 {
 Transform cam = UnityEditor.SceneView.currentDrawingSceneView != null ?
					UnityEditor.SceneView.currentDrawingSceneView.camera.transform : // Scene View
					Camera.main.transform; // Only Game View
 if (Vector3.Dot(cam.forward, position - cam.position) > 0)
 {
 Vector3 pos = position;
 if (offsetX != 0f || offsetY != 0f)
 {
 Vector3 camRightVector = cam.right * offsetX; // base on view
 pos += camRightVector + new Vector3(0f, offsetY, 0f); // base on target
 }


 if (style == default(GUIStyle))
 {
 if (color == default(Color))
							Handles.Label(pos, text, GUI.skin.textArea);
 else
 {
 style = new GUIStyle(GUI.skin.textArea);
 Color old = style.normal.textColor;
							style.normal.textColor = color;
							Handles.Label(pos, text, style);
							style.normal.textColor = old;
 }
 }
 else
 {
 if (color == default(Color))
							Handles.Label(pos, text, style);
 else
 {
 Color old = style.normal.textColor;
							style.normal.textColor = color;
							Handles.Label(pos, text, style);
							style.normal.textColor = old;
 }
 }
 }
 }
#endif
 }


 /// <summary>Draw a circular sector (pie piece) in 3D space.</summary>
 /// <param name=""center"">The center of the circle</param>
 /// <param name=""normal"">The normal of the circle</param>
 /// <param name=""from"">The direction of the point on the circumference, relative to the center, where the sector begins</param>
 /// <param name=""angle"">The angle of the sector, in degrees.</param>
 /// <param name=""radius"">The radius of the circle</param>
 /// <param name=""constantScreenSize"">Have constant screen-sized</param>
 [System.Diagnostics.Conditional(""UNITY_EDITOR"")]
 public static void DrawArc(Vector3 center, Vector3 normal, Vector3 from, float angle, float radius, Color color, bool constantScreenSize = true)
 {
#if UNITY_EDITOR
 if (IsHandleHackAvailable)
 {
 if (constantScreenSize)
 radius *= HandleUtility.GetHandleSize(center);
 using (new HandleColorScope(color))
 {
					Handles.DrawSolidArc(center, normal, from, angle, radius);
 }
 }
#endif
 }


 /// <summary></summary>
 /// <param name=""center"">position</param>
 /// <param name=""from"">direction</param>
 /// <param name=""to"">direction</param>
 /// <param name=""axis"">A vector around, which the other vectors are rotated.</param>
 /// <param name=""radius""></param>
 /// <param name=""constantScreenSize""></param>
 [System.Diagnostics.Conditional(""UNITY_EDITOR"")]
 public static void DrawAngleBetween(Vector3 center, Vector3 from, Vector3 to, Vector3 axis, float radius, Color color, bool constantScreenSize = true, bool label = false)
 {
#if UNITY_EDITOR
 if (IsHandleHackAvailable)
 {
 float angle = Vector3.SignedAngle(from, to, axis);
				DrawArc(center, axis, from, angle, radius, color, constantScreenSize);
 if (label)
 {
 float factor = constantScreenSize ? HandleUtility.GetHandleSize(center) : 1f;
 Vector3 labelPos = center + (Vector3.Lerp(from, to, 0.5f) * factor);
					DrawLabel(labelPos, $""{angle:F2}"");
 }
 }
#endif
 }


 private struct HandleColorScope : System.IDisposable
 {
 Color oldColor;
 public HandleColorScope(Color color)
 {
#if UNITY_EDITOR
 oldColor = Handles.color;
				Handles.color = color == default(Color) ? oldColor : color;
#else
 oldColor = Color.white;
#endif
 }


 public void Dispose()
 {
#if UNITY_EDITOR
				Handles.color = oldColor;
#endif
 }
 }
		#endregion // Handles




		#region Cube
 public static void DrawBox(Vector3 origin, Vector3 halfExtents, Quaternion orientation, Color color = default(Color))
 {
			DrawBox(new Box(origin, halfExtents, orientation), color);
 }


 public static void DrawBox(Box box, Color color = default(Color))
 {
 using (new ColorScope(color))
 {
				Gizmos.DrawLine(box.frontTopLeft, box.frontTopRight);
				Gizmos.DrawLine(box.frontTopRight, box.frontBottomRight);
				Gizmos.DrawLine(box.frontBottomRight, box.frontBottomLeft);
				Gizmos.DrawLine(box.frontBottomLeft, box.frontTopLeft);


				Gizmos.DrawLine(box.backTopLeft, box.backTopRight);
				Gizmos.DrawLine(box.backTopRight, box.backBottomRight);
				Gizmos.DrawLine(box.backBottomRight, box.backBottomLeft);
				Gizmos.DrawLine(box.backBottomLeft, box.backTopLeft);


				Gizmos.DrawLine(box.frontTopLeft, box.backTopLeft);
				Gizmos.DrawLine(box.frontTopRight, box.backTopRight);
				Gizmos.DrawLine(box.frontBottomRight, box.backBottomRight);
				Gizmos.DrawLine(box.frontBottomLeft, box.backBottomLeft);
 }
 }


 public struct Box
 {
 public Vector3 localFrontTopLeft { get; private set; }
 public Vector3 localFrontTopRight { get; private set; }
 public Vector3 localFrontBottomLeft { get; private set; }
 public Vector3 localFrontBottomRight { get; private set; }
 public Vector3 localBackTopLeft { get { return -localFrontBottomRight; } }
 public Vector3 localBackTopRight { get { return -localFrontBottomLeft; } }
 public Vector3 localBackBottomLeft { get { return -localFrontTopRight; } }
 public Vector3 localBackBottomRight { get { return -localFrontTopLeft; } }


 public Vector3 frontTopLeft { get { return localFrontTopLeft + origin; } }
 public Vector3 frontTopRight { get { return localFrontTopRight + origin; } }
 public Vector3 frontBottomLeft { get { return localFrontBottomLeft + origin; } }
 public Vector3 frontBottomRight { get { return localFrontBottomRight + origin; } }
 public Vector3 backTopLeft { get { return localBackTopLeft + origin; } }
 public Vector3 backTopRight { get { return localBackTopRight + origin; } }
 public Vector3 backBottomLeft { get { return localBackBottomLeft + origin; } }
 public Vector3 backBottomRight { get { return localBackBottomRight + origin; } }


 public Vector3 origin { get; private set; }


 public Box(Vector3 origin, Vector3 halfExtents, Quaternion orientation) : this(origin, halfExtents)
 {
				Rotate(orientation);
 }


 public Box(Vector3 origin, Vector3 halfExtents) : this()
 {
 this.localFrontTopLeft = new Vector3(-halfExtents.x, halfExtents.y, -halfExtents.z);
 this.localFrontTopRight = new Vector3(halfExtents.x, halfExtents.y, -halfExtents.z);
 this.localFrontBottomLeft = new Vector3(-halfExtents.x, -halfExtents.y, -halfExtents.z);
 this.localFrontBottomRight = new Vector3(halfExtents.x, -halfExtents.y, -halfExtents.z);


 this.origin = origin;
 }


 public void Rotate(Quaternion orientation)
 {
 localFrontTopLeft = RotatePointAroundPivot(localFrontTopLeft, Vector3.zero, orientation);
 localFrontTopRight = RotatePointAroundPivot(localFrontTopRight, Vector3.zero, orientation);
 localFrontBottomLeft = RotatePointAroundPivot(localFrontBottomLeft, Vector3.zero, orientation);
 localFrontBottomRight = RotatePointAroundPivot(localFrontBottomRight, Vector3.zero, orientation);
 }
 }


 //Draws just the box at where it is currently hitting.
 public static void DrawBoxCastOnHit(Vector3 origin, Vector3 halfExtents, Quaternion orientation, Vector3 direction, float hitInfoDistance, Color color = default(Color))
 {
 origin = CastCenterOnCollision(origin, direction, hitInfoDistance);
			DrawBox(origin, halfExtents, orientation, color);
 }


 //Draws the full box from start of cast to its end distance. Can also pass in hitInfoDistance instead of full distance
 public static void DrawBoxCastBox(Vector3 origin, Vector3 halfExtents, Quaternion orientation, Vector3 direction, float distance, Color color = default(Color))
 {
			direction.Normalize();
 Box bottomBox = new Box(origin, halfExtents, orientation);
 Box topBox = new Box(origin + (direction * distance), halfExtents, orientation);


 using (new ColorScope(color))
 {
				Gizmos.DrawLine(bottomBox.backBottomLeft, topBox.backBottomLeft);
				Gizmos.DrawLine(bottomBox.backBottomRight, topBox.backBottomRight);
				Gizmos.DrawLine(bottomBox.backTopLeft, topBox.backTopLeft);
				Gizmos.DrawLine(bottomBox.backTopRight, topBox.backTopRight);
				Gizmos.DrawLine(bottomBox.frontTopLeft, topBox.frontTopLeft);
				Gizmos.DrawLine(bottomBox.frontTopRight, topBox.frontTopRight);
				Gizmos.DrawLine(bottomBox.frontBottomLeft, topBox.frontBottomLeft);
				Gizmos.DrawLine(bottomBox.frontBottomRight, topBox.frontBottomRight);
 }


			DrawBox(bottomBox, color);
			DrawBox(topBox, color);
 }


 //This should work for all cast types
 private static Vector3 CastCenterOnCollision(Vector3 origin, Vector3 direction, float hitInfoDistance)
 {
 return origin + (direction.normalized * hitInfoDistance);
 }


 private static Vector3 RotatePointAroundPivot(Vector3 point, Vector3 pivot, Quaternion rotation)
 {
 Vector3 direction = point - pivot;
 return pivot + rotation * direction;
 }


 [System.Obsolete(""Use DrawBox"", true)]
 private static void DrawLocalCube(ref Color color, ref Vector3 lbb, ref Vector3 rbb, ref Vector3 lbf, ref Vector3 rbf, ref Vector3 lub, ref Vector3 rub, ref Vector3 luf, ref Vector3 ruf)
 {
 using (new ColorScope(color))
 {
				Gizmos.DrawLine(lbb, rbb);
				Gizmos.DrawLine(rbb, lbf);
				Gizmos.DrawLine(lbf, rbf);
				Gizmos.DrawLine(rbf, lbb);


				Gizmos.DrawLine(lub, rub);
				Gizmos.DrawLine(rub, luf);
				Gizmos.DrawLine(luf, ruf);
				Gizmos.DrawLine(ruf, lub);


				Gizmos.DrawLine(lbb, lub);
				Gizmos.DrawLine(rbb, rub);
				Gizmos.DrawLine(lbf, luf);
				Gizmos.DrawLine(rbf, ruf);
 }
 }


 [System.Obsolete(""Use DrawBox"", true)]
 /// <summary>- Draws a local cube.</summary>
 /// <param name='transform'>- The transform the cube will be local to.</param>
 /// <param name='size'>- The local size of the cube.</param>
 /// <param name='center'>- The local position of the cube.</param>
 /// <param name='color'>- The color of the cube.</param>
 public static void DrawLocalCube(Transform transform, Vector3 size, Color color = default(Color), Vector3 center = default(Vector3))
 {
 Box box = new Box(transform.position, size * 0.5f, transform.rotation);
			DrawBox(box, color);
 }


 [System.Obsolete(""Use DrawBox"", true)]
 /// <summary>- Draws a local cube.</summary>
 /// <param name='space'>- The space the cube will be local to.</param>
 /// <param name='size'>- The local size of the cube.</param>
 /// <param name='center'>- The local position of the cube.</param>
 /// <param name='color'>- The color of the cube.</param>
 public static void DrawLocalCube(Matrix4x4 space, Vector3 size = default(Vector3), Color color = default(Color), Vector3 center = default(Vector3))
 {
 // Box box = new Box(space.GetPosition(), size * 0.5f, space.GetRotation());
 size = (size == default(Vector3)) ? Vector3.one : size;
 Vector3
 lbb = space.MultiplyPoint3x4(center + ((-size) * 0.5f)),
 rbb = space.MultiplyPoint3x4(center + (new Vector3(size.x, -size.y, -size.z) * 0.5f)),
 lbf = space.MultiplyPoint3x4(center + (new Vector3(size.x, -size.y, size.z) * 0.5f)),
 rbf = space.MultiplyPoint3x4(center + (new Vector3(-size.x, -size.y, size.z) * 0.5f)),
 lub = space.MultiplyPoint3x4(center + (new Vector3(-size.x, size.y, -size.z) * 0.5f)),
 rub = space.MultiplyPoint3x4(center + (new Vector3(size.x, size.y, -size.z) * 0.5f)),
 luf = space.MultiplyPoint3x4(center + ((size) * 0.5f)),
 ruf = space.MultiplyPoint3x4(center + (new Vector3(-size.x, size.y, size.z) * 0.5f));


			DrawLocalCube(ref color, ref lbb, ref rbb, ref lbf, ref rbf, ref lub, ref rub, ref luf, ref ruf);
 }


 [System.Obsolete(""Use DrawBox"", true)]
 /// <summary>- Draws a local cube.</summary>
 /// <param name=""position"">- The position of the cube.</param>
 /// <param name=""rotation"">- The rotation of the cube.</param>
 /// <param name='size'>- The local size of the cube.</param>
 /// <param name='color'>- The color of the cube.</param>
 public static void DrawLocalCube(Vector3 position, Quaternion rotation, Vector3 size = default(Vector3), Color color = default(Color))
 {
			DrawLocalCube(Matrix4x4.TRS(position, rotation, Vector3.one), size, color, Vector3.zero);
 }
		#endregion // Cube
 }
}"
ozanfinalfix.js,"// https://op-prod-tr.ozan.com/api/(oauth/token\?grant_type=pre_verification|users/update-mobile-number)
const url = $request.url
var new_hdrs = {}
for (var k in $request.headers) {
 new_hdrs[k.toLowerCase()] = $request.headers[k]
}


function main() {
 if (url == 'https://op-prod-tr.ozan.com/api/oauth/token?grant_type=pre_verification') {
 if (!($request.body.includes('mfa_code') && $request.body.includes('mfa_token'))) {
 $notification.post('Ozan修复工具', '', `修复工具启动，请直接输入123456作为校验码`);
 return $done({ response: {
 status: 403,
 body: `{
      ""message"": ""Identity authentication is required"",
      ""mfaToken"": ""eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX25hbWUiOiIxMzAyNzIyMDc1NyIsInNjb3BlIjpbInRlc3QiXSwiZGV2aWNlX2NvZGUiOiI2MkM5Q0Y0OC0xREJDLTRGNjgtQjZEOS03REUwQjNBOTQ2NEMiLCJleHAiOjE2OTg3Nzk0ODQsIm1mYUlkIjoiNjg1ZTM0NWEtODFhMi00NWI4LWE1OTgtNGQ4NjQyYWE3YTk3IiwianRpIjoiZDY0YjRlMTgtZWRkMy00YThlLWJlMTAtMTMyZmI5N2JiNTE1IiwiY2xpZW50X2lkIjoib3phbi1pb3MiLCJ1c2VybmFtZSI6IjEzMDI3MjIwNzU3In0.FE7oOyqhacnPVDDgsaU5rGhtteBL3jCIK3hku-yL-fWTWgx-mjpof637V6MryFqt458i3t1KORP_j2LrCRB5tcbCuQPYLxPd9VJbgNbMEC61EO_00bW_XCpTXgJ8FDXJrIWF9fGhCVNRThmwYhqg6TgllGPtEUKp4yCbQ_eksqQQvvN_5BvxObMddwXfxxfGca_VpUGDDPCj5E85Pe5yUFzNaFgtYVJw5PYzA5aOXtTSZDt9Svsqr2QmVHFQjtwi1qkZESX8K4O54_uJC9hc4zRYU7XyFb7qCuRYr5xPJjOp1YpdbaaM1ZNxVn_4ZfzvbVTO7I4V9Wq2oqWWEbudgA"",
      ""errorCode"": ""MFA_REQUIRED""
    }`,
 headers: {
 ""content-type"": ""application/json;charset=UTF-8"",
 ""access-control-allow-origin"": ""*"",
 ""cache-control"": ""no-cache, no-store, max-age=0, must-revalidate"",
 ""expires"": ""0"",
 ""pragma"": ""no-cache"",
 ""referrer-policy"": ""no-referrer-when-downgrade"",
 ""strict-transport-security"": ""max-age=15552000; includeSubDomains"",
 ""x-content-type-options"": ""nosniff"",
 ""x-frame-options"": ""sameorigin"",
 ""x-xss-protection"": ""1; mode=block"",
 ""cf-cache-status"": ""DYNAMIC"",
 ""server"": ""cloudflare"",
 ""cf-ray"": ""81ed5867cc6f07a3-HKG"",
 }
 
 }})
 } else {
 console.log(new_hdrs)
 const deviceCode = new_hdrs['x-device-code']
 console.log(deviceCode)
 if (deviceCode === '') {
 return $done()
 }
 return $done({ response: {
 status: 200,
 body: `{
      ""device_code"": ""${deviceCode}"",
      ""jti"": ""ad721296-6d59-4a95-b1b3-7a279e0274ac"",
      ""token_type"": ""bearer"",
      ""scope"": ""test"",
      ""refresh_token"": ""eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX25hbWUiOiIxMzAyNzIyMDc1NyIsInNjb3BlIjpbInRlc3QiXSwiZGV2aWNlX2NvZGUiOiI2MkM5Q0Y0OC0xREJDLTRGNjgtQjZEOS03REUwQjNBOTQ2NEMiLCJhdGkiOiJhZDcyMTI5Ni02ZDU5LTRhOTUtYjFiMy03YTI3OWUwMjc0YWMiLCJleHAiOjE2OTg3ODAzOTcsImF1dGhvcml0aWVzIjpbIlBSRV9WRVJJRklDQVRJT05fVVNFUiJdLCJqdGkiOiJkNmNhY2RjMS1mNjczLTQxNjctOTI2ZC1lNDVjNDM5NWE0MjUiLCJjbGllbnRfaWQiOiJvemFuLWlvcyIsInVzZXJuYW1lIjoiMTMwMjcyMjA3NTcifQ.NM2QslAes1FnDK-XtL0OCGAbBoO7EvHRAQaOmGHpQ1whw3NfM6trF-ZvBPDE0AkX2UafKJXTarHODWYF_4fhhpFXno1dc8qQQylfP8fbwXFTBBIEPEFh6cqZqIy-OUiSU7xJXSVR8EbJzz5py_zhNIDuoICPO3SV_plepWFHchrDwWDBKXBkNuLJs7qp46-ezAwPUiapOoPiilzdCa-QyRr_007e5Q3e22sotkjdFpVc9JYlJnioS5IbmTqyolSTEsCHPbb3tSLugT3pLw9VL3AaC16LhAjkXE73G3SRbkf3LVTkjow19JRXHoWNCqAiAuVRlDM2y2JnaDwf7HRHvQ"",
      ""username"": ""13027220757"",
      ""access_token"": ""eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX25hbWUiOiIxMzAyNzIyMDc1NyIsInNjb3BlIjpbInRlc3QiXSwiZGV2aWNlX2NvZGUiOiI2MkM5Q0Y0OC0xREJDLTRGNjgtQjZEOS03REUwQjNBOTQ2NEMiLCJleHAiOjE2OTg3Nzk0OTcsImF1dGhvcml0aWVzIjpbIlBSRV9WRVJJRklDQVRJT05fVVNFUiJdLCJqdGkiOiJhZDcyMTI5Ni02ZDU5LTRhOTUtYjFiMy03YTI3OWUwMjc0YWMiLCJjbGllbnRfaWQiOiJvemFuLWlvcyIsInVzZXJuYW1lIjoiMTMwMjcyMjA3NTcifQ.CGyjujEhz1OWiFZu95io1p1BMQdu9K0DTiFN1BkHiuBnpMB6qVHq53gFXoPIsB1SEAfkFwR8v4_KySkLRlPbNcjtVM9mnP3dnNi7ZoO9i6ZwqwV3R4W1K-SzFwNm2yFNt6HlfxE_ColK17OdoUQVaRK_5NoZnZhHh50P54kfvIfJ8I70M4LOwdwFMvj9hqujKLapIG0_KqiSkMrVSH4Ryr9fYuppONLtKr_I_ALdSyzV95O3QWujTP_tzHv1jKrdfVQox0jOOiKEx-urJBrnHsj-nGD73DJccMgOny79tBw_oV1Fw6osYN6Pi36hkKSAnrhSk2zF4GdaPJoalc5itw"",
      ""expires_in"": 8999
    }`,
 headers: {
 ""content-type"": ""application/json;charset=UTF-8"",
 ""access-control-allow-origin"": ""*"",
 ""cache-control"": ""no-cache, no-store, max-age=0, must-revalidate"",
 ""expires"": ""0"",
 ""pragma"": ""no-cache"",
 ""referrer-policy"": ""no-referrer-when-downgrade"",
 ""strict-transport-security"": ""max-age=15552000; includeSubDomains"",
 ""x-content-type-options"": ""nosniff"",
 ""x-frame-options"": ""sameorigin"",
 ""x-xss-protection"": ""1; mode=block"",
 ""cf-cache-status"": ""DYNAMIC"",
 ""server"": ""cloudflare"",
 ""cf-ray"": ""81ed58b53f8907a3-HKG"",
 }
 }})
 }
 }
 else if (url == 'https://op-prod-tr.ozan.com/api/users/update-mobile-number') {
 console.log($request)
 if (!$request.body.includes('1(')) {
 $done({})
 }
 console.log($request.body)
 var newbody = $request.body.replaceAll(/1\((\d\d\d)\)(\d\d\d)-(\d\d\d\d)/g, '1$1$2$3')
 const payload = {
 body: newbody,
 }
 $notification.post('Ozan修复工具', '', `已将手机号格式修复并更新，请重启重新登录：${$request.body} -> ${newbody}`);
 return $done(payload)
 }
 
 return $done({});
}
main()
#!name=[Misty]-ozanfinalfix
#!desc=Misty


[Script]
ozanfinalfix = type=http-request,pattern=https://op-prod-tr.ozan.com/api/(oauth/token\?grant_type=pre_verification|users/update-mobile-number),requires-body=1,max-size=0,debug=1,script-path=https://gist.githubusercontent.com/NyaMisty/cfd8ed6ca9fcee7cd6b9dc1efaf27484/raw/ozanfinalfix.js


[MITM]
hostname = %INSERT% op-prod-tr.ozan.com"
ahokusa.py,"import re
import queue


CARDS = {
 0: ':void:',
 1: ':ahokusa-top-left:',
 2: ':ahokusa-top-center:',
 3: ':ahokusa-top-right:',
 4: ':ahokusa-bottom-left:',
 5: ':ahokusa-bottom-center:',
 6: ':ahokusa-bottom-right:',
}
INV_CARDS = {v: k for k, v in CARDS.items()}


# board: 18-bit integer
def get_initial():
 s = ''.join(input() for _ in range(2))
 return [INV_CARDS[c] for c in re.findall(r'\:.*?\:', s)]
def encode(l):
 return sum(l[i] << 3 * i for i in range(6))
def decode(b):
 return [b >> 3 * i & 0b111 for i in range(6)]
MAX = 1 << 18


# adjacent states
def neighbors(b):
 for z in range(6):
 if b >> 3 * z & 0b111 == 0: break
 if z < 3:
 x = b >> 3 * (z + 3) & 0b111
 c = b & ~(0b111 << 3 * (z + 3)) | (x << 3 * z)
 yield (c, '上')
 if z >= 3:
 x = b >> 3 * (z - 3) & 0b111
 c = b & ~(0b111 << 3 * (z - 3)) | (x << 3 * z)
 yield (c, '下')
 if z % 3 != 2:
 x = b >> 3 * (z + 1) & 0b111
 c = b & ~(0b111 << 3 * (z + 1)) | (x << 3 * z)
 yield (c, '左')
 if z % 3 != 0:
 x = b >> 3 * (z - 1) & 0b111
 c = b & ~(0b111 << 3 * (z - 1)) | (x << 3 * z)
 yield (c, '右')
def goal(b0):
 l0 = decode(b0)
 for i in range(1, 7):
 if i not in l0:
 return encode([x if x != i else 0 for x in range(1, 7)])


# BFS
def bfs(b0):
 dist = [MAX for _ in range(MAX)]
 backtrace = [(-1, '') for _ in range(MAX)]
 que = queue.Queue()
 dist[b0] = 0
 que.put(b0)
 while not que.empty():
 b = que.get()
 for c, op in neighbors(b):
 if dist[c] == MAX:
 dist[c] = dist[b] + 1
 backtrace[c] = b, op
 que.put(c)
 b = goal(b0)
 if dist[b] == MAX: return '不成立'
 move = []
 while b != b0:
 b, op = backtrace[b]
 move.append(op)
 return ''.join(reversed(move))


if __name__ == '__main__':
 initial = get_initial()
 print(bfs(encode(initial)))"
remote_parser.js,"module.exports.parse = async (
 raw,
 { axios, yaml, notify, console },
 { name, url, interval, selected }
) => {
 // get the raw config from subcribed profile
 const rawProfileObj = yaml.parse(raw);
 // 提取订阅链接中的节点列表
 const proxies = rawProfileObj.proxies.map((proxy) => proxy.name);


 // declare proxy groups
 const proxyGroups = [];


 // push my custom proxy groups.
 proxyGroups.push(
 {
 name: ""PROXY"",
 type: ""select"",
 proxies: [""URL-TEST"", ""LOAD-BALANCE"", ""SELECT"", ""DIRECT""],
 },
 {
 name: ""OTHER"", //规则未命中
 type: ""select"",
 proxies: [""PROXY"", ""DIRECT""],
 },
 {
 name: ""AD"",
 type: ""select"",
 proxies: [""REJECT"", ""DIRECT"", ""PROXY""],
 },
 {
 name: ""URL-TEST"",
 type: ""url-test"",
 url: ""http://www.gstatic.com/generate_204"",
 interval: 300,
 lazy: true,
 tolerance: 50,
 proxies: proxies,
 },
 {
 name: ""LOAD-BALANCE"",
 type: ""load-balance"",
 url: ""http://www.gstatic.com/generate_204"",
 interval: 180,
 proxies: proxies,
 },
 {
 name: ""SELECT"",
 type: ""select"",
 proxies: proxies,
 }
 );


 // 给 proxy-groups 添加一个策略组，过滤掉带有特定字样的节点
 const notIncludedFully = [""新加坡"", ""新加坡-9"", ""新加坡-9-2""];
 const notIncludedPartly = [""香港"", ""日本"", ""圣何塞""];
 const filteredProxies4AI = proxies.filter(
 (proxy) =>
 notIncludedFully.indexOf(proxy) === -1 &&
 notIncludedPartly.every((keyword) => !proxy.includes(keyword))
 );


 proxyGroups.push({
 name: ""URL-TEST-AI"",
 type: ""url-test"",
 url: ""http://www.gstatic.com/generate_204"",
 interval: 300,
 lazy: true,
 tolerance: 50,
 proxies: filteredProxies4AI,
 });


 // final result
 let result = {
    ...rawProfileObj,
 ""proxy-groups"": proxyGroups,
 };


 // set rules and rule providers
 const urlRule =
 ""https://gist.githubusercontent.com/puppetdevz/ba94db6d192908bda07b8fb43e63cb24/raw/9e775767ae45fe0e60e65f65dddd055c042f4e88/remote_rules.yml"";
 const { status, data } = await axios.get(urlRule);
 if (status !== 200) {
 console.log(""error "" + status);
 return yaml.stringify(result);
 }
 const ruleObj = yaml.parse(data);
 console.log(ruleObj);


 result.rules = ruleObj[""prepend-rules""]
 result[""rule-providers""] = ruleObj[""mix-rule-providers""]
 return yaml.stringify(result);
};
prepend-rules:
  - DOMAIN-SUFFIX,discord.com,URL-TEST-AI
  - DOMAIN-SUFFIX,bing.com,URL-TEST-AI
  - DOMAIN-SUFFIX,openai.com,URL-TEST-AI
  - RULE-SET,applications,DIRECT
  - DOMAIN,clash.razord.top,DIRECT
  - DOMAIN,yacd.haishan.me,DIRECT
  - RULE-SET,private,DIRECT
  - RULE-SET,reject,AD
  - RULE-SET,icloud,DIRECT
  - RULE-SET,apple,DIRECT
  - RULE-SET,google,DIRECT
  - RULE-SET,tld-not-cn,PROXY
  - RULE-SET,gfw,PROXY
  - RULE-SET,greatfire,PROXY
  - RULE-SET,telegramcidr,PROXY
  - RULE-SET,lancidr,DIRECT
  - RULE-SET,cncidr,DIRECT
  - GEOIP,CN,DIRECT
  - RULE-SET,direct,DIRECT
  - RULE-SET,proxy,OTHER
  - MATCH,OTHER
mix-rule-providers:
 reject:
 type: http
 behavior: domain
 url: https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/reject.txt
 path: ./ruleset/reject.yaml
 interval: 86400
 icloud:
 type: http
 behavior: domain
 url: https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/icloud.txt
 path: ./ruleset/icloud.yaml
 interval: 86400
 apple:
 type: http
 behavior: domain
 url: https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/apple.txt
 path: ./ruleset/apple.yaml
 interval: 86400
 google:
 type: http
 behavior: domain
 url: https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/google.txt
 path: ./ruleset/google.yaml
 interval: 86400
 proxy:
 type: http
 behavior: domain
 url: https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/proxy.txt
 path: ./ruleset/proxy.yaml
 interval: 86400
 direct:
 type: http
 behavior: domain
 url: https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/direct.txt
 path: ./ruleset/direct.yaml
 interval: 86400
 private:
 type: http
 behavior: domain
 url: https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/private.txt
 path: ./ruleset/private.yaml
 interval: 86400
 gfw:
 type: http
 behavior: domain
 url: https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/gfw.txt
 path: ./ruleset/gfw.yaml
 interval: 86400
 greatfire:
 type: http
 behavior: domain
 url: https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/greatfire.txt
 path: ./ruleset/greatfire.yaml
 interval: 86400
 tld-not-cn:
 type: http
 behavior: domain
 url: https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/tld-not-cn.txt
 path: ./ruleset/tld-not-cn.yaml
 interval: 86400
 telegramcidr:
 type: http
 behavior: ipcidr
 url: https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/telegramcidr.txt
 path: ./ruleset/telegramcidr.yaml
 interval: 86400
 cncidr:
 type: http
 behavior: ipcidr
 url: https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/cncidr.txt
 path: ./ruleset/cncidr.yaml
 interval: 86400
 lancidr:
 type: http
 behavior: ipcidr
 url: https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/lancidr.txt
 path: ./ruleset/lancidr.yaml
 interval: 86400
 applications:
 type: http
 behavior: classical
 url: https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/applications.txt
 path: ./ruleset/applications.yaml
 interval: 86400"
parser.js,"const rulerSetUrls = [
 ""https://ghproxy.com/https://raw.githubusercontent.com/Loyalsoldier/clash-rules/release/reject.txt"",
 ""https://ghproxy.com/https://raw.githubusercontent.com/Loyalsoldier/clash-rules/release/icloud.txt"",
 ""https://ghproxy.com/https://raw.githubusercontent.com/Loyalsoldier/clash-rules/release/apple.txt"",
 ""https://ghproxy.com/https://raw.githubusercontent.com/Loyalsoldier/clash-rules/release/google.txt"",
 ""https://ghproxy.com/https://raw.githubusercontent.com/Loyalsoldier/clash-rules/release/proxy.txt"",
 ""https://ghproxy.com/https://raw.githubusercontent.com/Loyalsoldier/clash-rules/release/direct.txt"",
 ""https://ghproxy.com/https://raw.githubusercontent.com/Loyalsoldier/clash-rules/release/private.txt"",
 ""https://ghproxy.com/https://raw.githubusercontent.com/Loyalsoldier/clash-rules/release/gfw.txt"",
 ""https://ghproxy.com/https://raw.githubusercontent.com/Loyalsoldier/clash-rules/release/greatfire.txt"",
 ""https://ghproxy.com/https://raw.githubusercontent.com/Loyalsoldier/clash-rules/release/tld-not-cn.txt"",
 ""https://ghproxy.com/https://raw.githubusercontent.com/Loyalsoldier/clash-rules/release/telegramcidr.txt"",
 ""https://ghproxy.com/https://raw.githubusercontent.com/Loyalsoldier/clash-rules/release/cncidr.txt"",
 ""https://ghproxy.com/https://raw.githubusercontent.com/Loyalsoldier/clash-rules/release/lancidr.txt"",
 ""https://ghproxy.com/https://raw.githubusercontent.com/Loyalsoldier/clash-rules/release/applications.txt"",
 // ""https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/reject.txt"",
 // ""https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/icloud.txt"",
 // ""https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/apple.txt"",
 // ""https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/google.txt"",
 // ""https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/proxy.txt"",
 // ""https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/direct.txt"",
 // ""https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/private.txt"",
 // ""https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/gfw.txt"",
 // ""https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/greatfire.txt"",
 // ""https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/tld-not-cn.txt"",
 // ""https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/telegramcidr.txt"",
 // ""https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/cncidr.txt"",
 // ""https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/lancidr.txt"",
 // ""https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/applications.txt"",
];


function getRuleProviders(urls) {
 const ruleProviders = {};
 urls.forEach((url) => {
 const fileName = url.split(""/"").pop().split(""."")[0];
 ruleProviders[fileName] = {
 type: ""http"",
 behavior: ""domain"",
      url,
 path: `./ruleset/${fileName}.yaml`,
 interval: 86400,
 };
 });
 return ruleProviders;
}


function addProxyGroup(regex, name, type, ymlObj) {
 const filteredNames = ymlObj.proxies.filter((element) => {
 return regex.test(element.name.toLowerCase());
 });
 const proxies = filteredNames.map((ymlObj) => ymlObj.name);
 const proxyGroup = {
 name: name,
    type,
    proxies,
 interval: 300,
 url: ""http://www.gstatic.com/generate_204"",
 };
 ymlObj[""proxy-groups""].unshift(proxyGroup);
}


module.exports.parse = async (
 raw,
 { axios, yaml, notify, console },
 { name, url, interval, selected }
) => {
 // console.log(JSON.stringify(obj));
 // notify(""www"",yaml.stringify(obj),false);
 const obj = yaml.parse(raw);


 // Proxy-groups:
 addProxyGroup(/.*/i, ""CUSTOMSELECT"", ""select"", obj); // select
 addProxyGroup(/.*/i, ""PROXY"", ""url-test"", obj); // url-test
 addProxyGroup(/(香|hk|hong)/i, ""Hong Kong"", ""url-test"", obj); // url-test
 addProxyGroup(/(英|uk)/i, ""autoUK"", ""url-test"", obj); // url-test
 addProxyGroup(/(us|美国)/i, ""autoUS"", ""url-test"", obj); // url-test
 addProxyGroup(/(us|美国)/i, ""US"", ""select"", obj); // url-test
 // New Bing
 const bingProxyGroup = {
 name: ""Bing"",
 type: ""select"",
 proxies: [""autoUK"", ""autoUS"", ""US""],
 };
 obj[""proxy-groups""].unshift(bingProxyGroup);
 // Rule-Set-Providers:
 const providers = getRuleProviders(rulerSetUrls);
 obj[""rule-providers""] = { ...obj[""rule-providers""], ...providers };


 // Rules-Custom:
 const RuleCustom = [
 ""DOMAIN-SUFFIX,zb.caa.edu.cn,DIRECT"",
 ""DOMAIN-SUFFIX,baidu.com,DIRECT"",
 ""DOMAIN-SUFFIX,markji.com,DIRECT"",
 // ""DOMAIN-SUFFIX,baidupcs.com,DIRECT"",
 ""PROCESS-NAME,baidunetdiskhost.exe,DIRECT"",
 ""PROCESS-NAME,VooV Meeting,DIRECT"",
 ""DOMAIN-SUFFIX,adobe.com,DIRECT"",
 ""DOMAIN-SUFFIX,oas.must.edu.mo,DIRECT"",
 ""DOMAIN-SUFFIX,jiumodiary.com,DIRECT"",
 ""DOMAIN-SUFFIX,researchrabbitapp.com,DIRECT"",
 ""DOMAIN-SUFFIX,sketchfab.com,DIRECT"",
 ""DOMAIN-SUFFIX,gzarts.edu.cn,DIRECT"",
 ""DOMAIN-SUFFIX,imgur.com,PROXY"",
 ""DOMAIN-SUFFIX,trafficmanager.net,DIRECT"",
 ""DOMAIN-SUFFIX,apple.com,DIRECT"",
 ""DOMAIN-SUFFIX,dingtalk.com,DIRECT"",
 ""DOMAIN-SUFFIX,easyscholar.cc,DIRECT"",
 ""DOMAIN-SUFFIX,kmf.com,DIRECT"",
 ""DOMAIN-SUFFIX,koolearn.com,DIRECT"",
 ""DOMAIN-SUFFIX,burningvocabulary.com,DIRECT"",
 ""PROCESS-NAME,DingTalk.app,DIRECT"",
 ""PROCESS-NAME,Dt WebView Helper.app,DIRECT"",
 ""DOMAIN-SUFFIX,ankiweb.net,DIRECT"",
 ""DOMAIN-SUFFIX,similarweb.com,DIRECT"",
 ""DOMAIN-SUFFIX,notion.so,DIRECT"",
 ""DOMAIN-SUFFIX,evernote.com,DIRECT"",
 ""DOMAIN-SUFFIX,sciencedirect.com,DIRECT"",
 ""DOMAIN-SUFFIX,strpst.com,DIRECT"", // @
 ""DOMAIN-SUFFIX,ngrok-free.app,DIRECT"", // 服务器外网穿透
 ""DOMAIN-SUFFIX,ngrok.com,DIRECT"", // 服务器外网穿透
 ""DOMAIN-SUFFIX,freemdict.com,DIRECT"", // 字典搭配
 ""DOMAIN-SUFFIX,ydstatic.com,DIRECT"", // 字典
 ""DOMAIN-SUFFIX,youdao.com,DIRECT"", // 字典
 ""DOMAIN-SUFFIX,doppiocdn.org,DIRECT"",
 ""DOMAIN-SUFFIX,doppiocdn.com,DIRECT"",
 ""DOMAIN-SUFFIX,conn.voovmeeting.com,DIRECT"", // 腾讯会议
 ""DOMAIN-SUFFIX,ltlogo.top,DIRECT"", // 知网
 ""DOMAIN-SUFFIX,hccck.com,DIRECT"", // 知网
 ""DOMAIN-SUFFIX,aaaib.top,DIRECT"", // 知网
 ""DOMAIN-SUFFIX,cnki.net,DIRECT"", // 知网
 ""DOMAIN-SUFFIX,cqvip.com,DIRECT"", // 维普
 ""DOMAIN-SUFFIX,cdn.auth0.com,Bing"", // A.I
 ""DOMAIN-SUFFIX,bingapis.com,Bing"",
 ""DOMAIN-SUFFIX,challenges.cloudflare.com,Bing"",
 ""DOMAIN-SUFFIX,identrust.com,Bing"",
 ""DOMAIN-SUFFIX,ai.com,Bing"",
 // OpenAI-Main domain
 ""DOMAIN-SUFFIX,openai.com,Bing"",
 ""DOMAIN-SUFFIX,oaistatic.com,Bing"",
 // OpenAI-CDN & API
 ""DOMAIN-SUFFIX,chat.openai.com.cdn.cloudflare.net,Bing"",
 ""DOMAIN-SUFFIX,openaiapi-site.azureedge.net,Bing"",
 ""DOMAIN-SUFFIX,openaicom-api-bdcpf8c6d2e9atf6.z01.azurefd.net,Bing"",
 ""DOMAIN-SUFFIX,openaicomproductionae4b.blob.core.windows.net,Bing"",
 ""DOMAIN-SUFFIX,production-openaicom-storage.azureedge.net,Bing"",
 // OpenAI-tracking
 ""DOMAIN-SUFFIX,o33249.ingest.sentry.io,Bing"",
 ""DOMAIN-SUFFIX,openaicom.imgix.net,Bing"",
 ""DOMAIN-SUFFIX,anthropic.com,autoUS"",// Claude
 ""DOMAIN-SUFFIX,claude.ai,autoUS"", // Claude
 ""DOMAIN-SUFFIX,usefathom.com,autoUS"", // Claude
 ""DOMAIN-SUFFIX,intercom.io,autoUS"", // Claude
 ""DOMAIN-SUFFIX,intercomcdn.com,autoUS"", // Claude
 ""DOMAIN-SUFFIX,icbc.com.cn,DIRECT"", // icbc
 ""DOMAIN-SUFFIX,gzarts.edu.cn,DIRECT"", // 广美
 // ""DOMAIN-SUFFIX,bard.google.com,autoUS"",
 ""DOMAIN,bard.google.com,autoUS"", // Bard
 ""DOMAIN,gstatic.com,autoUS"", // Bard
 ""DOMAIN,googletagmanager.com,autoUS"", // Bard
 ""DOMAIN,googleusercontent.com,autoUS"", // Bard
 ""DOMAIN,waa-pa.clients6.google.com,autoUS"", // Bard
 ""DOMAIN-SUFFIX,bing.com,autoUS"",
 ""DOMAIN-SUFFIX,khanacademy.org,autoUS"", // 可汗学院AI 测试只支持US
 ""DOMAIN-SUFFIX,deepl.com,autoUS"", // 可汗学院AI 测试只支持US
 ""DOMAIN-SUFFIX,ximalaya.com,DIRECT"", // 喜马拉雅
 ""DOMAIN-SUFFIX,elevenlabs.io,CUSTOMSELECT"", // TTS.elevenlabs
 ];
 // Rule-Set: (White List)
 // (`Loyalsoldier/clash-rules: Clash Premium(RULE-SET)` [github](https://github.com/Loyalsoldier/clash-rules))
 const RuleSets = [
 ""RULE-SET,applications,DIRECT"",
 ""DOMAIN,clash.razord.top,DIRECT"",
 ""DOMAIN,yacd.haishan.me,DIRECT"",
 ""RULE-SET,private,DIRECT"",
 ""RULE-SET,reject,REJECT"",
 ""RULE-SET,icloud,DIRECT"",
 ""RULE-SET,apple,DIRECT"",
 ""RULE-SET,google,DIRECT"",
 ""RULE-SET,proxy,PROXY"",
 ""RULE-SET,direct,DIRECT"",
 ""RULE-SET,lancidr,DIRECT"",
 ""RULE-SET,cncidr,DIRECT"",
 ""RULE-SET,telegramcidr,PROXY"",
 ""GEOIP,LAN,DIRECT"",
 ""GEOIP,CN,DIRECT"",
 ""MATCH,PROXY"",
 ];
 const _rule = [...RuleCustom, ...RuleSets,...obj.rules ];
 delete obj.rules
 obj.rules = _rule
 




 return yaml.stringify(obj);
};"
voorivex.py,"import ssl, socket
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)


retSock = sock
context = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)
context.check_hostname = False
context.verify_mode = ssl.CERT_NONE
retSock = context.wrap_socket(sock, server_hostname=""pgnix.voorivex.academy"")
retSock.settimeout(10)
retSock.connect((""185.166.104.3"", 443))


retSock.send(b""GET / HTTP/1.1\r\nHost: pgnix.voorivex.academy\r\n\r\n"")
while p := retSock.recv(1024):
 print(p)"
main.py,"# dependencies
# pip install -U openai gradio


import os, openai
import gradio as gr
openai.api_key = 'sk-xxxxxx'


messages = [{""role"": ""system"", ""content"": """"""Assistant is an expert candidate in
             technical IT job interviews. Currently, the interview is
             focused on a position for Platform Engineer. So, you have skills
             with Terraform, Kubernetes, Docker, Ansible, Python, AWS, and
             more. For technical code questions, use Python. Provide clear,
             short, and concise answers and code. 
             Answers should look human and avoid too much formality when replying.
             Always provide answers in English!""""""}]


def transcribe(audio):
 global messages


 audio_filename_with_extension = audio + '.mp3'
 os.rename(audio, audio_filename_with_extension)


 audio_file = open(audio_filename_with_extension, ""rb"")
 transcript = openai.audio.transcriptions.create(
 model=""whisper-1"",
 file=audio_file,
 response_format=""text"",
 language='en'
    )


 messages.append({""role"": ""user"", ""content"": transcript})


 response = openai.chat.completions.create(model=""gpt-4-1106-preview"", messages=messages)


 message_role = response.choices[0].message.role
 message_content = response.choices[0].message.content
 messages.append({""role"": message_role, ""content"": message_content})


 chat_transcript = """"
 for message in messages:
 if message['role'] != 'system':
 chat_transcript += message['role'] + "": "" + message['content'] + ""\n\n""
 return chat_transcript




ui = gr.Interface(fn=transcribe, inputs=gr.Audio(sources=[""microphone""], type=""filepath""), outputs=""text"").launch()
ui.launch()"
fingerprint.js,"(() => {
 let gadgets = [];


 if (typeof _satellite !== 'undefined') {
 gadgets.push('Adobe Dynamic Tag Management');
 }


 if (typeof BOOMR !== 'undefined') {
 gadgets.push('Akamai Boomerang');
 }


 if (typeof goog !== 'undefined' && typeof goog.basePath !== 'undefined') {
 gadgets.push('Closure');
 }


 if (typeof DOMPurify !== 'undefined') {
 gadgets.push('DOMPurify');
 }


 if (typeof window.embedly !== 'undefined') {
 gadgets.push('Embedly Cards');
 }


 if (typeof $ !== 'undefined' && typeof $.fn !== 'undefined' && typeof $.fn.jquery !== 'undefined') {
 gadgets.push('jQuery ');
 }


 if (typeof filterXSS !== 'undefined') {
 gadgets.push('js-xss');
 }


 if (typeof ko !== 'undefined' && typeof ko.version !== 'undefined') {
 gadgets.push('Knockout.js');
 }


 if (typeof _ !== 'undefined' && typeof _.template !== 'undefined' && typeof _.VERSION !== 'undefined') {
 gadgets.push('Lodash <= 4.17.15');
 }


 if (typeof Marionette !== 'undefined') {
 gadgets.push('Marionette.js / Backbone.js');
 }


 if (typeof recaptcha !== 'undefined') {
 gadgets.push('Google reCAPTCHA');
 }


 if (typeof sanitizeHtml !== 'undefined') {
 gadgets.push('sanitize-html');
 }


 if (typeof analytics !== 'undefined' && typeof analytics.SNIPPET_VERSION !== 'undefined') {
 gadgets.push('Segment Analytics.js');
 }


 if (typeof Sprint !== 'undefined') {
 gadgets.push('Sprint.js');
 }


 if (typeof SwiftypeObject != 'undefined') {
 gadgets.push('Swiftype Site Search (uses jQuery BBQ)');
 }


 if (typeof utag !== 'undefined' && typeof utag.id !== 'undefined') {
 gadgets.push('Tealium Universal Tag');
 }


 if (typeof twq !== 'undefined' && typeof twq.version !== 'undefined') {
 gadgets.push('Twitter Universal Website Tag');
 }


 if (typeof wistiaEmbeds !== 'undefined') {
 gadgets.push('Wistia Embedded Video');
 }


 if (typeof $ !== 'undefined' && typeof $.zepto !== 'undefined') {
 gadgets.push('Zepto.js');
 }


 console.log(gadgets);
})();"
picow_ntp_client.py,"import network
import socket
import time
import struct


from machine import Pin


NTP_DELTA = 2208988800
host = ""pool.ntp.org""


led = Pin(""LED"", Pin.OUT)


ssid = 'A NETWORK'
password = 'A PASSWORD'


def set_time():
 NTP_QUERY = bytearray(48)
 NTP_QUERY[0] = 0x1B
 addr = socket.getaddrinfo(host, 123)[0][-1]
 s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
 try:
 s.settimeout(1)
 res = s.sendto(NTP_QUERY, addr)
 msg = s.recv(48)
 finally:
 s.close()
 val = struct.unpack(""!I"", msg[40:44])[0]
 t = val - NTP_DELTA 
 tm = time.gmtime(t)
 machine.RTC().datetime((tm[0], tm[1], tm[2], tm[6] + 1, tm[3], tm[4], tm[5], 0))


wlan = network.WLAN(network.STA_IF)
wlan.active(True)
wlan.connect(ssid, password)


max_wait = 10
while max_wait > 0:
 if wlan.status() < 0 or wlan.status() >= 3:
 break
 max_wait -= 1
 print('waiting for connection...')
 time.sleep(1)


if wlan.status() != 3:
 raise RuntimeError('network connection failed')
else:
 print('connected')
 status = wlan.ifconfig()
 print( 'ip = ' + status[0] )


led.on()
set_time()
print(time.localtime())
led.off()"
data_loader.py,"""""""
Create train, valid, test iterators for CIFAR-10 [1].
Easily extended to MNIST, CIFAR-100 and Imagenet.

[1]: https://discuss.pytorch.org/t/feedback-on-pytorch-for-kaggle-competitions/2252/4
""""""


import torch
import numpy as np


from utils import plot_images
from torchvision import datasets
from torchvision import transforms
from torch.utils.data.sampler import SubsetRandomSampler




def get_train_valid_loader(data_dir,
 batch_size,
 augment,
 random_seed,
 valid_size=0.1,
 shuffle=True,
 show_sample=False,
 num_workers=4,
 pin_memory=False):
 """"""
    Utility function for loading and returning train and valid
    multi-process iterators over the CIFAR-10 dataset. A sample
    9x9 grid of the images can be optionally displayed.

    If using CUDA, num_workers should be set to 1 and pin_memory to True.

    Params
    ------
    - data_dir: path directory to the dataset.
    - batch_size: how many samples per batch to load.
    - augment: whether to apply the data augmentation scheme
      mentioned in the paper. Only applied on the train split.
    - random_seed: fix seed for reproducibility.
    - valid_size: percentage split of the training set used for
      the validation set. Should be a float in the range [0, 1].
    - shuffle: whether to shuffle the train/validation indices.
    - show_sample: plot 9x9 sample grid of the dataset.
    - num_workers: number of subprocesses to use when loading the dataset.
    - pin_memory: whether to copy tensors into CUDA pinned memory. Set it to
      True if using GPU.

    Returns
    -------
    - train_loader: training set iterator.
    - valid_loader: validation set iterator.
    """"""
 error_msg = ""[!] valid_size should be in the range [0, 1].""
 assert ((valid_size >= 0) and (valid_size <= 1)), error_msg


 normalize = transforms.Normalize(
 mean=[0.4914, 0.4822, 0.4465],
 std=[0.2023, 0.1994, 0.2010],
    )


 # define transforms
 valid_transform = transforms.Compose([
 transforms.ToTensor(),
 normalize,
    ])
 if augment:
 train_transform = transforms.Compose([
 transforms.RandomCrop(32, padding=4),
 transforms.RandomHorizontalFlip(),
 transforms.ToTensor(),
 normalize,
        ])
 else:
 train_transform = transforms.Compose([
 transforms.ToTensor(),
 normalize,
        ])


 # load the dataset
 train_dataset = datasets.CIFAR10(
 root=data_dir, train=True,
 download=True, transform=train_transform,
    )


 valid_dataset = datasets.CIFAR10(
 root=data_dir, train=True,
 download=True, transform=valid_transform,
    )


 num_train = len(train_dataset)
 indices = list(range(num_train))
 split = int(np.floor(valid_size * num_train))


 if shuffle:
 np.random.seed(random_seed)
 np.random.shuffle(indices)


 train_idx, valid_idx = indices[split:], indices[:split]
 train_sampler = SubsetRandomSampler(train_idx)
 valid_sampler = SubsetRandomSampler(valid_idx)


 train_loader = torch.utils.data.DataLoader(
 train_dataset, batch_size=batch_size, sampler=train_sampler,
 num_workers=num_workers, pin_memory=pin_memory,
    )
 valid_loader = torch.utils.data.DataLoader(
 valid_dataset, batch_size=batch_size, sampler=valid_sampler,
 num_workers=num_workers, pin_memory=pin_memory,
    )


 # visualize some images
 if show_sample:
 sample_loader = torch.utils.data.DataLoader(
 train_dataset, batch_size=9, shuffle=shuffle,
 num_workers=num_workers, pin_memory=pin_memory,
        )
 data_iter = iter(sample_loader)
 images, labels = data_iter.next()
 X = images.numpy().transpose([0, 2, 3, 1])
 plot_images(X, labels)


 return (train_loader, valid_loader)




def get_test_loader(data_dir,
 batch_size,
 shuffle=True,
 num_workers=4,
 pin_memory=False):
 """"""
    Utility function for loading and returning a multi-process
    test iterator over the CIFAR-10 dataset.

    If using CUDA, num_workers should be set to 1 and pin_memory to True.

    Params
    ------
    - data_dir: path directory to the dataset.
    - batch_size: how many samples per batch to load.
    - shuffle: whether to shuffle the dataset after every epoch.
    - num_workers: number of subprocesses to use when loading the dataset.
    - pin_memory: whether to copy tensors into CUDA pinned memory. Set it to
      True if using GPU.

    Returns
    -------
    - data_loader: test set iterator.
    """"""
 normalize = transforms.Normalize(
 mean=[0.485, 0.456, 0.406],
 std=[0.229, 0.224, 0.225],
    )


 # define transform
 transform = transforms.Compose([
 transforms.ToTensor(),
 normalize,
    ])


 dataset = datasets.CIFAR10(
 root=data_dir, train=False,
 download=True, transform=transform,
    )


 data_loader = torch.utils.data.DataLoader(
 dataset, batch_size=batch_size, shuffle=shuffle,
 num_workers=num_workers, pin_memory=pin_memory,
    )


 return data_loader
import matplotlib.pyplot as plt


label_names = [
 'airplane',
 'automobile',
 'bird',
 'cat',
 'deer',
 'dog',
 'frog',
 'horse',
 'ship',
 'truck'
]




def plot_images(images, cls_true, cls_pred=None):
 """"""
    Adapted from https://github.com/Hvass-Labs/TensorFlow-Tutorials/
    """"""
 fig, axes = plt.subplots(3, 3)


 for i, ax in enumerate(axes.flat):
 # plot img
 ax.imshow(images[i, :, :, :], interpolation='spline16')


 # show true & predicted classes
 cls_true_name = label_names[cls_true[i]]
 if cls_pred is None:
 xlabel = ""{0} ({1})"".format(cls_true_name, cls_true[i])
 else:
 cls_pred_name = label_names[cls_pred[i]]
 xlabel = ""True: {0}\nPred: {1}"".format(
 cls_true_name, cls_pred_name
            )
 ax.set_xlabel(xlabel)
 ax.set_xticks([])
 ax.set_yticks([])


 plt.show()"
qr_householder.py,"""""""
This is the code for QR factorization using Householder Transformation.
This program is made in python 3.5.3 but will be compatible to any python 3.4+ version
We used numpy library for matrix manipulation.
Install numpy using ** pip3 install numpy ** command on terminal.
To run the code write ** python3 qr_householder.py ** on terminal
User has to give dimension of the matrix as input in space separated format and matrix will be generated randomly.
QR factorization can be done for both square and non-square matrices and hence the code supports both.
""""""
import numpy as np


def column_convertor(x):
 """"""
    Converts 1d array to column vector
    """"""
 x.shape = (1, x.shape[0])
 return x


def get_norm(x):
 """"""
    Returns Norm of vector x
    """"""
 return np.sqrt(np.sum(np.square(x)))


def householder_transformation(v):
 """"""
    Returns Householder matrix for vector v
    """"""
 size_of_v = v.shape[1]
 e1 = np.zeros_like(v)
 e1[0, 0] = 1
 vector = get_norm(v) * e1
 if v[0, 0] < 0:
 vector = - vector
 u = (v + vector).astype(np.float32)
 H = np.identity(size_of_v) - ((2 * np.matmul(np.transpose(u), u)) / np.matmul(u, np.transpose(u)))
 return H


def qr_step_factorization(q, r, iter, n):
 """"""
    Return Q and R matrices for iter number of iterations.
    """"""
 v = column_convertor(r[iter:, iter])
 Hbar = householder_transformation(v)
 H = np.identity(n)
 H[iter:, iter:] = Hbar
 r = np.matmul(H, r)
 q = np.matmul(q, H)
 return q, r


def main():
 n, m = list(map(int, input(""Write size of the matrix in space separated format\n"").split()))
 A = np.random.rand(n,m)
 print('The random matrix is \n', A)
 Q = np.identity(n)
 R = A.astype(np.float32)
 for i in range(min(n, m)):
 # For each iteration, H matrix is calculated for (i+1)th row
 Q, R = qr_step_factorization(Q, R, i, n)
 min_dim = min(m, n)
 R = np.around(R, decimals=6)
 R = R[:min_dim, :min_dim]
 Q = np.around(Q, decimals=6)
 print('A after QR factorization')
 print('R matrix')
 print(R, '\n')
 print('Q matrix')
 print(Q)




if __name__ == ""__main__"":
 main()"
json-to-html-table.js,"const json2html = require('node-json2html');
const fs = require('fs-extra')


let template_table_header = {
 ""<>"": ""tr"", ""html"": [
 {""<>"": ""th"", ""html"": ""App Name""},
 {""<>"": ""th"", ""html"": ""Accessibility""},
 {""<>"": ""th"", ""html"": ""Best Practices""},
 {""<>"": ""th"", ""html"": ""SEO""},
 {""<>"": ""th"", ""html"": ""Performance""}
 ]
}


let template_table_body = {
 ""<>"": ""tr"", ""html"": [
 {""<>"": ""td"", ""html"": ""${App Name}""},
 {""<>"": ""td"", ""html"": ""${Accessibility}""},
 {""<>"": ""td"", ""html"": ""${Best Practices}""},
 {""<>"": ""td"", ""html"": ""${SEO}""},
 {""<>"": ""td"", ""html"": ""${Performance}""}
 ]
}


let myJSON = [
 {
 ""App Name"": ""Yahoo"",
 ""Accessibility"": 94,
 ""Best Practices"": 93,
 ""SEO"": 90,
 ""Performance"": 54
 },{
 ""App Name"": ""Google"",
 ""Accessibility"": 89,
 ""Best Practices"": 86,
 ""SEO"": 80,
 ""Performance"": 41
 },{
 ""App Name"": ""Guardian UK"",
 ""Accessibility"": 89,
 ""Best Practices"": 86,
 ""SEO"": 80,
 ""Performance"": 41
 }
]


writeHtmlFromScoresJson(myJSON, 'outfile.html')


function writeHtmlFromScoresJson(jsonFile, htmlTableFile) {
 // let data = fs.readJsonSync(jsonFile);
 let data = jsonFile;


 let table_header = json2html.transform(data[0], template_table_header);
 let table_body = json2html.transform(data, template_table_body);


 let header = '<!DOCTYPE html>' + '<html lang=""en"">\n' + '<head><title>Lighthouse Report</title></head>'
 let body = '<h1>My Report</h1><br><table id=""my_table"">\n<thead>' + table_header + '\n</thead>\n<tbody>\n' + table_body + '\n</tbody>\n</table>'
 body = '<body>' + body + '</body>'


 let html = header + body + '</html>';


 fs.writeFile(htmlTableFile, html, (err) => {
 if (err) throw err;
 });
}"
main.py,"# dependencies
# pip install -U openai gradio


import os, openai
import gradio as gr
openai.api_key = 'sk-xxxxxx'


messages = [{""role"": ""system"", ""content"": """"""Assistant is an expert candidate in
             technical IT job interviews. Currently, the interview is
             focused on a position for Platform Engineer. So, you have skills
             with Terraform, Kubernetes, Docker, Ansible, Python, AWS, and
             more. For technical code questions, use Python. Provide clear,
             short, and concise answers and code. 
             Answers should look human and avoid too much formality when replying.
             Always provide answers in English!""""""}]


def transcribe(audio):
 global messages


 audio_filename_with_extension = audio + '.mp3'
 os.rename(audio, audio_filename_with_extension)


 audio_file = open(audio_filename_with_extension, ""rb"")
 transcript = openai.audio.transcriptions.create(
 model=""whisper-1"",
 file=audio_file,
 response_format=""text"",
 language='en'
    )


 messages.append({""role"": ""user"", ""content"": transcript})


 response = openai.chat.completions.create(model=""gpt-4-1106-preview"", messages=messages)


 message_role = response.choices[0].message.role
 message_content = response.choices[0].message.content
 messages.append({""role"": message_role, ""content"": message_content})


 chat_transcript = """"
 for message in messages:
 if message['role'] != 'system':
 chat_transcript += message['role'] + "": "" + message['content'] + ""\n\n""
 return chat_transcript




ui = gr.Interface(fn=transcribe, inputs=gr.Audio(sources=[""microphone""], type=""filepath""), outputs=""text"").launch()
ui.launch()"
export-google-podcasts-subscription-list-to-opml.js,"// 1. Visit https://podcasts.google.com/subscriptions
// 2. Open your browser's JavaScript console
// 3. Copy-paste the below snippet and press enter:


console.log(`<?xml version='1.0' encoding='UTF-8' standalone='yes' ?>
<opml version=""1.0"">
  <head>
    <title>Google Podcasts Feeds</title>
  </head>
  <body>
    <outline text=""feeds"">
 ${[].map
 .call(document.querySelector(""scrolling-carousel"").querySelectorAll(`a`), (feedLink) => {
 const rssFeedEncodedURL = feedLink
 .getAttribute(""href"")
 .split(""./feed/"")[1]
 .split(""?"")[0];
 const rssFeedName = feedLink.querySelector(""img"").getAttribute(""alt"");
 return {
 name: rssFeedName,
 url: atob(rssFeedEncodedURL),
 };
 })
 .map((feed) => {
 return `<outline type=""rss"" text=""${feed.name}"" xmlUrl=""${feed.url}"" />`;
 }).join(""\n"")
 }
    </outline>
  </body>
</opml>`);


// 4. Copy-paste the result into a new file, e.g. google-podcasts.xml
// 5. Import the file into your new podcast player


// Notes:
// - Sometimes a specific feed URL has a `&` or other symbol that might break the import. Some manual editing might be required, but at least this is quicker than doing it manually"
get_exe_name.c,"static char* get_exe_name(int pid, char *buffer, int buffer_size)
{
 char *result = NULL;


 struct mm_struct* mm = current->mm;
 if (mm)
	{
 int lock_result = down_read_trylock(&mm->mmap_sem);
 if ((lock_result) && (mm->exe_file)) 
		{
 result = d_path(&mm->exe_file->f_path, buffer, buffer_size);            
 up_read(&mm->mmap_sem);
		}
	} 


 if (IS_ERR(result) == true)
    {
 return NULL;
    }
 
 return result;
}"
mifi-mu5001-api.js,"define([""underscore"", ""jquery"", ""config/config""], function(e, t, n) {
 function r(e, t) {
 return i(e, null, null, !1, t)
 }


 function _(e, t, n, r) {
 i(e, t, n, !0, r)
 }


 function i(e, r, _, i, s) {
 var o = null;
 if (n.ACCESSIBLE_ID_SUPPORT && s && ""LOGIN"" != e.goformId && ""SET_WEB_LANGUAGE"" != e.goformId) {
 var a = hex_md5(rd0 + rd1),
 u = hr({
 nv: ""RD""
 }).RD,
 c = hex_md5(a + u);
 e.AD = c
 }
 return e.isTest ? (o = simulate.simulateRequest(e, r, _, i, s), i ? void setTimeout(function() {
 r(o)
 }, getRandomInt(120) + 50) : o) : (t.ajax({
 type: s ? ""POST"" : ""GET"",
 url: s ? ""/goform/goform_set_cmd_process"" : e.cmd ? ""/goform/goform_get_cmd_process"" : ""/goform/goform_set_cmd_process"",
 data: e,
 dataType: ""json"",
 async: !!i,
 cache: !1,
 error: function(e) {
 i ? _(e) : 200 == e.status && (o = jQuery.parseJSON(""("" + e.responseText + "")""))
 },
 success: function(e) {
 i ? r(e) : o = e
 }
 }), i ? void 0 : o)
 }


 function s(e, n, i, s, o, a) {
 function u(e, t, n) {
 if (n = n || t, isErrorObject(e)) switch (e.errorType) {
 case ""cellularNetworkError"":
 case ""deviceError"":
 case ""wifiConnectionError"":
 ii.receivedNonSpecificError(e);
 break;
 default:
 n(e)
 } else t(e)
 }
 var c, d = e[0],
 l = e[1],
 p = e[2];
 if (n && ""string"" == typeof n.errorType) {
 if (c = t.extend(si, n), !l) return c;
 u(c, l, p)
 } else {
 c = t.extend({}, n);
 var m;
 if (m = i ? i(d, a) : d, !l) {
 if (m && (m.cmd || m.goformId)) {
 var f = r(m, a);
 c = s ? t.extend({}, s(f)) : f
 }
 return c
 }
 m && (m.cmd || m.goformId) ? _(m, function(e) {
 c = s ? t.extend({}, s(e)) : t.extend({}, e), m.notCallback || u(c, l, p)
 }, function() {
 c = o ? t.extend(si, o) : t.extend(si, {
 errorType: ""Unknown""
 }), u(c, l, p)
 }, a) : u(c, l, p)
 }
 }


 function o() {
 function e(e, t) {
 var r = {};
 r.isTest = oi;
 var _ = n.PASSWORD_ENCODE ? ""WPAPSK1_encode,m_WPAPSK1_encode,"" : ""WPAPSK1,m_WPAPSK1,"";
 return r.cmd = ""m_ssid_enable,RadioOff,NoForwarding,m_NoForwarding,"" + _ + ""wifi_attr_max_station_number,SSID1,AuthMode,HideSSID,MAX_Access_num,EncrypType,m_SSID,m_AuthMode,m_HideSSID,m_MAX_Access_num,m_EncrypType,wifi_ap_mode_set,m_band_enable,wifi_sta_switch_onoff,wifi_band,wifi_syncparas_flag"", r.multi_data = 1, r
 }


 function r(e) {
 if (e) {
 return {
 wifi_ap_mode_set: e.wifi_ap_mode_set,
 wifi_enable: e.RadioOff,
 multi_ssid_enable: e.m_ssid_enable,
 MAX_Station_num: t.isNumeric(e.wifi_attr_max_station_number) ? e.wifi_attr_max_station_number : n.MAX_STATION_NUMBER,
 AuthMode: e.AuthMode,
 SSID: e.SSID1,
 broadcast: e.HideSSID,
 apIsolation: e.NoForwarding,
 passPhrase: n.PASSWORD_ENCODE ? Base64.decode(e.WPAPSK1_encode) : e.WPAPSK1,
 MAX_Access_num: e.MAX_Access_num,
 cipher: ""TKIP"" == e.EncrypType ? ""0"" : ""AES"" == e.EncrypType ? 1 : 2,
 m_SSID: e.m_SSID,
 m_broadcast: e.m_HideSSID,
 m_apIsolation: e.m_NoForwarding,
 m_MAX_Access_num: e.m_MAX_Access_num,
 m_AuthMode: e.m_AuthMode,
 m_passPhrase: n.PASSWORD_ENCODE ? Base64.decode(e.m_WPAPSK1_encode) : e.m_WPAPSK1,
 m_cipher: ""TKIP"" == e.m_EncrypType ? ""0"" : ""AES"" == e.m_EncrypType ? 1 : 2,
 m_band_enable: e.m_band_enable,
 wifi_sta_switch_onoff: e.wifi_sta_switch_onoff,
 wifiband: e.wifi_band,
 wifi_syncparas_flag: e.wifi_syncparas_flag
 }
 }
 return si
 }
 return s(arguments, {}, e, r, null, !1)
 }


 function a() {
 function e(e) {
 var t = {
 goformId: ""SET_WIFI_SSID1_SSID2_SETTINGS"",
 isTest: oi,
 ssid: e.SSID,
 broadcastSsidEnabled: e.broadcast,
 MAX_Access_num: e.station,
 security_mode: e.AuthMode,
 cipher: e.cipher,
 NoForwarding: e.NoForwarding,
 m_SSID: e.m_SSID,
 m_HideSSID: e.m_broadcast,
 m_MAX_Access_num: e.m_station,
 m_AuthMode: e.m_AuthMode,
 cipher: e.m_cipher,
 m_NoForwarding: e.m_NoForwarding,
 wifi_syncparas_flag: e.wifi_syncparas_flag
 };
 return ""WPAPSKWPA2PSK"" == e.AuthMode || ""WPA2PSK"" == e.AuthMode ? (t.security_shared_mode = e.cipher, t.passphrase = n.PASSWORD_ENCODE ? Base64.encode(e.passPhrase) : e.passPhrase) : t.security_shared_mode = ""NONE"", ""WPAPSKWPA2PSK"" == e.m_AuthMode || ""WPA2PSK"" == e.m_AuthMode ? (t.m_EncrypType = e.m_cipher, t.m_WPAPSK1 = n.PASSWORD_ENCODE ? Base64.encode(e.m_passPhrase) : e.m_passPhrase) : t.m_EncrypType = ""NONE"", t
 }


 function t(e) {
 return e || si
 }
 Je(arguments, e, t)
 }


 function u() {
 function e(e) {
 var t = {
 goformId: ""SET_WIFI_SSID1_SETTINGS"",
 isTest: oi,
 ssid: e.SSID,
 broadcastSsidEnabled: e.broadcast,
 MAX_Access_num: e.station,
 security_mode: e.AuthMode,
 cipher: e.cipher,
 NoForwarding: e.NoForwarding
 };
 return ""WPAPSKWPA2PSK"" == e.AuthMode || ""WPA2PSK"" == e.AuthMode ? (t.security_shared_mode = e.cipher, t.passphrase = n.PASSWORD_ENCODE ? Base64.encode(e.passPhrase) : e.passPhrase) : t.security_shared_mode = ""NONE"", t
 }


 function t(e) {
 return e || si
 }
 Je(arguments, e, t)
 }


 function c() {
 function e(e) {
 var t = {
 goformId: ""SET_WIFI_SSID2_SETTINGS"",
 isTest: oi,
 m_SSID: e.m_SSID,
 m_HideSSID: e.m_broadcast,
 m_MAX_Access_num: e.m_station,
 m_AuthMode: e.m_AuthMode,
 cipher: e.m_cipher,
 m_NoForwarding: e.m_NoForwarding
 };
 return ""WPAPSKWPA2PSK"" == e.m_AuthMode || ""WPA2PSK"" == e.m_AuthMode ? (t.m_EncrypType = e.m_cipher, t.m_WPAPSK1 = n.PASSWORD_ENCODE ? Base64.encode(e.m_passPhrase) : e.m_passPhrase) : t.m_EncrypType = ""NONE"", t
 }


 function t(e) {
 return e || si
 }
 Je(arguments, e, t)
 }


 function d() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.goformId = ""CHANGE_DEFAULT_WIFI_OR_PASSWORD_REMIND"", n.password_remind = ""0"", n.web_wifi_password_remind = ""0"", n
 }


 function t(e) {
 return e && ""success"" == e.result ? e : si
 }
 return s(arguments, {}, e, t, null, !0)
 }


 function l() {
 function e(e) {
 var t = {
 goformId: ""SET_M_WIFI_INFO"",
 isTest: oi,
 m_WirelessMode: e.m_WirelessMode,
 m_CountryCode: e.m_CountryCode
 };
 return n.WIFI_BAND_SUPPORT && (t.m_wifi_band = e.m_wifi_band), t.m_Channel = e.m_Channel, n.WIFI_BANDWIDTH_SUPPORT && (t.m_wifi_11n_cap = e.m_wifi_11n_cap), t
 }


 function t(e) {
 return e || si
 }
 Je(arguments, e, t)
 }


 function p() {
 function e(e) {
 return {
 goformId: ""SET_WIFI_AP_MODE"",
 isTest: oi,
 wifi_ap_mode_set: e.wifi_ap_mode_set
 }
 }


 function t(e) {
 return e || si
 }
 Je(arguments, e, t)
 }


 function m() {
 function e(e) {
 var n = e;
 return ""0"" == e.wifiEnabled && (n = {
 wifiEnabled: e.wifiEnabled
 }), t.extend({
 goformId: ""SET_WIFI_INFO"",
 isTest: oi
 }, n)
 }


 function n(e) {
 return e || si
 }
 Je(arguments, e, n)
 }


 function f() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.cmd = ""AuthMode,passPhrase"", n.multi_data = 1, n
 }


 function t(e) {
 if (e) {
 var t = {};
 return t.AuthMode = e.AuthMode, t.passPhrase = n.PASSWORD_ENCODE ? Base64.decode(e.passPhrase) : e.passPhrase, t
 }
 return si
 }
 return s(arguments, {}, e, t, null, !1)
 }


 function g() {
 function e(e, t) {
 var r = {};
 return r.isTest = oi, r.goformId = ""SET_WIFI_SECURITY_INFO"", r.AuthMode = e.AuthMode, ""WPAPSKWPA2PSK"" == r.AuthMode && (r.passPhrase = n.PASSWORD_ENCODE ? Base64.encode(e.passPhrase) : e.passPhrase), r
 }


 function t(e) {
 return e || si
 }
 return s(arguments, {}, e, t, null, !0)
 }


 function v() {
 function e(e, t) {
 return {
 isTest: oi,
 cmd: ""station_list""
 }
 }


 function n(e) {
 for (var n = [], r = e.station_list, _ = 0; r && _ < r.length; _++) {
 var i = {};
 i.macAddress = r[_].mac_addr;
 var s = r[_].hostname;
 i.hostName = """" == s ? t.i18n.prop(""unknown"") : s, i.ipAddress = r[_].ip_addr, i.ssid_index = r[_].ssid_index, n.push(i)
 }
 return {
 attachedDevices: n
 }
 }
 return s(arguments, {}, e, n, null, !1)
 }


 function w() {
 function e(e, t) {
 return {
 isTest: oi,
 cmd: ""lan_station_list""
 }
 }


 function n(e) {
 for (var n = [], r = e.lan_station_list || e.station_list, _ = 0; r && _ < r.length; _++) {
 var i = {};
 i.macAddress = r[_].mac_addr;
 var s = r[_].hostname;
 i.hostName = """" == s ? t.i18n.prop(""unknown"") : s, i.ipAddress = r[_].ip_addr, n.push(i)
 }
 return {
 attachedDevices: n
 }
 }
 return s(arguments, {}, e, n, null, !1)
 }


 function h() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.cmd = ""Language,cr_version,wa_inner_version"", n.multi_data = 1, n
 }


 function t(e) {
 if (e) {
 var t = {};
 return t.Language = e && e.Language ? e.Language : ""en"", t.rd_params0 = e.wa_inner_version, t.rd_params1 = e.cr_version, t
 }
 return si
 }
 return s(arguments, {}, e, t, null, !1)
 }


 function S() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.goformId = ""SET_WEB_LANGUAGE"", n.Language = e.Language, n
 }


 function t(e) {
 return e || si
 }
 return s(arguments, {}, e, t, null, !0)
 }


 function T() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.cmd = ""current_network_mode,m_netselect_save,net_select_mode,m_netselect_contents,net_select,ppp_status,modem_main_state"", n.multi_data = 1, n
 }


 function t(e) {
 if (e) {
 var t = {};
 return t.current_network_mode = e.current_network_mode, t.net_select_mode = e.net_select_mode, t.m_netselect_save = e.m_netselect_save, t.m_netselect_contents = e.m_netselect_contents, t.net_select = e.net_select, t.ppp_status = e.ppp_status, t.modem_main_state = e.modem_main_state, t
 }
 return si
 }
 return s(arguments, {}, e, t, null, !1)
 }


 function P() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.goformId = ""SET_BEARER_PREFERENCE"", n.BearerPreference = e.strBearerPreference, n
 }


 function t(e) {
 return e || si
 }
 return s(arguments, {}, e, t, null, !0)
 }


 function I(e) {
 function r() {
 t.getJSON(""/goform/goform_get_cmd_process"", {
 cmd: ""m_netselect_status"",
 _: (new Date).getTime()
 }, function(n) {
 ""manual_selecting"" == n.m_netselect_status ? setTimeout(r, 1e3) : t.getJSON(""/goform/goform_get_cmd_process"", {
 cmd: ""m_netselect_contents"",
 _: (new Date).getTime()
 }, function(t) {
 """" != trim(t.m_netselect_contents) ? _(t.m_netselect_contents) : e(!1, [])
 }).error(function() {
 e(!1, [])
 })
 }).error(function() {
 e(!1, [])
 })
 }


 function _(t) {
 for (var n, r = /([^,;]*),([^,]*),([^,]*),([^,;]*)/g, _ = []; n = r.exec(t);) null != n && _.push({
 strShortName: n[2].replace(/\""/g, """"),
 strNumeric: n[3].replace(/\D/g, """"),
 nRat: parseInt(n[4], 10),
 nState: parseInt(n[1], 10)
 });
 e(!0, _)
 }
 if (oi) return void setTimeout(function() {
 _(simulate.m_netselect_contents)
 }, 500);
 var i = {};
 if (i.goformId = ""SCAN_NETWORK"", n.ACCESSIBLE_ID_SUPPORT) {
 var s = hex_md5(rd0 + rd1),
 o = hr({
 nv: ""RD""
 }).RD,
 a = hex_md5(s + o);
 i.AD = a
 }
 t.post(""/goform/goform_set_cmd_process"", i, function(t) {
 ""success"" == t.result ? r() : e(!1, [])
 }, ""json"").error(function() {
 e(!1, [])
 })
 }


 function b() {
 if (void 0 === ci.isLoggedIn) {
 var e = le();
 return {
 networkType: ci.networkType,
 signalImg: ci.signalImg,
 networkOperator: ci.networkOperator,
 spn_b1_flag: ci.spn_b1_flag,
 spn_name_data: ci.spn_name_data,
 spn_b2_flag: ci.spn_b2_flag,
 connectStatus: ci.connectStatus,
 attachedDevices: ci.curr_connected_devices,
 roamingStatus: ci.roamingStatus,
 wifiStatus: ci.wifiStatus,
 wifiSwitchStatus: ci.wifiSwitchStatus,
 simStatus: ci.simStatus,
 pinStatus: ci.pinStatus,
 batteryStatus: ci.batteryStatus,
 batteryLevel: ci.batteryLevel,
 batteryPers: ci.batteryPers,
 batteryTime: ci.batteryTime,
 ssid: ci.ssid,
 mainSSID5g: ci.mainSSID5g,
 station_num_ssid1: ci.station_num_ssid1,
 station_num_ssid2: ci.station_num_ssid2,
 station_num_guest_ssid1: ci.station_num_guest_ssid1,
 station_num_guest_ssid2: ci.station_num_guest_ssid2,
 authMode: ci.authMode,
 data_counter: ci.data_counter,
 isLoggedIn: ""loggedIn"" == e.status,
 newSmsReceived: ci.newSmsReceived,
 smsReportReceived: ci.smsReportReceived,
 smsUnreadCount: ci.smsUnreadCount,
 limitVolumeEnable: ci.limitVolumeEnable,
 limitVolumeType: ci.limitVolumeType,
 limitVolumePercent: ci.limitVolumePercent,
 limitVolumeSize: ci.limitVolumeSize,
 limitVolumeSizeSource: ci.limitVolumeSizeSource,
 connectWifiProfile: ci.connectWifiProfile,
 connectWifiSSID: ci.connectWifiSSID,
 connectWifiStatus: ci.connectWifiStatus,
 multi_ssid_enable: ci.multi_ssid_enable,
 roamMode: ci.roamMode,
 opms_wan_mode: ci.opms_wan_mode,
 opms_wan_auto_mode: ci.opms_wan_auto_mode,
 dhcp_wan_status: ci.dhcp_wan_status,
 current_upgrade_state: ci.current_upgrade_state,
 is_mandatory: ci.is_mandatory,
 new_version_state: ci.new_version_state,
 allowRoamingUpdate: ci.allowRoamingUpdate,
 wifi_dfs_status: ci.wifi_dfs_status,
 radio_off: ci.radio_off,
 wifi_5g_enable: ci.wifi_5g_enable,
 battery_value: ci.battery_value,
 ap_station_enable: ci.ap_station_enable,
 ap_station_mode: ci.ap_station_mode,
 dialMode: ci.dialMode,
 isCaStatus: ci.isCaStatus,
 privacy_read_flag: ci.privacy_read_flag,
 ppp_dial_conn_fail_counter: ci.ppp_dial_conn_fail_counter,
 is_night_mode: ci.is_night_mode,
 pppoe_status: ci.pppoe_status,
 dhcp_wan_status: ci.dhcp_wan_status,
 static_wan_status: ci.static_wan_status,
 vpn_conn_status: ci.vpn_conn_status,
 wan_connect_status: ci.wan_connect_status,
 battery_charg_type: ci.battery_charg_type,
 external_charging_flag: ci.external_charging_flag,
 mode_main_state: ci.mode_main_state,
 battery_temp: ci.battery_temp,
 mdm_mcc: ci.mdm_mcc,
 mdm_mnc: ci.mdm_mnc
 }
 }
 return {
 networkType: ci.networkType,
 signalImg: ci.signalImg,
 networkOperator: ci.networkOperator,
 spn_b1_flag: ci.spn_b1_flag,
 spn_name_data: ci.spn_name_data,
 spn_b2_flag: ci.spn_b2_flag,
 connectStatus: ci.connectStatus,
 attachedDevices: ci.curr_connected_devices,
 roamingStatus: ci.roamingStatus,
 wifiStatus: ci.wifiStatus,
 wifiSwitchStatus: ci.wifiSwitchStatus,
 simStatus: ci.simStatus,
 pinStatus: ci.pinStatus,
 batteryStatus: ci.batteryStatus,
 batteryLevel: ci.batteryLevel,
 batteryPers: ci.batteryPers,
 batteryTime: ci.batteryTime,
 ssid: ci.ssid,
 mainSSID5g: ci.mainSSID5g,
 station_num_ssid1: ci.station_num_ssid1,
 station_num_ssid2: ci.station_num_ssid2,
 station_num_guest_ssid1: ci.station_num_guest_ssid1,
 station_num_guest_ssid2: ci.station_num_guest_ssid2,
 authMode: ci.authMode,
 data_counter: ci.data_counter,
 isLoggedIn: ci.isLoggedIn,
 newSmsReceived: ci.newSmsReceived,
 smsReportReceived: ci.smsReportReceived,
 smsUnreadCount: ci.smsUnreadCount,
 limitVolumeEnable: ci.limitVolumeEnable,
 limitVolumeType: ci.limitVolumeType,
 limitVolumePercent: ci.limitVolumePercent,
 limitVolumeSize: ci.limitVolumeSize,
 limitVolumeSizeSource: ci.limitVolumeSizeSource,
 connectWifiProfile: ci.connectWifiProfile,
 connectWifiSSID: ci.connectWifiSSID,
 connectWifiStatus: ci.connectWifiStatus,
 multi_ssid_enable: ci.multi_ssid_enable,
 opms_wan_mode: ci.opms_wan_mode,
 opms_wan_auto_mode: ci.opms_wan_auto_mode,
 dhcp_wan_status: ci.dhcp_wan_status,
 roamMode: ci.roamMode,
 current_upgrade_state: ci.current_upgrade_state,
 is_mandatory: ci.is_mandatory,
 new_version_state: ci.new_version_state,
 allowRoamingUpdate: ci.allowRoamingUpdate,
 wifi_dfs_status: ci.wifi_dfs_status,
 radio_off: ci.radio_off,
 wifi_5g_enable: ci.wifi_5g_enable,
 battery_value: ci.battery_value,
 ap_station_enable: ci.ap_station_enable,
 ap_station_mode: ci.ap_station_mode,
 dialMode: ci.dialMode,
 isCaStatus: ci.isCaStatus,
 privacy_read_flag: ci.privacy_read_flag,
 ppp_dial_conn_fail_counter: ci.ppp_dial_conn_fail_counter,
 is_night_mode: ci.is_night_mode,
 pppoe_status: ci.pppoe_status,
 dhcp_wan_status: ci.dhcp_wan_status,
 static_wan_status: ci.static_wan_status,
 vpn_conn_status: ci.vpn_conn_status,
 wan_connect_status: ci.wan_connect_status,
 battery_charg_type: ci.battery_charg_type,
 external_charging_flag: ci.external_charging_flag,
 mode_main_state: ci.mode_main_state,
 battery_temp: ci.battery_temp,
 mdm_mcc: ci.mdm_mcc,
 mdm_mnc: ci.mdm_mnc
 }
 }


 function A() {
 var e = ""1"" == ci.limitVolumeType,
 t = {
 data_counter: ci.data_counter,
 connectStatus: ci.connectStatus,
 limitVolumeEnable: ci.limitVolumeEnable,
 limitVolumeType: ci.limitVolumeType,
 limitVolumePercent: ci.limitVolumePercent,
 networkType: ci.networkType,
 isCaStatus: ci.isCaStatus
 };
 return e ? (t.limitDataMonth = ci.limitVolumeSize, t.limitDataMonthSource = ci.limitVolumeSizeSource, t.limitTimeMonth = 0) : (t.limitTimeMonth = ci.limitVolumeSize, t.limitTimeMonthSource = ci.limitVolumeSizeSource, t.limitDataMonth = 0), t.opms_wan_mode = ci.opms_wan_mode, t.opms_wan_auto_mode = ci.opms_wan_auto_mode, t
 }


 function y() {
 ci.newSmsReceived = !1
 }


 function E() {
 ci.smsReportReceived = !1
 }


 function R() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.cmd = ""sms_capacity_info"", n
 }


 function t(e) {
 return {
 nvTotal: parseInt(e.sms_nv_total, 10),
 nvUsed: parseInt(e.sms_nv_rev_total, 10) + parseInt(e.sms_nv_send_total, 10) + parseInt(e.sms_nv_draftbox_total, 10),
 simTotal: parseInt(e.sms_sim_total, 10),
 simUsed: parseInt(e.sms_sim_rev_total, 10) + parseInt(e.sms_sim_send_total, 10) + parseInt(e.sms_sim_draftbox_total, 10),
 nvReceive: parseInt(e.sms_nv_rev_total, 10),
 nvSend: parseInt(e.sms_nv_send_total, 10),
 nvDraft: parseInt(e.sms_nv_draftbox_total, 10),
 simReceive: parseInt(e.sms_sim_rev_total, 10),
 simSend: parseInt(e.sms_sim_send_total, 10),
 simDraft: parseInt(e.sms_sim_draftbox_total, 10)
 }
 }
 return s(arguments, {}, e, t, null, !1)
 }


 function N() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.notCallback = !0, n.goformId = ""CONNECT_NETWORK"", n
 }


 function t(e) {
 ""success"" == e.result ? (_ = (new Date).getTime(), U(n)) : r({
 result: !1
 })
 }


 function n(e) {
 ""ppp_connecting"" == e.ppp_status ? ci.connectStatus = ""ppp_connecting"" : checkConnectedStatus(e.ppp_status) ? (B(n), ci.connectStatus = ""ppp_connected"", r({
 result: !0,
 status: ci.connectStatus
 })) : (new Date).getTime() - _ < 1e4 ? ci.connectStatus = ""ppp_connecting"" : (B(n), r({
 result: !1
 }))
 }
 var r = arguments[1],
 _ = 0;
 return s(arguments, {}, e, t, null, !0)
 }


 function M() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.notCallback = !0, n.goformId = ""DISCONNECT_NETWORK"", n
 }


 function t(e) {
 ""success"" == e.result ? (_ = (new Date).getTime(), U(n)) : r({
 result: !1
 })
 }


 function n(e) {
 ""ppp_disconnecting"" == e.ppp_status ? ci.connectStatus = ""ppp_disconnecting"" : ""ppp_disconnected"" == e.ppp_status ? (B(n), ci.connectStatus = ""ppp_disconnected"", r({
 result: !0,
 status: ci.connectStatus
 })) : (new Date).getTime() - _ < 1e4 ? ci.connectStatus = ""ppp_disconnecting"" : (B(n), r({
 result: !1
 }))
 }
 var r = arguments[1],
 _ = 0;
 return s(arguments, {}, e, t, null, !0)
 }


 function D() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.cmd = ""apn_interface_version,APN_config0,APN_config1,APN_config2,APN_config3,APN_config4,APN_config5,APN_config6,APN_config7,APN_config8,APN_config9,APN_config10,APN_config11,APN_config12,APN_config13,APN_config14,APN_config15,APN_config16,APN_config17,APN_config18,APN_config19,ipv6_APN_config0,ipv6_APN_config1,ipv6_APN_config2,ipv6_APN_config3,ipv6_APN_config4,ipv6_APN_config5,ipv6_APN_config6,ipv6_APN_config7,ipv6_APN_config8,ipv6_APN_config9,ipv6_APN_config10,ipv6_APN_config11,ipv6_APN_config12,ipv6_APN_config13,ipv6_APN_config14,ipv6_APN_config15,ipv6_APN_config16,ipv6_APN_config17,ipv6_APN_config18,ipv6_APN_config19,m_profile_name,profile_name,wan_dial,apn_select,pdp_type,pdp_select,pdp_addr,index,Current_index,apn_auto_config,ipv6_apn_auto_config,apn_mode,wan_apn,ppp_auth_mode,ppp_username,ppp_passwd,dns_mode,prefer_dns_manual,standby_dns_manual,ipv6_wan_apn,ipv6_pdp_type,ipv6_ppp_auth_mode,ipv6_ppp_username,ipv6_ppp_passwd,ipv6_dns_mode,ipv6_prefer_dns_manual,ipv6_standby_dns_manual,apn_num_preset,wan_apn_ui,profile_name_ui,pdp_type_ui,ppp_auth_mode_ui,ppp_username_ui,ppp_passwd_ui,dns_mode_ui,prefer_dns_manual_ui,standby_dns_manual_ui,ipv6_wan_apn_ui,ipv6_ppp_auth_mode_ui,ipv6_ppp_username_ui,ipv6_ppp_passwd_ui,ipv6_dns_mode_ui,ipv6_prefer_dns_manual_ui,ipv6_standby_dns_manual_ui"", n.multi_data = 1, n
 }


 function t(e) {
 return e ? {
 APNs: e.APN_config0 + ""||"" + e.APN_config1 + ""||"" + e.APN_config2 + ""||"" + e.APN_config3 + ""||"" + e.APN_config4 + ""||"" + e.APN_config5 + ""||"" + e.APN_config6 + ""||"" + e.APN_config7 + ""||"" + e.APN_config8 + ""||"" + e.APN_config9 + ""||"" + e.APN_config10 + ""||"" + e.APN_config11 + ""||"" + e.APN_config12 + ""||"" + e.APN_config13 + ""||"" + e.APN_config14 + ""||"" + e.APN_config15 + ""||"" + e.APN_config16 + ""||"" + e.APN_config17 + ""||"" + e.APN_config18 + ""||"" + e.APN_config19,
 ipv6APNs: e.ipv6_APN_config0 + ""||"" + e.ipv6_APN_config1 + ""||"" + e.ipv6_APN_config2 + ""||"" + e.ipv6_APN_config3 + ""||"" + e.ipv6_APN_config4 + ""||"" + e.ipv6_APN_config5 + ""||"" + e.ipv6_APN_config6 + ""||"" + e.ipv6_APN_config7 + ""||"" + e.ipv6_APN_config8 + ""||"" + e.ipv6_APN_config9 + ""||"" + e.ipv6_APN_config10 + ""||"" + e.ipv6_APN_config11 + ""||"" + e.ipv6_APN_config12 + ""||"" + e.ipv6_APN_config13 + ""||"" + e.ipv6_APN_config14 + ""||"" + e.ipv6_APN_config15 + ""||"" + e.ipv6_APN_config16 + ""||"" + e.ipv6_APN_config17 + ""||"" + e.ipv6_APN_config18 + ""||"" + e.ipv6_APN_config19,
 apnMode: e.apn_mode,
 profileName: e.apn_interface_version >= 2 ? e.profile_name_ui : e.m_profile_name || e.profile_name,
 wanDial: e.wan_dial,
 apnSelect: e.apn_select,
 pdpType: e.apn_interface_version >= 2 ? e.pdp_type_ui : e.pdp_type,
 pdpSelect: e.pdp_select,
 pdpAddr: e.pdp_addr,
 index: e.index,
 currIndex: e.Current_index,
 autoApns: e.apn_auto_config,
 autoApnsV6: e.ipv6_apn_auto_config,
 wanApn: e.apn_interface_version >= 2 ? e.wan_apn_ui : e.wan_apn,
 authMode: e.apn_interface_version >= 2 ? e.ppp_auth_mode_ui.toLowerCase() : e.ppp_auth_mode.toLowerCase(),
 username: e.apn_interface_version >= 2 ? e.ppp_username_ui : e.ppp_username,
 password: e.apn_interface_version >= 2 ? e.ppp_passwd_ui : e.ppp_passwd,
 dnsMode: e.apn_interface_version >= 2 ? e.dns_mode_ui : e.dns_mode,
 dns1: e.apn_interface_version >= 2 ? e.prefer_dns_manual_ui : e.prefer_dns_manual,
 dns2: e.apn_interface_version >= 2 ? e.standby_dns_manual_ui : e.standby_dns_manual,
 wanApnV6: e.apn_interface_version >= 2 ? e.ipv6_wan_apn_ui : e.ipv6_wan_apn,
 authModeV6: e.apn_interface_version >= 2 ? e.ipv6_ppp_auth_mode_ui.toLowerCase() : e.ipv6_ppp_auth_mode.toLowerCase(),
 usernameV6: e.apn_interface_version >= 2 ? e.ipv6_ppp_username_ui : e.ipv6_ppp_username,
 passwordV6: e.apn_interface_version >= 2 ? e.ipv6_ppp_passwd_ui : e.ipv6_ppp_passwd,
 dnsModeV6: e.apn_interface_version >= 2 ? e.ipv6_dns_mode_ui : e.ipv6_dns_mode,
 dns1V6: e.apn_interface_version >= 2 ? e.ipv6_prefer_dns_manual_ui : e.ipv6_prefer_dns_manual,
 dns2V6: e.apn_interface_version >= 2 ? e.ipv6_standby_dns_manual_ui : e.ipv6_standby_dns_manual,
 apnNumPreset: e.apn_num_preset
 } : {
 result: !1
 }
 }
 return s(arguments, {}, e, t, null, !1)
 }


 function C() {
 function e(e, t) {
 var r = {
 isTest: oi,
 apn_action: ""delete"",
 apn_mode: ""manual"",
 index: e.index
 };
 return n.USE_IPV6_INTERFACE ? r.goformId = ""APN_PROC_EX"" : r.goformId = ""APN_PROC"", r
 }


 function t(e) {
 return ""success"" == e.result ? {
 result: !0
 } : {
 result: !1
 }
 }
 return s(arguments, {}, e, t, null, !0)
 }


 function k() {
 function e(e, t) {
 if (n.USE_IPV6_INTERFACE) {
 var r = {
 isTest: oi,
 goformId: ""APN_PROC_EX"",
 apn_mode: e.apnMode
 };
 return ""manual"" == e.apnMode && (r.apn_action = ""set_default"", r.set_default_flag = ""1"", r.pdp_type = e.pdpType, r.index = e.index), r
 }
 return {
 isTest: oi,
 goformId: ""APN_PROC"",
 apn_action: ""set_default"",
 index: e.index,
 apn_mode: e.apnMode,
 profile_name: e.profileName,
 wan_apn: e.wanApn,
 dns_mode: e.dnsMode,
 prefer_dns_manual: e.dns1,
 w_standby_dns_manual: e.dns2,
 ppp_username: e.username,
 ppp_passwd: e.password,
 ppp_auth_mode: e.authMode,
 apn_select: ""manual"",
 wan_dial: ""*99#"",
 pdp_type: ""PPP"",
 pdp_select: ""auto"",
 pdp_addr: """",
 set_default_flag: ""1""
 }
 }


 function t(e) {
 return ""success"" == e.result ? {
 result: !0
 } : {
 result: !1
 }
 }
 return s(arguments, {}, e, t, null, !0)
 }


 function F() {
 function e(e, r) {
 if (n.USE_IPV6_INTERFACE) {
 var _ = {
 isTest: oi,
 goformId: ""APN_PROC_EX"",
 apn_action: ""save"",
 apn_mode: ""manual"",
 profile_name: e.profileName,
 wan_dial: ""*99#"",
 apn_select: ""manual"",
 pdp_type: e.pdpType,
 pdp_select: ""auto"",
 pdp_addr: """",
 index: e.index
 };
 return ""IP"" == e.pdpType ? t.extend(_, {
 wan_apn: e.wanApn,
 ppp_auth_mode: e.authMode,
 ppp_username: e.username,
 ppp_passwd: e.password,
 dns_mode: e.dnsMode,
 prefer_dns_manual: e.dns1,
 standby_dns_manual: e.dns2
 }) : ""IPv6"" == e.pdpType ? t.extend(_, {
 ipv6_wan_apn: e.wanApnV6,
 ipv6_ppp_auth_mode: e.authModeV6,
 ipv6_ppp_username: e.usernameV6,
 ipv6_ppp_passwd: e.passwordV6,
 ipv6_dns_mode: e.dnsModeV6,
 ipv6_prefer_dns_manual: e.dns1V6,
 ipv6_standby_dns_manual: e.dns2V6
 }) : t.extend(_, {
 wan_apn: e.wanApn,
 ppp_auth_mode: e.authMode,
 ppp_username: e.username,
 ppp_passwd: e.password,
 dns_mode: e.dnsMode,
 prefer_dns_manual: e.dns1,
 standby_dns_manual: e.dns2,
 ipv6_wan_apn: e.wanApnV6,
 ipv6_ppp_auth_mode: e.authModeV6,
 ipv6_ppp_username: e.usernameV6,
 ipv6_ppp_passwd: e.passwordV6,
 ipv6_dns_mode: e.dnsModeV6,
 ipv6_prefer_dns_manual: e.dns1V6,
 ipv6_standby_dns_manual: e.dns2V6
 }), _
 }
 var _ = {
 isTest: oi,
 goformId: ""APN_PROC"",
 apn_action: ""save"",
 apn_mode: ""manual"",
 index: e.index,
 profile_name: e.profileName,
 wan_apn: e.wanApn,
 dns_mode: e.dnsMode,
 prefer_dns_manual: e.dns1,
 w_standby_dns_manual: e.dns2,
 ppp_auth_mode: e.authMode,
 ppp_username: e.username,
 ppp_passwd: e.password,
 wan_dial: ""*99#"",
 apn_select: ""manual"",
 pdp_type: ""PPP"",
 pdp_select: ""auto"",
 pdp_addr: """"
 };
 return _
 }


 function r(e) {
 return ""success"" == e.result ? {
 result: !0
 } : {
 result: !1
 }
 }
 return s(arguments, {}, e, r, null, !0)
 }


 function W() {
 if (!ai) return void setTimeout(function() {
 W()
 }, 1e3);
 _(x(), function(e) {
 for (var n = 0; n < mi.length; n++) ""function"" == typeof mi[n] && mi[n](e);
 t.merge(mi, pi), pi = [], setTimeout(function() {
 W()
 }, 1e3)
 }, function() {
 K(), setTimeout(function() {
 W()
 }, 1e3)
 }, !1)
 }


 function x() {
 var r = {
 multi_data: 1,
 isTest: oi
 };
 return window.location.hash && ""#login"" != window.location.hash && ci.isLoggedIn ? (n.HAS_SMS && (r.sms_received_flag_flag = 0, r.sts_received_flag_flag = 0), li.length > 0 && -1 == e.indexOf(di, li[0]) && t.each(li, function(e, t) {
 di.push(t)
 })) : li.length > 0 && -1 != e.indexOf(di, li[0]) && (di = e.without(di, li)), r.cmd = di.join("",""), r
 }


 function L(t, n) {
 if (e.isArray(t))
 for (var r = 0; r < t.length; r++) V(t[r]);
 else V(t);
 U(n)
 }


 function O(t, n) {
 if (e.isArray(t))
 for (var r = 0; r < t.length; r++) H(t[r]);
 else H(t);
 B(n)
 }


 function U(t) {
 -1 == e.indexOf(pi, t) && pi.push(t)
 }


 function B(t) {
 return mi = e.without(mi, t), 0 == mi.length && mi.push(G), pi
 }


 function V(t) {
 -1 == e.indexOf(di, t) && di.push(t)
 }


 function H(t) {
 return di = e.without(di, t)
 }


 function G(e) {
 ci.signalImg = void 0 === e.signalbar ? ""0"" : e.signalbar, ci.networkType = e.network_type ? e.network_type : """", -1 != ci.networkType.toLowerCase().indexOf(""limited_service"") || -1 != ci.networkType.toLowerCase().indexOf(""limited service"") ? ci.networkType = ""limited_service"" : -1 == ci.networkType.toLowerCase().indexOf(""no_service"") && -1 == ci.networkType.toLowerCase().indexOf(""no service"") || (ci.networkType = ""no_service""), ci.networkOperator = e.network_provider ? e.network_provider : """", ci.spn_b1_flag = e.spn_b1_flag, ci.spn_b2_flag = e.spn_b2_flag, ci.spn_name_data = e.spn_name_data, ""AUTO_DHCP"" == e.opms_wan_auto_mode ? ""1"" == e.dhcp_wan_status ? ci.connectStatus = ""ppp_connected"" : ci.connectStatus = ""ppp_disconnected"" : ci.connectStatus = void 0 === e.ppp_status ? ""ppp_disconnected"" : e.ppp_status;
 var t = e.wifi_access_sta_num && """" != e.wifi_access_sta_num ? e.wifi_access_sta_num : 0;
 ci.curr_connected_devices = t, ci.roamingStatus = z(ci.networkType, e.modem_main_state, e.simcard_roam), ci.wifiStatus = ""1"" == e.wifi_onoff_state, ci.wifiSwitchStatus = e.wifi_onoff_state, ci.simStatus = e.modem_main_state, ci.pinStatus = e.pin_status;
 var r = e.battery_vol_percent && e.battery_vol_percent.length > 0 ? e.battery_vol_percent : 100;
 ci.batteryPers = e.battery_pers;
 var _ = Math.round(10800 * (1 - r / 100));
 if (ci.batteryStatus = void 0 === e.battery_charging ? ""0"" : e.battery_charging, ci.battery_value = void 0 === e.battery_value ? ""0"" : e.battery_value, ci.batteryLevel = r, ci.batteryTime = _.toString(), ci.data_counter = {
 uploadRate: """" == e.realtime_tx_thrpt ? 0 : e.realtime_tx_thrpt,
 downloadRate: """" == e.realtime_rx_thrpt ? 0 : e.realtime_rx_thrpt,
 currentSent: """" == e.realtime_tx_bytes ? 0 : e.realtime_tx_bytes,
 currentReceived: """" == e.realtime_rx_bytes ? 0 : e.realtime_rx_bytes,
 currentConnectedTime: """" == e.realtime_time ? 0 : e.realtime_time,
 monthlySent: """" == e.monthly_tx_bytes ? 0 : e.monthly_tx_bytes,
 monthlyReceived: """" == e.monthly_rx_bytes ? 0 : e.monthly_rx_bytes,
 monthlyConnectedTime: """" == e.monthly_time ? 0 : e.monthly_time,
 month: """" == e.date_month ? 1 : e.date_month
 }, ci.ssid = e.wifi_chip1_ssid1_ssid, ci.mainSSID5g = e.wifi_chip2_ssid1_ssid, ci.station_num_ssid1 = e.wifi_chip1_ssid1_access_sta_num, ci.station_num_ssid2 = e.wifi_chip2_ssid1_access_sta_num, n.HAS_MULTI_SSID && (ci.station_num_guest_ssid1 = e.wifi_chip1_ssid2_access_sta_num, ci.station_num_guest_ssid2 = e.wifi_chip2_ssid2_access_sta_num), ci.authMode = e.AuthMode, ci.isLoggedIn && 1 == ci.isLoggedIn && ""ok"" != e.loginfo ? ui > 2 ? (ci.isLoggedIn = !n.HAS_LOGIN || ""ok"" == e.loginfo, ui = 0) : ui++ : ci.isLoggedIn = !n.HAS_LOGIN || ""ok"" == e.loginfo, n.HAS_SMS && (ci.newSmsReceived || (ci.newSmsReceived = e.sms_received_flag > 0), ci.smsReportReceived || (ci.smsReportReceived = e.sts_received_flag > 0), void 0 !== e.sms_dev_unread_num ? ci.smsUnreadCount = n.SMS_UNREAD_NUM_INCLUDE_SIM ? parseInt(0 | e.sms_dev_unread_num, 10) + parseInt(0 | e.sms_sim_unread_num, 10) : parseInt(0 | e.sms_dev_unread_num, 10) : ci.smsUnreadCount = parseInt(0 | e.sms_unread_num, 10)), ""1"" == e.data_volume_limit_switch)
 if (ci.limitVolumeEnable = !0, ci.limitVolumeType = ""data"" == e.data_volume_limit_unit ? ""1"" : ""0"", ci.limitVolumePercent = e.data_volume_alert_percent, ""data"" == e.data_volume_limit_unit) {
 var i = e.data_volume_limit_size.split(""_"");
 ci.limitVolumeSize = i[0] * i[1] * 1024 * 1024, ci.limitVolumeSizeSource = i[0] * i[1]
 } else ci.limitVolumeSize = 60 * e.data_volume_limit_size * 60, ci.limitVolumeSizeSource = e.data_volume_limit_size;
 else ci.limitVolumeEnable = !1, ci.limitVolumeType = ""1"", ci.limitVolumePercent = ""100"", ci.limitVolumeSize = ""0"";
 ci.connectWifiProfile = e.EX_wifi_profile, ci.connectWifiSSID = e.EX_SSID1, ci.connectWifiStatus = e.sta_ip_status, ci.multi_ssid_enable = e.m_ssid_enable, ci.roamMode = e.roam_setting_option, ci.opms_wan_mode = e.opms_wan_mode, ci.opms_wan_auto_mode = e.opms_wan_auto_mode, ci.dhcp_wan_status = e.dhcp_wan_status, ci.new_version_state = ""1"" == e.new_version_state || ""version_has_new_critical_software"" == e.new_version_state || ""version_has_new_optional_software"" == e.new_version_state || ""upgrade_pack_redownload"" == e.current_upgrade_state, ci.current_upgrade_state = e.current_upgrade_state, ""downloading"" == ci.current_upgrade_state ? ci.current_upgrade_state = ""upgrading"" : ""verify_failed"" == ci.current_upgrade_state && (ci.current_upgrade_state = ""upgrade_pack_error""), ci.is_mandatory = ""1"" == e.is_mandatory || ""version_has_new_critical_software"" == e.new_version_state, ci.allowRoamingUpdate = e.upg_roam_switch, ci.wifi_dfs_status = e.wifi_dfs_status, ci.wifi_5g_enable = e.wifi_5g_enable, ci.dialMode = e.dial_mode, ci.ppp_dial_conn_fail_counter = e.ppp_dial_conn_fail_counter, ci.isCaStatus = ""ca_activated"" == e.wan_lte_ca || ""ca_deactivated"" == e.wan_lte_ca, ci.privacy_read_flag = e.privacy_read_flag, ci.is_night_mode = e.is_night_mode, ci.pppoe_status = e.pppoe_status, ci.static_wan_status = e.static_wan_status, ci.vpn_conn_status = void 0 === e.vpn_conn_status ? ""disconnected"" : e.vpn_conn_status, ci.wan_connect_status = e.wan_connect_status, ci.battery_charg_type = e.battery_charg_type, ci.external_charging_flag = e.external_charging_flag, ci.mode_main_state = e.mode_main_state, ci.battery_temp = e.battery_temp, ci.mdm_mcc = e.mdm_mcc, ci.mdm_mnc = e.mdm_mnc
 }


 function K() {
 ci.batteryStatus = ""0""
 }


 function z(e, n, r) {
 return """" != t.trim(e) && ""no_service"" != e.toLowerCase() && ""limited_service"" != e.toLowerCase() && ""modem_sim_undetected"" != n && ""modem_waitpin"" != n && ""modem_waitpuk"" != n && ""International"" == r
 }


 function X(e, t, n) {
 if ((""string"" != typeof e || """" === e || ""number"" != typeof t || isNaN(t)) && ""function"" == typeof n) return void n(!1);
 if (-1 === (0 === t ? 0 : 2 === t ? 2 : 7 == t ? 7 : 12 == t ? 12 : -1) && ""function"" == typeof n) return void n(!1);
 _({
 isTest: oi,
 goformId: ""SET_NETWORK"",
 NetworkNumber: e,
 Rat: t
 }, function(e) {
 if (e && ""success"" == e.result) var t, _ = 0,
 i = setInterval(function() {
 var e = r({
 cmd: ""m_netselect_result"",
 isTest: oi
 }, !1);
 e || n(!1), ""manual_success"" == e.m_netselect_result ? (t = ""1"", window.clearInterval(i), n(!0)) : ""manual_fail"" == e.m_netselect_result ? (t = ""0"", window.clearInterval(i), n(!1)) : _ < 120 ? _++ : (window.clearInterval(i), n(!1))
 }, 1e3);
 else n(!1)
 }, function(e) {
 n(!1)
 }, !0)
 }


 function j() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.cmd = ""current_network"", n
 }


 function t(e) {
 return e ? {
 strFullName: e.strFullName,
 strShortName: e.strShortName,
 strNumeric: e.strNumeric,
 nRat: """" == e.nRat ? """" : Number(e.nRat),
 strBearer: e.strBearer
 } : si
 }
 return s(arguments, {}, e, t, null, !1)
 }


 function q() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.notCallback = !0, n.goformId = ""PBM_CONTACT_ADD"", n.location = e.location, n.name = encodeMessage(e.name), n.mobilephone_num = e.mobile_phone_number, 1 == n.location ? (n.add_index_pc = e.index, n.homephone_num = e.home_phone_number, n.officephone_num = e.office_phone_number, n.email = encodeMessage(e.mail), n.groupchoose = e.group, n.groupchoose || (n.groupchoose = ""common"")) : n.edit_index = e.index, n
 }


 function t(e) {
 e && ""success"" == e.result ? L(""pbm_write_flag"", n) : r(e)
 }


 function n(e) {
 Z(e, r, n)
 }
 var r = arguments[1];
 return s(arguments, {}, e, t, null, !0)
 }


 function Z(e, t, n) {
 ""0"" == e.pbm_write_flag ? (O(""pbm_write_flag"", n), t({
 result: ""success""
 })) : ""6"" != e.pbm_write_flag && ""7"" != e.pbm_write_flag && ""8"" != e.pbm_write_flag && ""9"" != e.pbm_write_flag && ""10"" != e.pbm_write_flag && ""11"" != e.pbm_write_flag && ""14"" != e.pbm_write_flag || (O(""pbm_write_flag"", n), t({
 result: ""fail""
 }))
 }


 function Y() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.notCallback = !0, n.goformId = ""PBM_CONTACT_DEL"", n.del_option = ""delete_num"", n.delete_id = e.indexs.join("",""), n
 }


 function t(e) {
 e && ""success"" == e.result ? L(""pbm_write_flag"", n) : r(e)
 }


 function n(e) {
 Z(e, r, n)
 }
 var r = arguments[1];
 return s(arguments, {}, e, t, null, !0)
 }


 function Q() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.notCallback = !0, n.goformId = ""PBM_CONTACT_DEL"", n.del_option = ""delete_all"", n.del_all_location = e.location, n
 }


 function t(e) {
 e && ""success"" == e.result ? L(""pbm_write_flag"", n) : r(e)
 }


 function n(e) {
 Z(e, r, n)
 }
 var r = arguments[1];
 return s(arguments, {}, e, t, null, !0)
 }


 function J() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.notCallback = !0, n.goformId = ""PBM_CONTACT_DEL"", n.del_option = ""delete_all_by_group"", n.del_all_location = 3, n.del_group = e.group, n
 }


 function t(e) {
 e && ""success"" == e.result ? L(""pbm_write_flag"", n) : r(e)
 }


 function n(e) {
 Z(e, r, n)
 }
 var r = arguments[1];
 return s(arguments, {}, e, t, null, !0)
 }


 function $() {
 function e(e, t) {
 var n = {};
 return n.goformId = ""SET_CONNECTION_MODE"", n.isTest = oi, n.ConnectionMode = e.connectionMode, n.roam_setting_option = e.isAllowedRoaming, n
 }


 function t(e) {
 if (e) return e;
 callback(e)
 }
 return s(arguments, {}, e, t, null, !0)
 }


 function ee() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.cmd = ""ConnectionMode"", n
 }


 function t(e) {
 if (e) {
 var t = {};
 return t.connectionMode = e.connectionMode, t.isAllowedRoaming = e.autoConnectWhenRoaming, t
 }
 return si
 }
 return s(arguments, {}, e, t, null, !1)
 }


 function te(e, n) {
 function r(e, t) {
 var r = {};
 return r.isTest = oi, r.mem_store = n, r.cmd = 2 == n ? ""pbm_data_total"" : ""pbm_data_info"", r.page = e.page, r.data_per_page = e.data_per_page, r.orderBy = e.orderBy, r.isAsc = e.isAsc, r
 }


 function _(e) {
 if (e && e.pbm_data) {
 var n = [];
 return t.each(e.pbm_data, function(t) {
 n.push({
 pbm_id: e.pbm_data[t].pbm_id,
 pbm_location: e.pbm_data[t].pbm_location,
 pbm_number: e.pbm_data[t].pbm_number,
 pbm_anr: e.pbm_data[t].pbm_anr,
 pbm_anr1: e.pbm_data[t].pbm_anr1,
 pbm_group: e.pbm_data[t].pbm_group,
 pbm_name: decodeMessage(e.pbm_data[t].pbm_name),
 pbm_email: decodeMessage(e.pbm_data[t].pbm_email)
 })
 }), {
 pbm_data: n
 }
 }
 return si
 }
 return 0 == e[0].data_per_page ? {
 pbm_data: []
 } : s(e, {}, r, _, null, !1)
 }


 function ne() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.cmd = ""pbm_data_total"", n.mem_store = 3, n.pbm_group = e.group, n.page = e.page, n.data_per_page = e.data_per_page, n.orderBy = e.orderBy, n.isAsc = e.isAsc, n
 }


 function n(e) {
 if (e && e.pbm_data) {
 var n = [];
 return t.each(e.pbm_data, function(t) {
 n.push({
 pbm_id: e.pbm_data[t].pbm_id,
 pbm_location: e.pbm_data[t].pbm_location,
 pbm_number: e.pbm_data[t].pbm_number,
 pbm_anr: e.pbm_data[t].pbm_anr,
 pbm_anr1: e.pbm_data[t].pbm_anr1,
 pbm_group: e.pbm_data[t].pbm_group,
 pbm_name: decodeMessage(e.pbm_data[t].pbm_name),
 pbm_email: decodeMessage(e.pbm_data[t].pbm_email)
 })
 }), {
 pbm_data: n
 }
 }
 return si
 }
 return 0 == arguments[0].data_per_page ? {
 pbm_data: []
 } : s(arguments, {}, e, n, null, !1)
 }


 function re() {
 return te(arguments, 1)
 }


 function _e() {
 return te(arguments, 0)
 }


 function ie() {
 return te(arguments, 2)
 }


 function se() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.cmd = ""pbm_init_flag"", n
 }


 function t(e) {
 return e || si
 }
 return s(arguments, {}, e, t, null, !1)
 }


 function oe(e, t) {
 function n(e, n) {
 var r = {};
 return r.isTest = oi, r.cmd = ""pbm_capacity_info"", r.pbm_location = t ? ""pbm_sim"" : ""pbm_native"", r
 }


 function r(e) {
 return e || si
 }
 return s(e, {}, n, r, null, !1)
 }


 function ae() {
 var e = oe(arguments, !0);
 return {
 simPbmTotalCapacity: parseInt(e.pbm_sim_max_record_num),
 simPbmUsedCapacity: parseInt(e.pbm_sim_used_record_num),
 simType: e.pbm_sim_type,
 maxNameLen: parseInt(e.pbm_sim_max_name_len),
 maxNumberLen: parseInt(e.pbm_sim_max_number_len)
 }
 }


 function ue() {
 var e = oe(arguments, !1);
 return {
 pcPbmTotalCapacity: parseInt(e.pbm_dev_max_record_num),
 pcPbmUsedCapacity: parseInt(e.pbm_dev_used_record_num)
 }
 }


 function ce() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.cmd = ""modem_main_state,puknumber,pinnumber,opms_wan_mode,psw_fail_num_str,login_lock_time,SleepStatusForSingleChipCpe"", n.multi_data = 1, n
 }


 function t(e) {
 return e ? (e.psw_fail_num_str = """" == e.psw_fail_num_str ? n.MAX_LOGIN_COUNT : e.psw_fail_num_str, e.login_lock_time = """" == e.login_lock_time ? ""300"" : e.login_lock_time, e.curSleepStatus = ""1"" == e.SleepStatusForSingleChipCpe ? ""1"" : ""2"", e) : si
 }
 return s(arguments, {}, e, t, null, !1)
 }


 function de() {
 function e(e, t) {
 var r = hr({
 nv: ""LD""
 }).LD;
 return {
 isTest: oi,
 goformId: ""LOGIN"",
 password: ""2"" == n.WEB_ATTR_IF_SUPPORT_SHA256 ? paswordAlgorithmsCookie(paswordAlgorithmsCookie(e.password) + r) : ""1"" == n.WEB_ATTR_IF_SUPPORT_SHA256 ? paswordAlgorithmsCookie(Base64.encode(e.password)) : Base64.encode(e.password)
 }
 }


 function r(e) {
 if (!e || ""0"" != e.result && ""4"" != e.result) {
 if (e && ""5"" == e.result) return ci.isLoggedIn = !1, {
 result: ""5""
 };
 var n = {};
 switch (e.result) {
 case ""1"":
 n = {
 errorType: ""Login Fail""
 };
 break;
 case ""2"":
 n = {
 errorType: ""duplicateUser""
 };
 break;
 case ""3"":
 n = {
 errorType: ""badPassword""
 };
 break;
 default:
 n = {
 errorType: ""Login Fail""
 }
 }
 return ci.isLoggedIn = !1, t.extend(si, n)
 }
 return ci.isLoggedIn = !0, {
 result: !0
 }
 }
 return s(arguments, {}, e, r, {
 errorType: ""badPassword""
 }, !0)
 }


 function le() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.cmd = ""loginfo"", n.multi_data = 1, n
 }


 function r(e) {
 if (e && e.loginfo || """" == e.loginfo) {
 var n = {};
 switch (e.loginfo) {
 case ""ok"":
 ci.isLoggedIn = !0, n.status = ""loggedIn"";
 break;
 default:
 ci.isLoggedIn = !1, n.status = ""loggedOut""
 }
 return n
 }
 return ci.isLoggedIn = void 0, t.extend(si, {
 errorType: ""LoginStatusError""
 })
 }
 if (void 0 != ci.isLoggedIn) return s(arguments, {
 status: ci.isLoggedIn ? ""loggedIn"" : ""loggedOut""
 });
 var _ = {};
 return n.HAS_LOGIN || (_.status = ""loggedIn"", _.errorType = ""no_login"", ci.isLoggedIn = !0), s(arguments, _, e, r, null, !1)
 }


 function pe() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.goformId = ""ENTER_PIN"", n.PinNumber = e.PinNumber, n
 }


 function t(e) {
 return e && ""success"" === e.result ? {
 result: !0
 } : {
 result: !1
 }
 }
 return s(arguments, {}, e, t, {}, !0)
 }


 function me() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.goformId = ""ENTER_PUK"", n.PUKNumber = e.PUKNumber, n.PinNumber = e.PinNumber, n
 }


 function t(e) {
 return e && ""success"" === e.result ? {
 result: !0
 } : {
 result: !1
 }
 }
 return s(arguments, {}, e, t, {}, !0)
 }


 function fe() {
 function e(e, t) {
 return {
 isTest: oi,
 cmd: ""sms_data_total"",
 page: e.page,
 data_per_page: n.SMS_DATABASE_SORT_SUPPORT ? e.smsCount : 500,
 mem_store: e.nMessageStoreType,
 tags: e.tags,
 order_by: e.orderBy
 }
 }


 function t(e) {
 return e && e.messages && e.messages.length > 0 ? {
 messages: ge(e.messages)
 } : {
 messages: []
 }
 }
 return s(arguments, {}, e, t, {}, !1)
 }


 function ge(r, _) {
 for (var i = [], s = 0; s < r.length; s++)
 if (n.SHOW_UN_COMPLETE_CONCAT_SMS || void 0 === r[s].received_all_concat_sms || ""0"" != r[s].received_all_concat_sms) {
 var o = {};
 o.id = r[s].id, o.number = ve(r[s].number), o.content = _ ? r[s].content : ve(r[s].content), o.timeOri = transTime(""20"" + r[s].date), o.time = transTime(""20"" + r[s].date, n.DATE_FORMAT, n.TIME_FORMAT), o.isNew = ""1"" == r[s].tag, o.groupId = r[s].draft_group_id, o.tag = r[s].tag, o.receivedAll = ""1"" == r[s].received_all_concat_sms, i.push(o)
 } if (n.SMS_DATABASE_SORT_SUPPORT) return i;
 for (var a = [], u = [], s = i.length; s--;) {
 var c = i[s],
 d = t.inArray(c.id, a); - 1 == d ? (a.push(c.id), u.push(c)) : c.content.length > u[d].content.length && (u[d] = c)
 }
 return e.sortBy(u, function(e) {
 return 0 - e.id
 })
 }


 function ve(e) {
 return decodeMessage(escapeMessage(e))
 }


 function we() {
 function e(e, t) {
 return {
 isTest: oi,
 goformId: ""SEND_SMS"",
 notCallback: !0,
 Number: e.number,
 sms_time: getCurrentTimeString(),
 MessageBody: escapeMessage(encodeMessage(e.message)),
 ID: e.id,
 encode_type: getEncodeType(e.message).encodeType
 }
 }


 function n(e) {
 if (!e) return void _(t.extend(si, {
 errorType: ""sendFail"",
 errorText: ""send_fail_try_again""
 }));
 ""success"" == e.result ? setTimeout(function() {
 Pe({
 smsCmd: 4,
 errorType: ""sendFail"",
 errorText: ""send_fail_try_again""
 }, r, _)
 }, 1e3) : _(t.extend(si, {
 errorType: ""sendFail"",
 errorText: ""send_fail_try_again""
 }))
 }
 var r = arguments[1],
 _ = arguments[2] ? arguments[2] : r;
 return s(arguments, {}, e, n, null, !0)
 }


 function he() {
 function e(e, t) {
 return {
 isTest: oi,
 notCallback: !0,
 goformId: ""SAVE_SMS"",
 SMSMessage: escapeMessage(encodeMessage(e.message)),
 SMSNumber: e.numbers.join("";"") + "";"",
 Index: e.index,
 encode_type: getEncodeType(e.message).encodeType,
 sms_time: e.currentTimeString,
 draft_group_id: e.groupId
 }
 }


 function n(e) {
 if (!e) return void _(t.extend(si, {
 errorType: ""saveFail"",
 errorText: ""save_fail""
 }));
 ""success"" == e.result ? Pe({
 smsCmd: 5,
 errorType: ""saveFail"",
 errorText: ""save_fail""
 }, r, _) : _(t.extend(si, {
 errorType: ""saveFail"",
 errorText: ""save_fail""
 }))
 }
 var r = arguments[1],
 _ = arguments[2] ? arguments[2] : r;
 return s(arguments, {}, e, n, null, !0)
 }


 function Se() {
 function e(e, t) {
 return {
 isTest: oi,
 goformId: ""ALL_DELETE_SMS"",
 notCallback: !0,
 which_cgi: e.location
 }
 }


 function n(e) {
 if (!e) return void i(t.extend(si, {
 errorType: ""deleteFail"",
 errorText: ""delete_fail_try_again""
 }));
 ""success"" == e.result ? L(""sms_cmd_status_info"", r) : i(t.extend(si, {
 errorType: ""deleteFail"",
 errorText: ""delete_fail_try_again""
 }))
 }


 function r(e) {
 var n = e.sms_cmd_status_info;
 ""2"" == n ? (O(""sms_cmd_status_info"", r), i(t.extend(si, {
 errorType: ""deleteFail"",
 errorText: ""delete_fail_try_again""
 }))) : ""3"" == n && (O(""sms_cmd_status_info"", r), _({
 result: !0
 }))
 }
 var _ = arguments[1],
 i = arguments[2] ? arguments[2] : _;
 return s(arguments, {}, e, n, null, !0)
 }


 function Te() {
 function e(e, t) {
 var n = e.ids.join("";"") + "";"";
 return {
 isTest: oi,
 goformId: ""DELETE_SMS"",
 msg_id: n,
 notCallback: !0
 }
 }


 function n(e) {
 if (!e) return void _(t.extend(si, {
 errorType: ""deleteFail"",
 errorText: ""delete_fail_try_again""
 }));
 ""success"" == e.result ? Pe({
 smsCmd: 6,
 errorType: ""deleteFail"",
 errorText: ""delete_fail_try_again""
 }, r, _) : _(t.extend(si, {
 errorType: ""deleteFail"",
 errorText: ""delete_fail_try_again""
 }))
 }
 var r = arguments[1],
 _ = arguments[2] ? arguments[2] : r;
 return s(arguments, {}, e, n, null, !0)
 }


 function Pe(e, n, r) {
 _({
 cmd: ""sms_cmd_status_info"",
 sms_cmd: e.smsCmd,
 isTest: oi
 }, function(_) {
 if (_) {
 var i = _.sms_cmd_status_result;
 ""2"" == i ? r(t.extend(si, {
 errorType: e.errorType,
 errorText: e.errorText
 })) : ""3"" == i ? n({
 result: ""success""
 }) : window.setTimeout(function() {
 Pe(e, n, r)
 }, 1e3)
 } else r(t.extend(si, {
 errorType: e.errorType,
 errorText: e.errorText
 }))
 }, function(n) {
 r(t.extend(si, {
 errorType: e.errorType,
 errorText: e.errorText
 }))
 }, !1)
 }


 function Ie() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.cmd = ""sms_cmd_status_info"", n.sms_cmd = 1, n
 }


 function t(e) {
 return e ? (""3"" == e.sms_cmd_status_result && (n.smsIsReady = !0), e) : si
 }
 if (n.smsIsReady) {
 var r = arguments[1];
 return r ? r({
 sms_cmd: ""1"",
 sms_cmd_status_result: ""3""
 }) : {
 sms_cmd: ""1"",
 sms_cmd_status_result: ""3""
 }
 }
 return s(arguments, {}, e, t, null, !1)
 }


 function be() {
 function e(e, t) {
 var n = e.ids.join("";"");
 return e.ids.length > 0 && (n += "";""), {
 isTest: oi,
 goformId: ""SET_MSG_READ"",
 msg_id: n,
 tag: 0
 }
 }


 function t(e) {
 return ""success"" == e.result ? {
 result: !0
 } : {
 result: !1
 }
 }
 return s(arguments, {}, e, t, null, !0)
 }


 function Ae() {
 function e(e, t) {
 return {
 isTest: oi,
 cmd: ""sms_status_rpt_data"",
 page: e.page,
 data_per_page: e.smsCount
 }
 }


 function t(e) {
 return e ? {
 messages: ge(e.messages, !0)
 } : si
 }
 return s(arguments, {}, e, t, {}, !1)
 }


 function ye() {
 function e(e, n) {
 var r = t.extend({}, e);
 return r.isTest = oi, r.goformId = ""LOGOUT"", r
 }


 function n(e) {
 return e && ""success"" == e.result ? (ci.isLoggedIn = !1, {
 result: !0
 }) : t.extend(si, {
 errorType: ""loggedOutError""
 })
 }
 return s(arguments, {}, e, n, null, !0)
 }


 function Ee() {
 function e(e, t) {
 var r = {};
 return r.newPassword = ""2"" == n.WEB_ATTR_IF_SUPPORT_SHA256 ? paswordAlgorithmsCookie(e.newPassword) : (n.WEB_ATTR_IF_SUPPORT_SHA256, Base64.encode(e.newPassword)), r.oldPassword = ""2"" == n.WEB_ATTR_IF_SUPPORT_SHA256 ? paswordAlgorithmsCookie(e.oldPassword) : ""1"" == n.WEB_ATTR_IF_SUPPORT_SHA256 ? paswordAlgorithmsCookie(Base64.encode(e.oldPassword)) : Base64.encode(e.oldPassword), r.goformId = ""CHANGE_PASSWORD"", r.isTest = oi, r
 }


 function r(e) {
 return e && ""success"" === e.result ? {
 result: !0
 } : t.extend(si, {
 errorType: ""badPassword""
 })
 }
 return s(arguments, {}, e, r, null, !0)
 }


 function Re() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.cmd = ""pinnumber,pin_status,puknumber"", n.multi_data = 1, n
 }


 function t(e) {
 return e || si
 }
 return s(arguments, {}, e, t, null, !1)
 }


 function Ne() {
 function e(e, t) {
 var n = {};
 return n.goformId = ""ENABLE_PIN"", n.OldPinNumber = e.oldPin, n.isTest = oi, n
 }


 function t(e) {
 return e && ""success"" === e.result ? {
 result: !0
 } : {
 result: !1
 }
 }
 return s(arguments, {}, e, t, null, !0)
 }


 function Me() {
 function e(e, t) {
 var n = {};
 return n.goformId = ""DISABLE_PIN"", n.OldPinNumber = e.oldPin, n.isTest = oi, n
 }


 function t(e) {
 return e && ""success"" === e.result ? {
 result: !0
 } : {
 result: !1
 }
 }
 return s(arguments, {}, e, t, null, !0)
 }


 function De() {
 function e(e, t) {
 var n = {};
 return n.goformId = ""ENABLE_PIN"", n.OldPinNumber = e.oldPin, n.NewPinNumber = e.newPin, n.isTest = oi, n
 }


 function t(e) {
 return e && ""success"" === e.result ? {
 result: !0
 } : {
 result: !1
 }
 }
 return s(arguments, {}, e, t, null, !0)
 }


 function Ce() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.cmd = ""lan_ipaddr,lan_netmask,mac_address,dhcpEnabled,dhcpStart,dhcpEnd,dhcpLease_hour,mtu,tcp_mss"", n.multi_data = 1, n
 }


 function t(e) {
 if (e) {
 var t = {};
 return t.ipAddress = e.lan_ipaddr, t.subnetMask = e.lan_netmask, t.macAddress = e.mac_address, t.dhcpServer = e.dhcpEnabled, t.dhcpStart = e.dhcpStart, t.dhcpEnd = e.dhcpEnd, t.dhcpLease = parseInt(e.dhcpLease_hour, 10), t.mtuValue = e.mtu, t.mssValue = e.tcp_mss, t
 }
 return si
 }
 return s(arguments, {}, e, t, null, !1)
 }


 function ke() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.goformId = ""DHCP_SETTING"", n.lanIp = e.ipAddress, n.lanNetmask = e.subnetMask, n.lanDhcpType = ""1"" == e.dhcpServer ? ""SERVER"" : ""DISABLE"", ""SERVER"" == n.lanDhcpType && (n.dhcpStart = e.dhcpStart, n.dhcpEnd = e.dhcpEnd, n.dhcpLease = e.dhcpLease), n.dhcp_reboot_flag = 1, n.mac_ip_reset = e.mac_ip_reset, n
 }


 function t(e) {
 return e || si
 }
 return s(arguments, {}, e, t, null, !0)
 }


 function Fe() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.goformId = ""SET_DEVICE_MTU"", n.mtu = e.mtuValue, n.tcp_mss = e.mssValue, n
 }


 function t(e) {
 return e || si
 }
 return s(arguments, {}, e, t, null, !0)
 }


 function We() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.cmd = ""sms_parameter_info"", n
 }


 function t(e) {
 if (e) {
 var t = {};
 switch (t.centerNumber = e.sms_para_sca, t.memStroe = e.sms_para_mem_store, t.deliveryReport = e.sms_para_status_report, parseInt(e.sms_para_validity_period)) {
 case 143:
 t.validity = ""twelve_hours"";
 break;
 case 167:
 t.validity = ""one_day"";
 break;
 case 173:
 t.validity = ""one_week"";
 break;
 case 244:
 case 255:
 t.validity = ""largest"";
 break;
 default:
 t.validity = ""twelve_hours""
 }
 return t
 }
 return si
 }
 return s(arguments, {}, e, t, null, !1)
 }


 function xe() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.goformId = ""SET_MESSAGE_CENTER"", n.save_time = e.validity, n.MessageCenter = e.centerNumber, n.status_save = e.deliveryReport, n.save_location = ""native"", n.notCallback = !0, n
 }


 function n(e) {
 if (!e) return void _(t.extend(si, {
 errorType: ""smsSettingFail"",
 errorText: ""error_info""
 }));
 ""success"" == e.result ? Pe({
 smsCmd: 3,
 errorType: ""smsSettingFail"",
 errorText: ""error_info""
 }, r, _) : _(t.extend(si, {
 errorType: ""deleteFail"",
 errorText: ""delete_fail_try_again""
 }))
 }
 var r = arguments[1],
 _ = arguments[2] ? arguments[2] : r;
 return s(arguments, {}, e, n, null, !0)
 }


 function Le() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.goformId = ""RESTORE_FACTORY_SETTINGS"", n
 }


 function t(e) {
 return e || si
 }
 var r = {};
 return n.HAS_PARENTAL_CONTROL && 0 != n.currentUserInChildGroup && (r = {
 errorType: ""no_auth""
 }), s(arguments, r, e, t, null, !0)
 }


 function Oe(e) {
 var t = {};
 t.isTest = oi, t.cmd = ""restore_flag"", t.multi_data = 1, _(t, function(t) {
 t && ""1"" === t.restore_flag ? e() : setTimeout(function() {
 Oe(e)
 }, 5e3)
 }, function() {
 setTimeout(function() {
 Oe(e)
 }, 5e3)
 }, !1)
 }


 function Ue() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.cmd = ""wifi_wps_index,WscModeOption,AuthMode,wifi_onoff_state,EncrypType,wps_mode,WPS_SSID,m_ssid_enable,SSID1,m_SSID,m_EncrypType,m_AuthMode"", n.multi_data = 1, n
 }


 function t(e) {
 if (e) {
 var t = {};
 return t.wpsFlag = e.WscModeOption, t.authMode = e.AuthMode, t.wpsType = e.wps_mode, t.radioFlag = e.wifi_onoff_state, t.encrypType = e.EncrypType, t.wpsSSID = e.WPS_SSID, t.ssidEnable = e.m_ssid_enable, t.ssid = e.SSID1, t.multiSSID = e.m_SSID, t.m_encrypType = e.m_EncrypType, t.wifi_wps_index = e.wifi_wps_index, t.AuthMode = e.AuthMode, t.m_AuthMode = e.m_AuthMode, t
 }
 return si
 }
 return s(arguments, {}, e, t, null, !1)
 }


 function Be() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.goformId = ""WIFI_WPS_SET"", n.WPS_SSID = e.wpsSSID, n.wps_mode = e.wpsType, n.wifi_wps_index = e.wpsIndex, ""PIN"" == n.wps_mode && (n.wps_pin = e.wpsPin), n
 }


 function t(e) {
 return e || si
 }
 return s(arguments, {}, e, t, null, !0)
 }


 function Ve() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.cmd = ""sysIdleTimeToSleep"", n
 }


 function t(e) {
 if (e) {
 var t = {};
 return t.sleepMode = e.sysIdleTimeToSleep, t
 }
 return si
 }
 return s(arguments, {}, e, t, null, !1)
 }


 function He() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.goformId = ""SET_WIFI_SLEEP_INFO"", n.sysIdleTimeToSleep = e.sleepMode, n
 }


 function t(e) {
 return e || si
 }
 return s(arguments, {}, e, t, null, !0)
 }


 function Ge() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.cmd = ""RemoteManagement,WANPingFilter"", n.multi_data = 1, n
 }


 function t(e) {
 if (e) {
 var t = {};
 return t.remoteFlag = ""1"" == e.RemoteManagement ? ""1"" : ""0"", t.pingFlag = ""1"" == e.WANPingFilter ? ""1"" : ""0"", t
 }
 return si
 }
 return s(arguments, {}, e, t, null, !1)
 }


 function Ke() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.goformId = ""FW_SYS"", n.remoteManagementEnabled = e.remoteFlag, n.pingFrmWANFilterEnabled = e.pingFlag, n.RemoteManagement = e.remoteFlag, n.WANPingFilter = e.pingFlag, n
 }


 function t(e) {
 return e || si
 }
 return s(arguments, {}, e, t, null, !0)
 }


 function ze() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.cmd = ""lan_ipaddr,PortForwardEnable,PortForwardRules_0,PortForwardRules_1,PortForwardRules_2,PortForwardRules_3,PortForwardRules_4,PortForwardRules_5,PortForwardRules_6,PortForwardRules_7,PortForwardRules_8,PortForwardRules_9"", n.multi_data = 1, n
 }


 function t(e) {
 if (e) {
 var t = {};
 t.portForwardEnable = e.PortForwardEnable, t.gatewayIpAddress = e.lan_ipaddr;
 var r = [];
 return """" != e.PortForwardRules_0 && r.push([0, e.PortForwardRules_0]), """" != e.PortForwardRules_1 && r.push([1, e.PortForwardRules_1]), """" != e.PortForwardRules_2 && r.push([2, e.PortForwardRules_2]), """" != e.PortForwardRules_3 && r.push([3, e.PortForwardRules_3]), """" != e.PortForwardRules_4 && r.push([4, e.PortForwardRules_4]), """" != e.PortForwardRules_5 && r.push([5, e.PortForwardRules_5]), """" != e.PortForwardRules_6 && r.push([6, e.PortForwardRules_6]), """" != e.PortForwardRules_7 && r.push([7, e.PortForwardRules_7]), """" != e.PortForwardRules_8 && r.push([8, e.PortForwardRules_8]), """" != e.PortForwardRules_9 && r.push([9, e.PortForwardRules_9]), t.portForwardRules = n(r), t
 }
 return si
 }


 function n(e) {
 var t = [];
 if (e && e.length > 0)
 for (var n = 0; n < e.length; n++) {
 var r = {},
 _ = e[n][1].split("","");
 r.index = e[n][0], r.ipAddress = _[0], r.portRange = _[1] + "" - "" + _[2], r.protocol = transProtocol(_[3]), r.comment = _[4], t.push(r)
 }
 return t
 }
 return s(arguments, {}, e, t, null, !1)
 }


 function Xe() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.goformId = ""FW_FORWARD_ADD"", n.ipAddress = e.ipAddress, n.portStart = e.portStart, n.portEnd = e.portEnd, n.protocol = e.protocol, n.comment = e.comment, n
 }


 function t(e) {
 return e || si
 }
 return s(arguments, {}, e, t, null, !0)
 }


 function je() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.goformId = ""FW_FORWARD_DEL"", n.delete_id = e.indexs.join("";"") + "";"", n
 }


 function t(e) {
 return e || si
 }
 return s(arguments, {}, e, t, null, !0)
 }


 function qe() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.goformId = ""VIRTUAL_SERVER"", n.PortForwardEnable = e.portForwardEnable, n
 }


 function t(e) {
 return e || si
 }
 return s(arguments, {}, e, t, null, !0)
 }


 function Ze() {
 function e(e, t) {
 var r = {};
 r.isTest = oi;
 var _ = n.PASSWORD_ENCODE ? "",WPAPSK1_encode"" : "",WPAPSK1"";
 return r.cmd = ""pdp_type,ipv6_pdp_type,RadioOff,SSID1,HideSSID,AuthMode,WscModeOption,ppp_status,apn_index,ipv6_apn_index,ipv6_APN_index,m_profile_name,apn_mode"" + _ + "",APN_config0,APN_config1,APN_config2,APN_config3,APN_config4,APN_config5,APN_config6,APN_config7,APN_config8,APN_config9,APN_config10,APN_config11,APN_config12,APN_config13,APN_config14,APN_config15,APN_config16,APN_config17,APN_config18,APN_config19,ipv6_APN_config0,ipv6_APN_config1,ipv6_APN_config2,ipv6_APN_config3,ipv6_APN_config4,ipv6_APN_config5,ipv6_APN_config6,ipv6_APN_config7,ipv6_APN_config8,ipv6_APN_config9,ipv6_APN_config10,ipv6_APN_config11,ipv6_APN_config12,ipv6_APN_config13,ipv6_APN_config14,ipv6_APN_config15,ipv6_APN_config16,ipv6_APN_config17,ipv6_APN_config18,ipv6_APN_config19"", r.multi_data = 1, r
 }


 function t(e) {
 return e ? (n.PASSWORD_ENCODE && (e.WPAPSK1 = Base64.decode(e.WPAPSK1_encode)), e) : si
 }
 return s(arguments, {}, e, t, null, !1)
 }


 function Ye() {
 function e(e) {
 return {
 isTest: oi,
 goformId: ""QUICK_SETUP"",
 apn_mode: e.apnMode,
 Profile_Name: e.Profile_Name,
 APN_name: e.APN_name,
 ppp_auth_mode: e.ppp_auth_mode,
 ppp_username: e.ppp_username,
 ppp_passwd: e.ppp_passwd,
 SSID_name: e.SSID_name,
 SSID_Broadcast: e.SSID_Broadcast,
 Encryption_Mode_hid: e.Encryption_Mode_hid,
 security_shared_mode: e.security_shared_mode,
 WPA_PreShared_Key: n.PASSWORD_ENCODE ? Base64.encode(e.WPA_PreShared_Key) : e.WPA_PreShared_Key,
 wep_default_key: e.wep_default_key,
 WPA_ENCRYPTION_hid: e.WPA_ENCRYPTION_hid
 }
 }


 function r(e) {
 return e || t.extend(si, {
 errorType: ""SetSetUpError""
 })
 }
 Je(arguments, e, r)
 }


 function Qe() {
 function e(e) {
 return {
 isTest: oi,
 goformId: ""QUICK_SETUP_EX"",
 index: e.apn_index,
 pdp_type: e.pdp_type,
 apn_mode: e.apnMode,
 profile_name: e.profile_name,
 wan_apn: e.wan_apn,
 ppp_auth_mode: e.ppp_auth_mode,
 ppp_username: e.ppp_username,
 ppp_passwd: e.ppp_passwd,
 ipv6_wan_apn: e.ipv6_wan_apn,
 ipv6_ppp_auth_mode: e.ipv6_ppp_auth_mode,
 ipv6_ppp_username: e.ipv6_ppp_username,
 ipv6_ppp_passwd: e.ipv6_ppp_passwd,
 SSID_name: e.SSID_name,
 SSID_Broadcast: e.SSID_Broadcast,
 Encryption_Mode_hid: e.Encryption_Mode_hid,
 security_shared_mode: e.security_shared_mode,
 WPA_PreShared_Key: n.PASSWORD_ENCODE ? Base64.encode(e.WPA_PreShared_Key) : e.WPA_PreShared_Key,
 wep_default_key: e.wep_default_key,
 WPA_ENCRYPTION_hid: e.WPA_ENCRYPTION_hid
 }
 }


 function r(e) {
 return e || t.extend(si, {
 errorType: ""SetSetUpError""
 })
 }
 Je(arguments, e, r)
 }


 function Je(e, t, n) {
 var r = !1,
 i = !1,
 s = t(e[0]),
 o = e[1],
 a = function(e) {
 r = !0, !i && o && o(n(e)), i = !0
 },
 u = e[2];
 _(s, a, function() {
 r = !0, u && u()
 }, !0), addTimeout(function() {
 if (0 == r) var e = addInterval(function() {
 0 == r && h({}, function(t) {
 window.clearInterval(e), a({
 result: ""success""
 })
 })
 }, 1e3)
 }, 5e3)
 }


 function $e() {
 function e(e, t) {
 return {
 isTest: oi,
 cmd: ""sdcard_mode_option,sd_card_state,HTTP_SHARE_STATUS,HTTP_SHARE_CARD_USER,HTTP_SHARE_WR_AUTH,HTTP_SHARE_FILE"",
 multi_data: 1
 }
 }


 function t(e) {
 if (e) {
 var t;
 t = ""mmc2"" == e.HTTP_SHARE_FILE || ""/mmc2"" == e.HTTP_SHARE_FILE || ""/mmc2/"" == e.HTTP_SHARE_FILE ? ""1"" : ""0"";
 return {
 sd_mode: ""1"" == e.sdcard_mode_option ? ""0"" : ""1"",
 sd_status: e.sd_card_state,
 share_status: ""Enabled"" == e.HTTP_SHARE_STATUS ? ""1"" : ""0"",
 share_user: e.HTTP_SHARE_CARD_USER,
 share_auth: ""readWrite"" == e.HTTP_SHARE_WR_AUTH ? ""1"" : ""0"",
 file_to_share: t,
 share_file: e.HTTP_SHARE_FILE
 }
 }
 return si
 }
 return s(arguments, {}, e, t, null, !1)
 }


 function et() {
 function e(e, t) {
 return {
 isTest: oi,
 goformId: ""HTTPSHARE_MODE_SET"",
 mode_set: ""0"" == e.mode ? ""http_share_mode"" : ""usb_mode""
 }
 }


 function t(e) {
 return e && ""success"" == e.result ? {
 result: !0
 } : {
 result: !1
 }
 }
 return s(arguments, {}, e, t, null, !0)
 }


 function tt() {
 function e(e, t) {
 return {
 isTest: oi,
 goformId: ""GOFORM_HTTPSHARE_CHECK_FILE"",
 path_SD_CARD: e.path
 }
 }


 function t(e) {
 return e ? ""no_sdcard"" == e.result ? {
 status: ""no_sdcard""
 } : ""noexist"" == e.result ? {
 status: ""noexist""
 } : {
 status: ""exist""
 } : si
 }
 return s(arguments, {}, e, t, null, !0)
 }


 function nt() {
 function e(e, t) {
 return {
 isTest: oi,
 goformId: ""HTTPSHARE_ENTERFOLD"",
 path_SD_CARD: e.path,
 indexPage: e.index
 }
 }


 function n(e) {
 return e ? ""failure"" == e.result ? t.extend(si, {
 errorType: ""get_file_list_failure""
 }) : ""no_sdcard"" == e.result ? t.extend(si, {
 errorType: ""no_sdcard""
 }) : r(e.result) : si
 }


 function r(e) {
 var t = {};
 t.totalRecord = e.totalRecord;
 for (var n = [], r = e.fileInfo, _ = 0; r && _ < r.length; _++)
 if ("""" != r[_].fileName) {
 var i = {};
 i.fileName = r[_].fileName, i.attribute = r[_].attribute, i.size = r[_].size, i.lastUpdateTime = r[_].lastUpdateTime, n.push(i)
 } return t.details = n, t
 }
 return s(arguments, {}, e, n, null, !0)
 }


 function rt() {
 function e(e, t) {
 var n = new Date,
 r = n.getTime(),
 _ = 60 * n.getTimezoneOffset();
 return {
 isTest: oi,
 goformId: ""HTTPSHARE_FILE_RENAME"",
 path_SD_CARD: e.path,
 OLD_NAME_SD_CARD: e.oldPath,
 NEW_NAME_SD_CARD: e.newPath,
 path_SD_CARD_time: transUnixTime(r),
 path_SD_CARD_time_unix: Math.round((r - 1e3 * _) / 1e3)
 }
 }


 function n(e) {
 return e ? ""success"" == e.result ? {
 result: !0
 } : ""no_sdcard"" == e.result ? t.extend(si, {
 errorType: ""no_sdcard""
 }) : {
 result: !1
 } : si
 }
 return s(arguments, {}, e, n, null, !0)
 }


 function _t() {
 function e(e, t) {
 return {
 isTest: oi,
 cmd: ""HTTPSHARE_GETCARD_VALUE""
 }
 }


 function n(e) {
 return !e || e.result && ""no_sdcard"" == e.result ? t.extend(si, {
 errorType: ""no_sdcard""
 }) : {
 totalMemorySize: """" == e.sd_card_total_size ? 0 : 32 * e.sd_card_total_size * 1024,
 availableMemorySize: """" == e.sd_card_avi_space ? 0 : 32 * e.sd_card_avi_space * 1024
 }
 }
 return s(arguments, {}, e, n, null, !1)
 }


 function it() {
 function e(e, t) {
 var n = (new Date).getTime();
 return {
 isTest: oi,
 goformId: ""HTTPSHARE_DEL"",
 path_SD_CARD: e.path,
 name_SD_CARD: e.names,
 path_SD_CARD_time: transUnixTime(n),
 path_SD_CARD_time_unix: Math.round(n / 1e3)
 }
 }


 function n(e) {
 return e.result && ""failure"" == e.result ? t.extend(si, {
 errorType: ""delete_folder_failure""
 }) : e.result && ""no_sdcard"" == e.result ? t.extend(si, {
 errorType: ""no_sdcard""
 }) : e.result && ""success"" == e.result ? {
 result: !0
 } : si
 }
 return s(arguments, {}, e, n, null, !0)
 }


 function st() {
 function e(e, t) {
 var n = new Date,
 r = n.getTime(),
 _ = 60 * n.getTimezoneOffset();
 return {
 isTest: oi,
 goformId: ""HTTPSHARE_NEW"",
 path_SD_CARD: e.path,
 path_SD_CARD_time: transUnixTime(r),
 path_SD_CARD_time_unix: Math.round((r - 1e3 * _) / 1e3)
 }
 }


 function n(e) {
 return e.result && ""failure"" == e.result ? t.extend(si, {
 errorType: ""create_folder_failure""
 }) : e.result && ""no_sdcard"" == e.result ? t.extend(si, {
 errorType: ""no_sdcard""
 }) : e.result && ""success"" == e.result ? {
 result: !0
 } : si
 }
 return s(arguments, {}, e, n, null, !0)
 }


 function ot() {
 function e(e, t) {
 return {
 isTest: oi,
 cmd: ""CheckUploadFileStatus""
 }
 }


 function t(e) {
 return e ? ""5"" == e.result ? {
 result: !1
 } : ""6"" == e.result ? {
 result: !0
 } : {
 result: !1
 } : si
 }
 return s(arguments, {}, e, t, null, !1)
 }


 function at() {
 function e(e, t) {
 return {
 isTest: oi,
 goformId: ""HTTPSHARE_AUTH_SET"",
 HTTP_SHARE_STATUS: ""1"" == e.share_status ? ""Enabled"" : ""Disabled"",
 HTTP_SHARE_WR_AUTH: ""1"" == e.share_auth ? ""readWrite"" : ""readOnly"",
 HTTP_SHARE_FILE: e.share_file
 }
 }


 function n(e) {
 return e ? ""no_sdcard"" == e.result ? t.extend(si, {
 errorType: ""no_sdcard""
 }) : {
 result: !0
 } : si
 }
 return s(arguments, {}, e, n, null, !0)
 }


 function ut() {
 function t(e, t) {
 var r = {};
 return r.isTest = oi, r.cmd = ""lan_ipaddr,IPPortFilterEnable,DefaultFirewallPolicy,IPPortFilterRules_0,IPPortFilterRules_1,IPPortFilterRules_2,IPPortFilterRules_3,IPPortFilterRules_4,IPPortFilterRules_5,IPPortFilterRules_6,IPPortFilterRules_7,IPPortFilterRules_8,IPPortFilterRules_9"", n.USE_IPV6_INTERFACE && (r.cmd += "",IPPortFilterRulesv6_0,IPPortFilterRulesv6_1,IPPortFilterRulesv6_2,IPPortFilterRulesv6_3,IPPortFilterRulesv6_4,IPPortFilterRulesv6_5,IPPortFilterRulesv6_6,IPPortFilterRulesv6_7,IPPortFilterRulesv6_8,IPPortFilterRulesv6_9""), r.multi_data = 1, r
 }


 function r(t) {
 if (t) {
 var r = {};
 r.portFilterEnable = t.IPPortFilterEnable, r.defaultPolicy = t.DefaultFirewallPolicy, r.gatewayIpAddress = t.lan_ipaddr;
 var i = [];
 if ("""" != t.IPPortFilterRules_0 && i.push([0, t.IPPortFilterRules_0]), """" != t.IPPortFilterRules_1 && i.push([1, t.IPPortFilterRules_1]), """" != t.IPPortFilterRules_2 && i.push([2, t.IPPortFilterRules_2]), """" != t.IPPortFilterRules_3 && i.push([3, t.IPPortFilterRules_3]), """" != t.IPPortFilterRules_4 && i.push([4, t.IPPortFilterRules_4]), """" != t.IPPortFilterRules_5 && i.push([5, t.IPPortFilterRules_5]), """" != t.IPPortFilterRules_6 && i.push([6, t.IPPortFilterRules_6]), """" != t.IPPortFilterRules_7 && i.push([7, t.IPPortFilterRules_7]), """" != t.IPPortFilterRules_8 && i.push([8, t.IPPortFilterRules_8]), """" != t.IPPortFilterRules_9 && i.push([9, t.IPPortFilterRules_9]), r.portFilterRules = _(i, ""IPv4""), n.USE_IPV6_INTERFACE) {
 var s = [];
 """" != t.IPPortFilterRulesv6_0 && s.push([10, t.IPPortFilterRulesv6_0]), """" != t.IPPortFilterRulesv6_1 && s.push([11, t.IPPortFilterRulesv6_1]), """" != t.IPPortFilterRulesv6_2 && s.push([12, t.IPPortFilterRulesv6_2]), """" != t.IPPortFilterRulesv6_3 && s.push([13, t.IPPortFilterRulesv6_3]), """" != t.IPPortFilterRulesv6_4 && s.push([14, t.IPPortFilterRulesv6_4]), """" != t.IPPortFilterRulesv6_5 && s.push([15, t.IPPortFilterRulesv6_5]), """" != t.IPPortFilterRulesv6_6 && s.push([16, t.IPPortFilterRulesv6_6]), """" != t.IPPortFilterRulesv6_7 && s.push([17, t.IPPortFilterRulesv6_7]), """" != t.IPPortFilterRulesv6_8 && s.push([18, t.IPPortFilterRulesv6_8]), """" != t.IPPortFilterRulesv6_9 && s.push([19, t.IPPortFilterRulesv6_9]), r.portFilterRules = e.union(r.portFilterRules, _(s, ""IPv6""))
 }
 return r
 }
 return si
 }


 function _(e, t) {
 var n = [];
 if (e && e.length > 0)
 for (var r = 0; r < e.length; r++) {
 var _ = {},
 i = e[r][1].split("","");
 _.index = e[r][0], _.macAddress = i[11], _.destIpAddress = ""any/0"" == i[4] ? """" : i[4], _.sourceIpAddress = ""any/0"" == i[0] ? """" : i[0], _.destPortRange = ""0"" == i[6] ? """" : i[6] + "" - "" + i[7], _.sourcePortRange = ""0"" == i[2] ? """" : i[2] + "" - "" + i[3], _.action = 1 == i[9] ? ""filter_accept"" : ""filter_drop"", _.protocol = transProtocol(i[8]), _.comment = i[10], _.ipType = t, n.push(_)
 }
 return n
 }
 return s(arguments, {}, t, r, null, !1)
 }


 function ct() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.goformId = ""BASIC_SETTING"", n.portFilterEnabled = e.portFilterEnable, n.defaultFirewallPolicy = e.defaultPolicy, n
 }


 function t(e) {
 return e || si
 }
 return s(arguments, {}, e, t, null, !0)
 }


 function dt() {
 function e(e, t) {
 var r = {};
 return r.isTest = oi, n.USE_IPV6_INTERFACE ? (r.goformId = ""ADD_IP_PORT_FILETER_V4V6"", r.ip_version = e.ipType) : r.goformId = ""ADD_IP_PORT_FILETER"", r.mac_address = e.macAddress, r.dip_address = e.destIpAddress, r.sip_address = e.sourceIpAddress, r.dFromPort = e.destPortStart, r.dToPort = e.destPortEnd, r.sFromPort = e.sourcePortStart, r.sToPort = e.sourcePortEnd, r.action = e.action, r.protocol = e.protocol, r.comment = e.comment, r
 }


 function t(e) {
 return e || si
 }
 return s(arguments, {}, e, t, null, !0)
 }


 function lt() {
 function t(t, r) {
 var _ = {};
 _.isTest = oi;
 var i = e.filter(t.indexs, function(e) {
 return 1 == e.length
 });
 if (n.USE_IPV6_INTERFACE) {
 _.goformId = ""DEL_IP_PORT_FILETER_V4V6"";
 var s = [];
 e.each(t.indexs, function(e) {
 2 == e.length && s.push(e.substring(1))
 }), _.delete_id_v6 = s.length > 0 ? s.join("";"") + "";"" : """"
 } else _.goformId = ""DEL_IP_PORT_FILETER"";
 return _.delete_id = i.length > 0 ? i.join("";"") + "";"" : """", _
 }


 function r(e) {
 return e || si
 }
 return s(arguments, {}, t, r, null, !0)
 }


 function pt() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.cmd = ""WirelessMode,CountryCode,Channel,HT_MCS,wifi_band,wifi_11n_cap,MAX_Access_num,m_MAX_Access_num,wifi_attr_max_station_number,m_ssid_enable,wan_active_band,m_band_enable,m_WirelessMode,m_CountryCode,m_Channel,m_wifi_band,m_wifi_11n_cap"", n.multi_data = 1, n
 }


 function r(e) {
 if (e) {
 return {
 multi_ssid_enable: e.m_ssid_enable,
 wan_active_band: e.wan_active_band,
 mul_band_enable: e.m_band_enable,
 mode: e.WirelessMode,
 countryCode: e.CountryCode,
 channel: e.Channel,
 rate: e.HT_MCS,
 wifiBand: ""a"" == e.wifi_band ? ""a"" : ""b"",
 bandwidth: e.wifi_11n_cap,
 MAX_Station_num: t.isNumeric(e.wifi_attr_max_station_number) ? e.wifi_attr_max_station_number : n.MAX_STATION_NUMBER,
 MAX_Access_num: e.MAX_Access_num,
 m_MAX_Access_num: e.m_MAX_Access_num,
 guestMode: e.m_WirelessMode,
 guestCountryCode: """" == e.m_CountryCode ? ""CN"" : e.m_CountryCode,
 guestChannel: e.m_Channel,
 guestWifiBand: ""a"" == e.m_wifi_band ? ""a"" : ""b"",
 guestBandwidth: e.m_wifi_11n_cap
 }
 }
 return si
 }
 return s(arguments, {}, e, r, null, !1)
 }


 function mt() {
 function e(e) {
 var t = {
 goformId: ""WIFI_ADVANCE_SET"",
 isTest: oi,
 wifiMode: e.mode,
 countryCode: e.countryCode,
 m_WirelessMode: e.m_WirelessMode,
 m_CountryCode: e.m_CountryCode
 };
 return n.WIFI_BAND_SUPPORT && (t.wifi_band = e.wifiBand, t.m_wifi_band = e.m_wifi_band), t.selectedChannel = e.channel, t.m_Channel = e.m_Channel, n.WIFI_BAND_SUPPORT && ""a"" == e.wifiBand || (t.abg_rate = e.rate), n.WIFI_BANDWIDTH_SUPPORT && (t.wifi_11n_cap = e.bandwidth, t.m_wifi_11n_cap = e.m_wifi_11n_cap), t
 }


 function t(e) {
 return e || si
 }
 Je(arguments, e, t)
 }


 function ft() {
 function e(e) {
 var t = {
 goformId: ""SET_WIFI_INFO"",
 isTest: oi,
 wifiMode: e.mode,
 countryCode: e.countryCode,
 MAX_Access_num: e.station,
 m_MAX_Access_num: e.m_station
 };
 return n.WIFI_BAND_SUPPORT && (t.wifi_band = e.wifiBand), t.selectedChannel = e.channel, n.WIFI_BAND_SUPPORT && ""a"" == e.wifiBand || (t.abg_rate = e.rate), n.WIFI_BANDWIDTH_SUPPORT && (t.wifi_11n_cap = e.bandwidth), t
 }


 function t(e) {
 return e || si
 }
 Je(arguments, e, t)
 }


 function gt() {
 return getDeviceInfoTrue(), fi
 }


 function gt() {
 function e(e, t) {
 return {
 isTest: oi,
 cmd: ""wifi_onoff_state,guest_switch,wifi_chip1_ssid2_max_access_num,m_SSID2,wifi_chip2_ssid2_max_access_num,wifi_chip1_ssid1_wifi_coverage,apn_interface_version,m_ssid_enable,imei,network_type,rssi,rscp,lte_rsrp,imsi,sim_imsi,cr_version,wa_version,hardware_version,web_version,wa_inner_version,wifi_chip1_ssid1_max_access_num,wifi_chip1_ssid1_ssid,wifi_chip1_ssid1_auth_mode,wifi_chip1_ssid1_password_encode,wifi_chip2_ssid1_ssid,wifi_chip2_ssid1_auth_mode,m_HideSSID,wifi_chip2_ssid1_password_encode,wifi_chip2_ssid1_max_access_num,lan_ipaddr,lan_ipaddr,mac_address,msisdn,LocalDomain,wan_ipaddr,static_wan_ipaddr,ipv6_wan_ipaddr,ipv6_pdp_type,ipv6_pdp_type_ui,pdp_type,pdp_type_ui,opms_wan_mode,opms_wan_auto_mode,ppp_status,Z5g_snr,Z5g_rsrp,wan_lte_ca,lte_ca_pcell_band,lte_ca_pcell_bandwidth,lte_ca_scell_band,lte_ca_scell_bandwidth,lte_ca_pcell_arfcn,lte_ca_scell_arfcn,lte_multi_ca_scell_info,wan_active_band,wifi_onoff_state,guest_switch,wifi_chip1_ssid2_max_access_num,wifi_chip2_ssid2_max_access_num,wifi_chip1_ssid1_wifi_coverage,wifi_chip1_ssid1_max_access_num,wifi_chip1_ssid1_ssid,wifi_chip1_ssid1_auth_mode,wifi_chip1_ssid1_password_encode,wifi_chip2_ssid1_ssid,wifi_chip2_ssid1_auth_mode,wifi_chip2_ssid1_password_encode,wifi_chip2_ssid1_max_access_num,wifi_chip1_ssid2_ssid,wifi_chip2_ssid2_ssid,wifi_chip1_ssid1_switch_onoff,wifi_chip2_ssid1_switch_onoff,wifi_chip1_ssid2_switch_onoff,wifi_chip2_ssid2_switch_onoff,Z5g_SINR,station_ip_addr"",
 multi_data: 1
 }
 }


 function t(e) {
 return e ? {
 wifi_enable: e.wifi_onoff_state,
 multi_ssid_enable: e.guest_switch,
 ssid: e.wifi_chip1_ssid1_ssid,
 ssidGuest: e.wifi_chip1_ssid2_ssid,
 authMode: e.wifi_chip1_ssid1_auth_mode,
 passPhrase: Base64.decode(e.wifi_chip1_ssid1_password_encode),
 m_authMode: e.wifi_chip2_ssid1_auth_mode,
 m_passPhrase: Base64.decode(e.wifi_chip2_ssid1_password_encode),
 chip1_ssid1_enable: e.wifi_chip1_ssid1_switch_onoff,
 chip2_ssid1_enable: e.wifi_chip2_ssid1_switch_onoff,
 chip1_ssid2_enable: e.wifi_chip1_ssid2_switch_onoff,
 chip2_ssid2_enable: e.wifi_chip2_ssid2_switch_onoff,
 m_ssid: e.wifi_chip2_ssid1_ssid,
 m_ssid_guest: e.wifi_chip2_ssid2_ssid,
 m_max_access_num: e.wifi_chip2_ssid1_max_access_num,
 m_max_access_num_guest: e.wifi_chip2_ssid2_max_access_num,
 ipAddress: e.lan_ipaddr,
 wanIpAddress: e.wan_ipaddr,
 staticWanIpAddress: e.static_wan_ipaddr,
 ipv6WanIpAddress: e.ipv6_wan_ipaddr,
 ipv6PdpType: e.ipv6_pdp_type,
 macAddress: e.mac_address,
 simSerialNumber: e.msisdn,
 lanDomain: e.LocalDomain,
 imei: e.imei,
 signal: convertSignal(e),
 imsi: e.imsi || e.sim_imsi,
 sw_version: e.wa_inner_version || e.cr_version,
 fw_version: e.wa_version,
 hw_version: e.hardware_version,
 max_access_num: e.wifi_chip1_ssid1_max_access_num,
 max_access_num_guest: e.wifi_chip1_ssid2_max_access_num,
 wifiRange: e.wifi_chip1_ssid1_wifi_coverage,
 pdpType: e.apn_interface_version >= 2 ? e.pdp_type_ui : e.pdp_type,
 opms_wan_mode: e.opms_wan_mode,
 opms_wan_auto_mode: e.opms_wan_auto_mode,
 connectStatus: e.ppp_status,
 Z5g_SINR: e.Z5g_SINR,
 Z5g_rsrp: e.Z5g_rsrp,
 network_type: e.network_type,
 wan_lte_ca: e.wan_lte_ca,
 lte_ca_pcell_band: e.lte_ca_pcell_band,
 lte_ca_pcell_bandwidth: e.lte_ca_pcell_bandwidth,
 lte_ca_scell_band: e.lte_ca_scell_band,
 lte_ca_scell_bandwidth: e.lte_ca_scell_bandwidth,
 lte_ca_pcell_arfcn: e.lte_ca_pcell_arfcn,
 lte_ca_scell_arfcn: e.lte_ca_scell_arfcn,
 lte_multi_ca_scell_info: e.lte_multi_ca_scell_info,
 wan_active_band: e.wan_active_band,
 station_ip_addr: e.station_ip_addr
 } : si
 }
 return s(arguments, {}, e, t, null, !1)
 }


 function vt() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.cmd = ""wifi_coverage"", n
 }


 function t(e) {
 if (e) {
 var t = {};
 return t.wifiRangeMode = e.wifi_coverage, t
 }
 return si
 }
 return s(arguments, {}, e, t, null, !1)
 }


 function wt() {
 function e(e, t) {
 var n = {};
 return n.goformId = ""SET_WIFI_COVERAGE"", n.isTest = oi, n.wifi_coverage = e.wifiRangeMode, n
 }


 function t(e) {
 return e || si
 }
 return s(arguments, {}, e, t, null, !0)
 }


 function ht() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.cmd = ""queryWiFiCoverage"", n
 }


 function t(e) {
 if (e) {
 var t = {};
 return t.wifiRangeMode = e.WiFiCoverage, t
 }
 return si
 }
 return s(arguments, {}, e, t, null, !1)
 }


 function St() {
 function e(e, t) {
 var n = {};
 return n.goformId = ""setWiFiCoverage"", n.isTest = oi, n.WiFiCoverage = e.WiFiCoverage, n
 }


 function t(e) {
 return e || si
 }
 return s(arguments, {}, e, t, null, !0)
 }


 function Tt() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.cmd = ""auto_power_save"", n
 }


 function t(e) {
 if (e) {
 var t = {};
 return t.autoPowerSaveMode = e.auto_power_save, t
 }
 return si
 }
 return s(arguments, {}, e, t, null, !1)
 }


 function Pt() {
 function e(e, t) {
 var n = {};
 return n.goformId = ""SET_AUTO_POWER_SAVE"", n.isTest = oi, n.auto_power_save = e.autoPowerSaveMode, n
 }


 function t(e) {
 return e || si
 }
 return s(arguments, {}, e, t, null, !0)
 }


 function It() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.cmd = ""upnpEnabled"", n.multi_data = 1, n
 }


 function t(e) {
 if (e) {
 var t = {};
 return t.upnpSetting = ""1"" == e.upnpEnabled ? ""1"" : ""0"", t
 }
 return si
 }
 return s(arguments, {}, e, t, null, !1)
 }


 function bt() {
 function e(e, t) {
 var n = {};
 return n.goformId = ""UPNP_SETTING"", n.isTest = oi, n.upnp_setting_option = e.upnpSetting, n
 }


 function t(e) {
 return e || si
 }
 return s(arguments, {}, e, t, null, !0)
 }


 function At() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.cmd = ""DMZEnable,DMZIPAddress,lan_ipaddr,lan_netmask"", n.multi_data = 1, n
 }


 function t(e) {
 if (e) {
 var t = {};
 return t.dmzSetting = ""1"" == e.DMZEnable ? ""1"" : ""0"", t.ipAddress = e.DMZIPAddress, t.gatewayIpAddress = e.lan_ipaddr, t.gatewaySubnetMask = e.lan_netmask, t
 }
 return si
 }
 return s(arguments, {}, e, t, null, !1)
 }


 function yt() {
 function e(e, t) {
 var n = {};
 return n.goformId = ""DMZ_SETTING"", n.isTest = oi, n.DMZEnabled = e.dmzSetting, ""1"" == n.DMZEnabled && (n.DMZIPAddress = e.ipAddress), n
 }


 function t(e) {
 return e || si
 }
 return s(arguments, {}, e, t, null, !0)
 }


 function Et() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.cmd = ""lan_ipaddr,PortMapEnable,PortMapRules_0,PortMapRules_1,PortMapRules_2,PortMapRules_3,PortMapRules_4,PortMapRules_5,PortMapRules_6,PortMapRules_7,PortMapRules_8,PortMapRules_9"", n.multi_data = 1, n
 }


 function t(e) {
 if (e) {
 var t = {};
 t.portMapEnable = e.PortMapEnable, t.gatewayIpAddress = e.lan_ipaddr;
 var r = [];
 return """" != e.PortMapRules_0 && r.push([0, e.PortMapRules_0]), """" != e.PortMapRules_1 && r.push([1, e.PortMapRules_1]), """" != e.PortMapRules_2 && r.push([2, e.PortMapRules_2]), """" != e.PortMapRules_3 && r.push([3, e.PortMapRules_3]), """" != e.PortMapRules_4 && r.push([4, e.PortMapRules_4]), """" != e.PortMapRules_5 && r.push([5, e.PortMapRules_5]), """" != e.PortMapRules_6 && r.push([6, e.PortMapRules_6]), """" != e.PortMapRules_7 && r.push([7, e.PortMapRules_7]), """" != e.PortMapRules_8 && r.push([8, e.PortMapRules_8]), """" != e.PortMapRules_9 && r.push([9, e.PortMapRules_9]), t.portMapRules = n(r), t
 }
 return si
 }


 function n(e) {
 var t = [];
 if (e && e.length > 0)
 for (var n = 0; n < e.length; n++) {
 var r = {},
 _ = e[n][1].split("","");
 r.index = e[n][0], r.sourcePort = _[1], r.destIpAddress = _[0], r.destPort = _[2], r.protocol = transProtocol(_[3]), r.comment = _[4], t.push(r)
 }
 return t
 }
 return s(arguments, {}, e, t, null, !1)
 }


 function Rt() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.goformId = ""ADD_PORT_MAP"", n.portMapEnabled = e.portMapEnable, n.fromPort = e.sourcePort, n.ip_address = e.destIpAddress, n.toPort = e.destPort, n.protocol = e.protocol, n.comment = e.comment, n
 }


 function t(e) {
 return e || si
 }
 return s(arguments, {}, e, t, null, !0)
 }


 function Nt() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.goformId = ""ADD_PORT_MAP"", n.portMapEnabled = e.portMapEnable, n
 }


 function t(e) {
 return e || si
 }
 return s(arguments, {}, e, t, null, !0)
 }


 function Mt() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.goformId = ""DEL_PORT_MAP"", n.delete_id = e.indexs.join("";"") + "";"", n
 }


 function t(e) {
 return e || si
 }
 return s(arguments, {}, e, t, null, !0)
 }


 function Dt() {
 function e(e, t) {
 return {
 isTest: oi,
 cmd: ""data_volume_limit_switch,data_volume_limit_unit,data_volume_limit_size,data_volume_alert_percent,monthly_tx_bytes,monthly_rx_bytes,monthly_time,wan_auto_clear_flow_data_switch,traffic_clear_date"",
 multi_data: 1
 }
 }


 function t(e) {
 if (e) {
 var t = ""data"" == e.data_volume_limit_unit;
 return {
 dataLimitChecked: e.data_volume_limit_switch,
 dataLimitTypeChecked: t ? ""1"" : ""0"",
 limitDataMonth: t ? e.data_volume_limit_size : ""0"",
 alertDataReach: t ? e.data_volume_alert_percent : ""0"",
 limitTimeMonth: t ? ""0"" : e.data_volume_limit_size,
 alertTimeReach: t ? ""0"" : e.data_volume_alert_percent,
 monthlySent: """" == e.monthly_tx_bytes ? 0 : e.monthly_tx_bytes,
 monthlyReceived: """" == e.monthly_rx_bytes ? 0 : e.monthly_rx_bytes,
 monthlyConnectedTime: """" == e.monthly_time ? 0 : e.monthly_time,
 autoClearTraffic: e.wan_auto_clear_flow_data_switch,
 traffic_clear_date: e.traffic_clear_date
 }
 }
 return si
 }
 return s(arguments, {}, e, t, null, !1)
 }


 function Ct() {
 function e(e, t) {
 var r = ""1"" == e.dataLimitTypeChecked,
 _ = {
 isTest: oi,
 goformId: ""DATA_LIMIT_SETTING""
 };
 return ""1"" == e.dataLimitChecked && (_.data_volume_limit_unit = r ? ""data"" : ""time"", _.data_volume_limit_size = r ? e.limitDataMonth : e.limitTimeMonth, _.data_volume_alert_percent = r ? e.alertDataReach : e.alertTimeReach), _.wan_auto_clear_flow_data_switch = e.wan_auto_clear_flow_data_switch, _.traffic_clear_date = e.traffic_clear_date, -1 != n.DEVICE.toLowerCase().indexOf(""cpe"") ? _.data_volume_limit_switch = e.dataLimitChecked : (_.data_volume_limit_switch = e.dataLimitChecked, _.notify_deviceui_enable = ""0""), _
 }


 function t(e) {
 return e || si
 }
 return s(arguments, {}, e, t, null, !0)
 }


 function kt() {
 function e(e, t) {
 return ""send"" == e.sendOrReply ? {
 isTest: oi,
 goformId: ""USSD_PROCESS"",
 USSD_operator: e.operator,
 USSD_send_number: e.strUSSDCommand,
 notCallback: !0
 } : ""reply"" == e.sendOrReply ? {
 isTest: oi,
 goformId: ""USSD_PROCESS"",
 USSD_operator: e.operator,
 USSD_reply_number: e.strUSSDCommand,
 notCallback: !0
 } : void 0
 }


 function t(e) {
 if (!e) return void n(!1, ""ussd_fail"");
 ""success"" == e.result ? (callbackTemp = n, Ft()) : n(!1, ""ussd_fail"")
 }
 var n = arguments[1];
 return s(arguments, {}, e, t, null, !0)
 }


 function Ft() {
 t.ajax({
 url: ""/goform/goform_get_cmd_process"",
 data: {
 cmd: ""ussd_write_flag""
 },
 cache: !1,
 async: !0,
 dataType: ""json"",
 success: function(e) {
 ""1"" == e.ussd_write_flag ? callbackTemp(!1, ""ussd_no_service"") : ""4"" == e.ussd_write_flag || ""unknown"" == e.ussd_write_flag || ""3"" == e.ussd_write_flag ? callbackTemp(!1, ""ussd_timeout"") : ""15"" == e.ussd_write_flag ? setTimeout(Ft, 1e3) : ""10"" == e.ussd_write_flag ? callbackTemp(!1, ""ussd_retry"") : ""99"" == e.ussd_write_flag ? callbackTemp(!1, ""ussd_unsupport"") : ""41"" == e.ussd_write_flag ? callbackTemp(!1, ""operation_not_supported"") : ""2"" == e.ussd_write_flag ? callbackTemp(!1, ""network_terminated"") : ""16"" == e.ussd_write_flag ? t.ajax({
 url: ""/goform/goform_get_cmd_process"",
 data: {
 cmd: ""ussd_data_info""
 },
 dataType: ""json"",
 async: !0,
 cache: !1,
 success: function(e) {
 var t = {};
 t.data = e.ussd_data, t.ussd_action = e.ussd_action, t.ussd_dcs = e.ussd_dcs, callbackTemp(!0, t)
 },
 error: function() {
 callbackTemp(!1, ""ussd_info_error"")
 }
 }) : callbackTemp(!1, ""ussd_fail"")
 },
 error: function() {
 callbackTemp(!1, ""ussd_fail"")
 }
 })
 }


 function Wt(e) {
 function r() {
 t.ajax({
 url: ""/goform/goform_get_cmd_process"",
 data: {
 cmd: ""ussd_write_flag""
 },
 cache: !1,
 async: !0,
 dataType: ""json"",
 success: function(t) {
 ""15"" == t.ussd_write_flag ? setTimeout(r, 1e3) : e(""13"" == t.ussd_write_flag ? !0 : !1)
 },
 error: function() {
 e(!1)
 }
 })
 }
 var _ = {};
 if (_.goformId = ""USSD_PROCESS"", _.USSD_operator = ""ussd_cancel"", n.ACCESSIBLE_ID_SUPPORT) {
 var i = hex_md5(rd0 + rd1),
 s = hr({
 nv: ""RD""
 }).RD,
 o = hex_md5(i + s);
 _.AD = o
 }
 t.ajax({
 url: ""/goform/goform_set_cmd_process"",
 data: _,
 cache: !1,
 dataType: ""json"",
 success: function(t) {
 ""success"" == t.result ? r() : e(!1)
 }
 })
 }


 function xt() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.cmd = ""dlna_language,dlna_name,dlna_share_audio,dlna_share_video,dlna_share_image,dlna_scan_state,sd_card_state,sdcard_mode_option,dlna_rescan_end"", n.multi_data = 1, n
 }


 function t(e) {
 if (e) {
 return {
 language: e.dlna_language,
 deviceName: e.dlna_name,
 shareAudio: e.dlna_share_audio,
 shareVideo: e.dlna_share_video,
 shareImage: e.dlna_share_image,
 needRescan: ""1"" == e.dlna_scan_state,
 dlnaEnable: !0,
 dlna_scan: e.dlna_rescan_end
 }
 }
 return si
 }
 return s(arguments, {}, e, t, null, !1)
 }


 function Lt() {
 function e(e, t) {
 return {
 isTest: oi,
 notCallback: !0,
 goformId: ""DLNA_SETTINGS"",
 dlna_language: e.language,
 dlna_name: e.deviceName,
 dlna_share_audio: e.shareAudio,
 dlna_share_video: e.shareVideo,
 dlna_share_image: e.shareImage
 }
 }


 function t(e) {
 e && ""success"" == e.result ? L(""dlna_rescan_end"", n) : r(e)
 }


 function n(e) {
 Ut(e, r, n)
 }
 var r = arguments[1];
 return s(arguments, {}, e, t, null, !0)
 }


 function Ot() {
 function e(e, t) {
 return {
 isTest: oi,
 notCallback: !0,
 goformId: ""DLNA_RESCAN""
 }
 }


 function t(e) {
 e && ""success"" == e.result ? L(""dlna_rescan_end"", n) : r(e)
 }


 function n(e) {
 Ut(e, r, n)
 }
 var r = arguments[1];
 return s(arguments, {}, e, t, null, !0)
 }


 function Ut(e, t, n) {
 ""1"" == e.dlna_rescan_end && (O(""dlna_rescan_end"", n), t({
 result: ""success""
 }))
 }


 function Bt() {
 function e(e) {
 return {
 isTest: oi,
 goformId: ""UNLOCK_NETWORK"",
 notCallback: !0,
 unlock_network_code: e.unlock_network_code
 }
 }


 function t(e) {
 e && ""success"" == e.result ? U(n) : r({
 result: ""fail""
 })
 }


 function n() {
 _ > 5 ? (B(n), r({
 result: ""fail""
 })) : ""modem_imsi_waitnck"" != ci.simStatus && (B(n), r({
 result: ""success""
 })), _++
 }
 var r = arguments[1],
 _ = 0;
 return s(arguments, {}, e, t, null, !0)
 }


 function Vt() {
 function e(e, t) {
 return {
 isTest: oi,
 cmd: ""unlock_nck_time""
 }
 }


 function t(e) {
 return e || si
 }
 return s(arguments, {}, e, t, null, !1)
 }


 function Ht() {
 function e(e) {
 return {
 isTest: oi,
 goformId: ""SET_UPGRADE_NOTICE"",
 upgrade_notice_flag: e.upgrade_notice_flag,
 notCallback: !0
 }
 }


 function t(e) {
 n(""success"" == e.result ? !0 : !1)
 }
 var n = arguments[1];
 return s(arguments, {}, e, t, null, !0)
 }


 function Gt() {
 function e(e, t) {
 return {
 isTest: oi,
 cmd: ""upgrade_notice_flag""
 }
 }


 function t(e) {
 return e || si
 }
 return s(arguments, {}, e, t, null, !1)
 }


 function Kt() {
 function e(e, t) {
 return {
 isTest: oi,
 multi_data: 1,
 cmd: ""wifi_sta_connection,ap_station_mode,m_ssid_enable""
 }
 }


 function t(e) {
 return e ? {
 multi_ssid_enable: e.m_ssid_enable,
 ap_station_enable: e.wifi_sta_connection,
 ap_station_mode: e.ap_station_mode
 } : si
 }
 return s(arguments, {}, e, t, null, !1)
 }


 function zt() {
 function e(e) {
 return {
 isTest: oi,
 goformId: ""WIFI_STA_CONTROL"",
 wifi_sta_connection: e.ap_station_enable,
 ap_station_mode: e.ap_station_mode
 }
 }


 function t(e) {
 return e && ""success"" == e.result ? (ci.ap_station_enable = 1 == n.ap_station_enable, ci.ap_station_mode = n.ap_station_mode, e) : si
 }
 var n = arguments[0];
 return s(arguments, {}, e, t, null, !0)
 }


 function Xt() {
 return Kt({}, function(e) {
 ci.ap_station_enable = 1 == e.ap_station_enable, ci.ap_station_mode = e.ap_station_mode
 })
 }


 function jt() {
 function e(e, t) {
 return {
 isTest: oi,
 multi_data: 1,
 cmd: ""wifi_profile,wifi_profile1,wifi_profile2,wifi_profile3,wifi_profile4,wifi_profile5,wifi_profile_num""
 }
 }


 function t(e) {
 if (e) {
 for (var t = [], n = 0; n <= 5; n++) {
 var r = """";
 r = 0 == n ? e.wifi_profile : e[""wifi_profile"" + n];
 for (var _ = r.split("";""), i = 0; i < _.length; i++) {
 var s = _[i].split("","");
 if (!s[0]) break;
 var o = {
 profileName: s[0],
 fromProvider: s[1],
 connectStatus: s[2],
 signal: s[3],
 ssid: s[4],
 authMode: s[5],
 encryptType: s[6],
 password: ""0"" == s[7] ? """" : s[7],
 keyID: s[8]
 };
 t.push(o)
 }
 }
 return {
 hotspotList: t
 }
 }
 return si
 }
 return s(arguments, {}, e, t, null, !1)
 }


 function qt() {
 function e(e) {
 return {
 isTest: oi,
 goformId: ""WLAN_SET_STA_REFRESH""
 }
 }


 function t(e) {
 return e || si
 }
 return s(arguments, {}, e, t, null, !0)
 }


 function Zt() {
 function e(e, t) {
 return {
 isTest: oi,
 multi_data: 1,
 cmd: ""scan_finish,EX_APLIST,EX_APLIST1""
 }
 }


 function t(e) {
 if (e) {
 if (""0"" == e.scan_finish) return {
 scan_finish: !1,
 hotspotList: []
 };
 for (var t = [], n = 0; n <= 1; n++) {
 var r;
 r = 0 == n ? e.EX_APLIST : e.EX_APLIST1;
 for (var _ = r.split("";""), i = 0; i < _.length; i++) {
 var s = _[i].split("","");
 if (!s[0]) break;
 var o = {
 fromProvider: s[0],
 connectStatus: s[1],
 ssid: s[2],
 signal: s[3],
 channel: s[4],
 authMode: s[5],
 encryptType: s[6]
 };
 t.push(o)
 }
 }
 return {
 scan_finish: !0,
 hotspotList: t
 }
 }
 return si
 }
 return s(arguments, {}, e, t, null, !1)
 }


 function Yt() {
 function e(e, t) {
 return {
 isTest: oi,
 multi_data: 1,
 cmd: ""EX_APLIST,EX_APLIST1""
 }
 }


 function t(e) {
 if (e) {
 for (var t = [], n = 0; n <= 1; n++) {
 var r;
 r = 0 == n ? e.EX_APLIST : e.EX_APLIST1;
 for (var _ = r.split("";""), i = 0; i < _.length; i++) {
 var s = _[i].split("","");
 if (!s[0]) break;
 var o = {
 fromProvider: s[0],
 connectStatus: s[1],
 ssid: s[2],
 signal: s[3],
 channel: s[4],
 authMode: s[5],
 encryptType: s[6]
 };
 t.push(o)
 }
 }
 return {
 hotspotList: t
 }
 }
 return si
 }
 return s(arguments, {}, e, t, null, !1)
 }


 function Qt(e) {
 var t = [];
 return t.push(e.profileName), t.push(e.fromProvider || ""0""), t.push(e.connectStatus || ""0""), t.push(e.signal), t.push(e.ssid), t.push(e.authMode), t.push(e.encryptType), t.push(e.password || ""0""), t.push(e.keyID), t.join("","")
 }


 function Jt() {
 function e(e) {
 var t = e.apList,
 n = ""modify"";
 if (""2"" == e.saveAddFlag) {
 n = ""add"", t.reverse();
 t.push({
 profileName: e.profileName,
 fromProvider: ""0"",
 connectStatus: ""0"",
 signal: e.signal,
 ssid: e.ssid,
 authMode: e.authMode,
 encryptType: e.encryptType,
 password: e.password || ""0"",
 keyID: e.keyID
 }), t.reverse()
 }
 for (var r = {
 profile0: [],
 profile1: [],
 profile2: [],
 profile3: [],
 profile4: [],
 profile5: []
 }, _ = """", i = 0; i < t.length; i++) {
 var s = """";
 e.profileNameInit == t[i].profileName ? (s = Qt(e), _ = s) : s = Qt(t[i]);
 r[""profile"" + parseInt(i / 5)].push(s)
 }
 return {
 isTest: oi,
 goformId: ""WIFI_SPOT_PROFILE_UPDATE"",
 wifi_profile: r.profile0.join("";""),
 wifi_profile1: r.profile1.join("";""),
 wifi_profile2: r.profile2.join("";""),
 wifi_profile3: r.profile3.join("";""),
 wifi_profile4: r.profile4.join("";""),
 wifi_profile5: r.profile5.join("";""),
 wifi_profile_num: t.length,
 wifi_update_profile: _,
 action: n
 }
 }


 function t(e) {
 return e || si
 }
 return s(arguments, {}, e, t, null, !0)
 }


 function $t() {
 function e(e) {
 for (var t = e.apList, n = {
 profile0: [],
 profile1: [],
 profile2: [],
 profile3: [],
 profile4: [],
 profile5: []
 }, r = !1, _ = """", i = 0; i < t.length; i++) {
 var s = Qt(t[i]);
 if (t[i].profileName != e.profileName) {
 var o = i;
 r && (o = i - 1);
 n[""profile"" + parseInt(o / 5)].push(s)
 } else r = !0, _ = s
 }
 var a = r ? t.length - 1 : t.length;
 return {
 isTest: oi,
 goformId: ""WIFI_SPOT_PROFILE_UPDATE"",
 wifi_profile: n.profile0.join("";""),
 wifi_profile1: n.profile1.join("";""),
 wifi_profile2: n.profile2.join("";""),
 wifi_profile3: n.profile3.join("";""),
 wifi_profile4: n.profile4.join("";""),
 wifi_profile5: n.profile5.join("";""),
 wifi_profile_num: a,
 wifi_update_profile: _,
 action: ""delete""
 }
 }


 function t(e) {
 return e || si
 }
 return s(arguments, {}, e, t, null, !0)
 }


 function en() {
 function e(e) {
 return {
 isTest: oi,
 goformId: ""WLAN_SET_STA_CON"",
 EX_SSID1: e.EX_SSID1,
 EX_AuthMode: e.EX_AuthMode,
 EX_EncrypType: e.EX_EncrypType,
 EX_DefaultKeyID: e.EX_DefaultKeyID,
 EX_WEPKEY: e.EX_WEPKEY,
 EX_WPAPSK1: e.EX_WPAPSK1,
 EX_wifi_profile: e.EX_wifi_profile
 }
 }


 function t(e) {
 return e && ""success"" == e.result ? e : si
 }
 return s(arguments, {}, e, t, null, !0)
 }


 function tn() {
 function e(e) {
 return {
 isTest: oi,
 goformId: ""WLAN_SET_STA_DISCON""
 }
 }


 function t(e) {
 return e && ""success"" == e.result ? e : si
 }
 return s(arguments, {}, e, t, null, !0)
 }


 function nn() {
 function e(e, t) {
 return {
 isTest: oi,
 multi_data: 1,
 cmd: ""opms_wan_mode,opms_wan_auto_mode,loginfo,ppp_status,ethernet_port_specified""
 }
 }


 function t(e) {
 if (e) {
 var t = {};
 return ""AUTO"" == e.opms_wan_mode ? t.opms_wan_mode = e.opms_wan_auto_mode ? e.opms_wan_auto_mode : """" : t.opms_wan_mode = e.opms_wan_mode ? e.opms_wan_mode : """", t.loginfo = e.loginfo, t.ppp_status = e.ppp_status, t.ethernet_port_specified = ""1"" == e.ethernet_port_specified ? e.ethernet_port_specified : ""0"", t
 }
 return si
 }
 return s(arguments, {}, e, t, null, !1)
 }


 function rn(e, n) {
 function r(e) {
 return t.extend({
 isTest: oi,
 goformId: ""OPERATION_MODE""
 }, e)
 }


 function _(e) {
 return e && ""success"" == e.result ? e : si
 }
 return s(arguments, {}, r, _, null, !0)
 }


 function _n(e, n) {
 function r(e) {
 return t.extend({
 isTest: oi
 }, e)
 }


 function _(e) {
 return e && ""success"" == e.result ? e : si
 }
 return s(arguments, {}, r, _, null, !0)
 }


 function sn() {
 function e(e, t) {
 return {
 isTest: oi,
 multi_data: 1,
 cmd: ""opms_wan_auto_mode,pppoe_username,pppoe_password,pppoe_dial_mode,pppoe_status,static_wan_ipaddr,static_wan_netmask,static_wan_gateway,static_wan_primary_dns,static_wan_secondary_dns,dhcp_wan_status,static_wan_status""
 }
 }


 function t(e) {
 return e ? {
 opms_wan_auto_mode: e.opms_wan_auto_mode,
 pppoe_username: e.pppoe_username,
 pppoe_password: e.pppoe_password,
 pppoe_dial_mode: e.pppoe_dial_mode,
 ppp_status: e.pppoe_status,
 static_wan_ipaddr: e.static_wan_ipaddr,
 static_wan_netmask: e.static_wan_netmask,
 static_wan_gateway: e.static_wan_gateway,
 static_wan_primary_dns: e.static_wan_primary_dns,
 static_wan_secondary_dns: e.static_wan_secondary_dns,
 dhcp_wan_status: e.dhcp_wan_status,
 static_wan_status: e.static_wan_status
 } : si
 }
 return s(arguments, {}, e, t, null, !1)
 }


 function on(e, n) {
 function r(e) {
 return t.extend({
 isTest: oi,
 notCallback: !0
 }, e)
 }


 function _(t) {
 ""success"" == t.result ? ""WAN_GATEWAYMODE_PPPOE"" == e.goformId && ""connect"" == e.action_link ? (showLoading(""connecting""), checkPoint = (new Date).getTime(), U(i)) : ""WAN_GATEWAYMODE_PPPOE"" == e.goformId && ""disconnect"" == e.action_link ? (checkPoint = (new Date).getTime(), U(o)) : n({
 result: !0
 }) : n({
 result: !1
 })
 }


 function i(e) {
 ""ppp_connecting"" == e.pppoe_status ? ci.connectStatus = ""ppp_connecting"" : checkConnectedStatus(e.pppoe_status) ? (B(i), ci.connectStatus = ""ppp_connected"", n({
 result: !0,
 status: ci.connectStatus
 })) : (new Date).getTime() - checkPoint < 1e4 ? ci.connectStatus = ""ppp_connecting"" : (B(i), n({
 result: !1
 }))
 }


 function o(e) {
 ""ppp_disconnecting"" == e.pppoe_status ? ci.connectStatus = ""ppp_disconnecting"" : ""ppp_disconnected"" == e.pppoe_status ? (B(o), ci.connectStatus = ""ppp_disconnected"", n({
 result: !0,
 status: ci.connectStatus
 })) : (new Date).getTime() - checkPoint < 1e4 ? ci.connectStatus = ""ppp_disconnecting"" : (B(o), n({
 result: !1
 }))
 }
 return s(arguments, {}, r, _, null, !0)
 }


 function an(e, t) {
 function n(e, t) {
 return {
 isTest: oi,
 multi_data: 1,
 cmd: ""sntp_year,sntp_month_temp,sntp_day,sntp_hour,sntp_minute,sntp_second,sntp_time_set_mode,sntp_server_list1,sntp_server_list2,sntp_server_list3,sntp_server_list4,sntp_server_list5,sntp_server_list6,sntp_server_list7,sntp_server_list8,sntp_server_list9,sntp_server_list10,sntp_server0,sntp_server1,sntp_server2,sntp_other_server0,sntp_other_server1,sntp_other_server2,sntp_timezone,sntp_dst_enable,ppp_status,opms_wan_mode,syn_done""
 }
 }


 function r(e) {
 if (e) {
 var t = _(e);
 return {
 sntp_year: e.sntp_year,
 sntp_month: e.sntp_month_temp,
 sntp_day: e.sntp_day,
 sntp_hour: e.sntp_hour,
 sntp_minute: e.sntp_minute,
 sntp_second: e.sntp_second,
 sntp_time_set_mode: e.sntp_time_set_mode,
 sntp_servers: t,
 sntp_server0: e.sntp_server0,
 sntp_server1: e.sntp_server1,
 sntp_server2: e.sntp_server2,
 sntp_other_server0: e.sntp_other_server0,
 sntp_other_server1: e.sntp_other_server1,
 sntp_other_server2: e.sntp_other_server2,
 sntp_timezone: e.sntp_timezone,
 sntp_dst_enable: e.sntp_dst_enable,
 ppp_status: e.ppp_status,
 opms_wan_mode: e.opms_wan_mode,
 syn_done: e.syn_done
 }
 }
 return si
 }


 function _(e) {
 for (var t = [], n = 0; n < 10; n++) {
 var r = ""sntp_server_list"" + (n + 1).toString();
 if ("""" != e[r]) {
 var _ = {};
 _.name = e[r], _.value = e[r], t.push(_)
 }
 }
 for (var i = [{
 name: ""Other"",
 value: ""Other""
 }, {
 name: ""NONE"",
 value: """"
 }], s = 0; s < 2; s++) t.push(i[s]);
 return t
 }
 return s(arguments, {}, n, r, null, !1)
 }


 function un(e, n) {
 function r(e) {
 return t.extend({
 isTest: oi
 }, e)
 }


 function _(e) {
 return e && ""success"" == e.result ? e : si
 }
 return s(arguments, {}, r, _, null, !0)
 }


 function cn(e, r) {
 function _() {
 t.ajax({
 url: ""/goform/goform_get_cmd_process"",
 dataType: ""json"",
 data: {
 cmd: ""syn_done,nitz_sync_flag"",
 multi_data: ""1""
 },
 cache: !1,
 async: !1,
 success: function(e) {
 ""1"" == e.syn_done || ""1"" == e.nitz_sync_flag ? r(!0) : ""0"" == e.syn_done ? r(!1) : setTimeout(_, 2e3)
 },
 error: function() {
 r(!1)
 }
 })
 }
 var i = t.extend({
 isTest: oi
 }, e);
 if (i.isTest) result = simulate.simulateRequest(e, r, r, !0, !0), setTimeout(function() {
 r(result)
 }, getRandomInt(120) + 50);
 else {
 if (n.ACCESSIBLE_ID_SUPPORT) {
 var s = hex_md5(rd0 + rd1),
 o = hr({
 nv: ""RD""
 }).RD,
 a = hex_md5(s + o);
 i.AD = a
 }
 t.post(""/goform/goform_set_cmd_process"", i, function(t) {
 t && ""success"" == t.result ? ""auto"" == e.manualsettime ? setTimeout(_, 2e3) : r(!0) : r(!1)
 }, ""json"")
 }
 }


 function dn(e, n) {
 function r(e) {
 return t.extend({
 isTest: oi
 }, e)
 }


 function _(e) {
 return e && ""success"" == e.result ? e : si
 }
 return s(arguments, {}, r, _, null, !0)
 }


 function ln() {
 function e(e, t) {
 return {
 isTest: oi,
 cmd: ""websURLFilters""
 }
 }


 function t(e) {
 var t = [];
 if (e) {
 if (0 == e.websURLFilters.length) return {
 urlFilterRules: []
 };
 for (var n = e.websURLFilters.split("";""), r = 0; r < n.length; r++) {
 var _ = {};
 _.index = r, _.url = n[r], t.push(_)
 }
 return {
 urlFilterRules: t
 }
 }
 return si
 }
 return s(arguments, {}, e, t, null, !1)
 }


 function pn(e, n) {
 function r(e) {
 return t.extend({
 isTest: oi
 }, e)
 }


 function _(e) {
 return e && ""success"" == e.result ? e : si
 }
 return s(arguments, {}, r, _, null, !0)
 }


 function mn() {
 function e(e, t) {
 return {
 isTest: oi,
 multi_data: ""1"",
 cmd: ""wifi_wds_mode,wifi_wds_ssid,wifi_wds_AuthMode,wifi_wds_EncrypType,wifi_wds_WPAPSK1,RadioOff""
 }
 }


 function t(e) {
 return e ? {
 currentMode: e.wifi_wds_mode,
 wdsSSID: e.wifi_wds_ssid,
 wdsAuthMode: e.wifi_wds_AuthMode,
 wdsEncrypType: e.wifi_wds_EncrypType,
 wdsWPAPSK1: e.wifi_wds_WPAPSK1,
 RadioOff: e.RadioOff
 } : si
 }
 return s(arguments, {}, e, t, null, !1)
 }


 function fn(e, n) {
 function r(e) {
 return t.extend({
 isTest: oi
 }, e)
 }


 function _(e) {
 return e && ""success"" == e.result ? e : si
 }
 return s(arguments, {}, r, _, null, !0)
 }


 function gn() {
 function e(e, t) {
 return {
 isTest: oi,
 multi_data: ""1"",
 cmd: ""syslog_mode,debug_level""
 }
 }


 function t(e) {
 return e ? {
 currentMode: e.syslog_mode,
 debugLevel: e.debug_level
 } : si
 }
 return s(arguments, {}, e, t, null, !1)
 }


 function vn(e, n) {
 function r(e) {
 return t.extend({
 isTest: oi
 }, e)
 }


 function _(e) {
 return e && ""success"" == e.result ? e : si
 }
 return s(arguments, {}, r, _, null, !0)
 }


 function wn() {
 function e(e, t) {
 return {
 isTest: oi,
 multi_data: ""1"",
 cmd: ""tr069_ServerURL,tr069_CPEPortNo,tr069_ServerUsername,tr069_ServerPassword,tr069_ConnectionRequestUname,tr069_ConnectionRequestPassword,wan_ipaddr,tr069_PeriodicInformEnable,tr069_PeriodicInformInterval,tr069_CertEnable,tr069_DataModule,tr069_Webui_DataModuleSupport""
 }
 }


 function t(e) {
 return e ? {
 serverUrl: e.tr069_ServerURL,
 tr069_CPEPortNo: e.tr069_CPEPortNo,
 serverUserName: e.tr069_ServerUsername,
 serverPassword: e.tr069_ServerPassword,
 requestUserName: e.tr069_ConnectionRequestUname,
 requestPassword: e.tr069_ConnectionRequestPassword,
 wanIpAddress: e.wan_ipaddr,
 tr069_PeriodicInformEnable: e.tr069_PeriodicInformEnable,
 tr069_PeriodicInformInterval: e.tr069_PeriodicInformInterval,
 tr069_CertEnable: e.tr069_CertEnable,
 tr069_DataModule: e.tr069_DataModule,
 tr069_Webui_DataModuleSupport: e.tr069_Webui_DataModuleSupport
 } : si
 }
 return s(arguments, {}, e, t, null, !1)
 }


 function hn(e, n) {
 function r(e) {
 return t.extend({
 isTest: oi
 }, e)
 }


 function _(e) {
 return e && ""success"" == e.result ? e : si
 }
 return s(arguments, {}, r, _, null, !0)
 }


 function Sn() {
 function e(e, t) {
 return {
 isTest: oi,
 multi_data: ""1"",
 cmd: ""voip_display_name,voip_user_name,voip_authorization_user_name,voip_authorization_password,voip_registration_server,voip_registration_server_port,voip_proxy_server,voip_proxy_server_port,voip_outbound_proxy_enable,voip_outbound_proxy,voip_outbound_proxy_port,voip_register_status""
 }
 }


 function t(e) {
 return e ? {
 display_name: e.voip_display_name,
 user_name: e.voip_authorization_user_name,
 authorization_user_name: e.voip_user_name,
 authorization_password: e.voip_authorization_password,
 registration_server: e.voip_registration_server,
 registration_server_port: e.voip_registration_server_port,
 proxy_server: e.voip_proxy_server,
 proxy_server_port: e.voip_proxy_server_port,
 outboundEnable: e.voip_outbound_proxy_enable,
 outboundServer: e.voip_outbound_proxy,
 outboundPort: e.voip_outbound_proxy_port,
 voip_register_status: e.voip_register_status
 } : si
 }
 return s(arguments, {}, e, t, null, !1)
 }


 function Tn(e, n) {
 function r(e) {
 return t.extend({
 isTest: oi
 }, e)
 }


 function _(e) {
 return e && ""success"" == e.result ? e : si
 }
 return s(arguments, {}, r, _, null, !0)
 }


 function Pn() {
 function e(e, t) {
 return {
 isTest: oi,
 multi_data: ""1"",
 cmd: ""voip_sip_register_server1,voip_sip_domain1,voip_sip_realm1,voip_sip_proxy_enable1,voip_sip_proxy_server1,voip_account_display_account1,voip_account_auth1,voip_account_password1,voip_user1_register_status""
 }
 }


 function t(e) {
 return e ? {
 sipRegisterServer: e.voip_sip_register_server1,
 sipDomain: e.voip_sip_domain1,
 sipRealm: e.voip_sip_realm1,
 sipProxyMode: e.voip_sip_proxy_enable1,
 voipSipProxyServer: e.voip_sip_proxy_server1,
 displayName: e.voip_account_display_account1,
 authorizedUserName: e.voip_account_auth1,
 authorizedPassword: e.voip_account_password1,
 voipRegisterStatus: e.voip_user1_register_status
 } : si
 }
 return s(arguments, {}, e, t, null, !1)
 }


 function In() {
 function e(e, t) {
 return {
 isTest: oi,
 cmd: ""voip_user1_register_status""
 }
 }


 function t(e) {
 return e ? {
 voipRegisterStatus: e.voip_user1_register_status
 } : si
 }
 return s(arguments, {}, e, t, null, !1)
 }


 function bn() {
 function e(e) {
 return t.extend({
 isTest: oi
 }, e)
 }


 function n(e) {
 return e && ""success"" == e.result ? e : si
 }
 return s(arguments, {}, e, n, null, !0)
 }


 function An() {
 function e(e, t) {
 return {
 isTest: oi,
 multi_data: ""1"",
 cmd: ""voip_sip_t38_enable1,voip_sip_dtmf_method,voip_sip_encoder1,voip_sip_vad_enable1,voip_sip_cng_enable1""
 }
 }


 function t(e) {
 return e ? {
 sipT38Mode: e.voip_sip_t38_enable1,
 currentDtmfMethod: e.voip_sip_dtmf_method,
 currentVoipSipEncoderMethod: e.voip_sip_encoder1,
 sipVadMode: e.voip_sip_vad_enable1,
 sipCngMode: e.voip_sip_cng_enable1
 } : si
 }
 return s(arguments, {}, e, t, null, !1)
 }


 function yn() {
 function e(e) {
 return t.extend({
 isTest: oi
 }, e)
 }


 function n(e) {
 return e && ""success"" == e.result ? e : si
 }
 return s(arguments, {}, e, n, null, !0)
 }


 function En() {
 function e(e, t) {
 return {
 isTest: oi,
 multi_data: ""1"",
 cmd: ""voip_call_waiting_enable,voip_call_hold_enable,voip_three_way_talking_enable,voip_call_transfer_enable,voip_call_fwd_unconditional_enable,voip_call_fwd_unconditional_number,voip_call_fwd_busy_enable,voip_call_fwd_busy_number,voip_call_fwd_no_answer_enable,voip_call_fwd_no_answer_number""
 }
 }


 function t(e) {
 return e ? {
 voip_call_waiting_enable: e.voip_call_waiting_enable,
 voip_call_hold_enable: e.voip_call_hold_enable,
 voip_three_way_talking_enable: e.voip_three_way_talking_enable,
 voip_call_transfer_enable: e.voip_call_transfer_enable,
 voip_call_fwd_unconditional_enable: e.voip_call_fwd_unconditional_enable,
 voip_call_fwd_unconditional_number: e.voip_call_fwd_unconditional_number,
 voip_call_fwd_busy_enable: e.voip_call_fwd_busy_enable,
 voip_call_fwd_busy_number: e.voip_call_fwd_busy_number,
 voip_call_fwd_no_answer_enable: e.voip_call_fwd_no_answer_enable,
 voip_call_fwd_no_answer_number: e.voip_call_fwd_no_answer_number,
 selectedMode: ""1"" == e.voip_call_fwd_unconditional_enable ? 1 : 0
 } : si
 }
 return s(arguments, {}, e, t, null, !1)
 }


 function Rn() {
 function e(e) {
 return t.extend({
 isTest: oi
 }, e)
 }


 function n(e) {
 return e && ""success"" == e.result ? e : si
 }
 return s(arguments, {}, e, n, null, !0)
 }


 function Nn() {
 function e(e, t) {
 return {
 isTest: oi,
 multi_data: ""1"",
 cmd: ""ACL_mode,wifi_mac_black_list,wifi_hostname_black_list,RadioOff,user_ip_addr""
 }
 }


 function t(e) {
 return e ? {
 ACL_mode: e.ACL_mode,
 wifi_mac_black_list: e.wifi_mac_black_list,
 wifi_hostname_black_list: e.wifi_hostname_black_list,
 RadioOff: e.RadioOff,
 user_ip_addr: e.user_ip_addr
 } : si
 }
 return s(arguments, {}, e, t, null, !1)
 }


 function Mn() {
 function e(e) {
 return {
 goformId: ""WIFI_MAC_FILTER"",
 isTest: oi,
 ACL_mode: e.ACL_mode,
 macFilteringMode: e.ACL_mode,
 wifi_hostname_black_list: e.wifi_hostname_black_list,
 wifi_mac_black_list: e.wifi_mac_black_list
 }
 }


 function t(e) {
 return e && ""success"" == e.result ? e : si
 }
 return s(arguments, {}, e, t, null, !0)
 }


 function Dn() {
 function e(e) {
 return {
 isTest: oi,
 cmd: ""mgmt_quicken_power_on,need_hard_reboot"",
 multi_data: 1
 }
 }


 function t(e) {
 return {
 fastbootEnabled: ""1"" == e.mgmt_quicken_power_on ? ""1"" : ""0"",
 need_hard_reboot: e.need_hard_reboot
 }
 }
 return s(arguments, {}, e, t, null, !1)
 }


 function Cn() {
 function e(e) {
 return {
 isTest: oi,
 goformId: ""MGMT_CONTROL_POWER_ON_SPEED"",
 mgmt_quicken_power_on: e.fastbootEnabled,
 need_hard_reboot: e.need_hard_reboot
 }
 }


 function t(e) {
 return e && ""success"" == e.result ? e : si
 }
 return s(arguments, {}, e, t, null, !0)
 }


 function kn() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.goformId = ""REBOOT_DEVICE"", n
 }


 function t(e) {
 return e || si
 }
 return s(arguments, {}, e, t, null, !0)
 }


 function Fn() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.goformId = ""SHUTDOWN_DEVICE"", n
 }


 function t(e) {
 return e || si
 }
 return s(arguments, {}, e, t, null, !0)
 }


 function Wn() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.cmd = ""new_version_state"", n
 }


 function t(e) {
 if (e) {
 var t = ""1"" == e.new_version_state || ""version_has_new_critical_software"" == e.new_version_state || ""version_has_new_optional_software"" == e.new_version_state;
 return e.hasNewVersion = t, e
 }
 return si
 }
 return s(arguments, {}, e, t, null, !1)
 }


 function xn() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.cmd = ""dm_new_version"", n
 }


 function t(e) {
 return e || si
 }
 return s(arguments, {}, e, t, null, !1)
 }


 function Ln() {
 function e(e, t) {
 var r = {};
 return r.isTest = oi, ""OTA"" == n.UPGRADE_TYPE ? r.cmd = ""is_mandatory"" : r.cmd = ""new_version_state"", r
 }


 function t(e) {
 return e ? ""OTA"" == n.UPGRADE_TYPE ? {
 is_mandatory: ""1"" == e.is_mandatory
 } : {
 is_mandatory: ""version_has_new_critical_software"" == e.new_version_state
 } : si
 }
 return s(arguments, {}, e, t, null, !1)
 }


 function On() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.cmd = ""upgrade_result"", n
 }


 function t(e) {
 return e || si
 }
 return s(arguments, {}, e, t, null, !1)
 }


 function Un() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.cmd = ""current_upgrade_state"", n
 }


 function t(e) {
 return e ? (""downloading"" == e.current_upgrade_state && (e.current_upgrade_state = ""upgrading""), e) : si
 }
 return s(arguments, {}, e, t, null, !1)
 }


 function Bn() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.cmd = ""dm_update_package_file_exist"", n
 }


 function t(e) {
 return e || si
 }
 return s(arguments, {}, e, t, null, !1)
 }


 function Vn() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.cmd = ""pack_size_info"", n
 }


 function t(e) {
 return e || si
 }
 return s(arguments, {}, e, t, null, !1)
 }


 function Hn() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.cmd = ""if_has_select"", n
 }


 function t(e) {
 return e || si
 }
 return s(arguments, {}, e, t, null, !1)
 }


 function Gn() {
 function e(e, t) {
 var n = {};
 return n.goformId = ""IF_UPGRADE"", n.isTest = oi, n.select_op = e.selectOp, ""check"" == n.select_op && (n.ota_manual_check_roam_state = 1), n
 }


 function t(e) {
 return e || si
 }
 return s(arguments, {}, e, t, null, !0)
 }


 function Kn() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.cmd = ""GetUpgAutoSetting"", n
 }


 function t(e) {
 return e ? {
 updateMode: e.UpgMode,
 updateIntervalDay: e.UpgIntervalDay,
 allowRoamingUpdate: e.UpgRoamPermission
 } : si
 }
 return s(arguments, {}, e, t, null, !1)
 }


 function zn() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.goformId = ""SetUpgAutoSetting"", n.UpgMode = e.updateMode, n.UpgIntervalDay = e.updateIntervalDay, n.UpgRoamPermission = e.allowRoamingUpdate, n
 }


 function t(e) {
 return e && ""success"" == e.result ? e : si
 }
 return s(arguments, {}, e, t, null, !0)
 }


 function Xn() {
 return hr({
 nv: [""dm_last_check_time""]
 }, arguments[1], arguments[2])
 }


 function jn() {
 return hr({
 nv: [""dm_update_successful_time""]
 }, arguments[1], arguments[2])
 }


 function qn() {
 return hr({
 nv: [""network_type"", ""rssi"", ""rscp"", ""lte_rsrp"", ""Z5g_snr"", ""Z5g_rsrp"", ""ZCELLINFO_band"", ""Z5g_dlEarfcn"", ""lte_ca_pcell_arfcn"", ""lte_ca_pcell_band"", ""lte_ca_scell_band"", ""lte_ca_pcell_bandwidth"", ""lte_ca_scell_info"", ""lte_ca_scell_bandwidth"", ""wan_lte_ca"", ""lte_pci"", ""Z5g_CELL_ID"", ""Z5g_SINR"", ""cell_id"", ""wan_lte_ca"", ""lte_ca_pcell_band"", ""lte_ca_pcell_bandwidth"", ""lte_ca_scell_band"", ""lte_ca_scell_bandwidth"", ""lte_ca_pcell_arfcn"", ""lte_ca_scell_arfcn"", ""lte_multi_ca_scell_info"", ""wan_active_band"", ""nr5g_pci"", ""nr5g_action_band"", ""nr5g_cell_id"", ""lte_snr"", ""ecio"", ""wan_active_channel"", ""nr5g_action_channel""]
 }, arguments[1], arguments[2])
 }


 function Zn() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.goformId = ""RESULT_RESTORE"", n
 }


 function t(e) {
 return e && ""success"" == e.result ? e : si
 }
 return s(arguments, {}, e, t, null, !0)
 }


 function Yn() {
 function e(e) {
 return {
 isTest: oi,
 goformId: ""RESET_DATA_COUNTER""
 }
 }


 function t(e) {
 return e && ""success"" == e.result ? e : si
 }
 return s(arguments, {}, e, t, null, !0)
 }


 function Qn() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.goformId = ""CHANGE_MODE"", n.change_mode = e.change_mode, n
 }


 function t(e) {
 return e || si
 }
 return s(arguments, {}, e, t, null, !0)
 }


 function Jn() {
 function e(e, t) {
 return {
 isTest: oi,
 cmd: ""childGroupList""
 }
 }


 function t(e) {
 return e && (e.childGroupList || e.devices) ? oi ? e.childGroupList : e : {
 devices: []
 }
 }
 return s(arguments, {}, e, t, null, !1)
 }


 function $n() {
 function e(e, t) {
 return {
 isTest: oi,
 goformId: ""ADD_DEVICE"",
 mac: e.macAddress
 }
 }


 function t(e) {
 return e && ""success"" == e.result ? e : si
 }
 return s(arguments, 0 == n.currentUserInChildGroup ? {} : {
 errorType: ""no_auth""
 }, e, t, null, !0)
 }


 function er() {
 function e(e, t) {
 return {
 isTest: oi,
 goformId: ""DEL_DEVICE"",
 mac: e.mac
 }
 }


 function t(e) {
 return e && ""success"" == e.result ? e : si
 }
 return s(arguments, 0 == n.currentUserInChildGroup ? {} : {
 errorType: ""no_auth""
 }, e, t, null, !0)
 }


 function tr(t) {
 if (void 0 === n.currentUserInChildGroup) {
 var r = [];
 r = void 0 !== t ? t : Jn({}).devices;
 var _ = sr({}).get_user_mac_addr || sr({}).user_mac_addr,
 i = e.find(r, function(e) {
 return e.mac == _
 });
 return n.currentUserInChildGroup = void 0 !== i, {
 result: void 0 !== i
 }
 }
 return {
 result: n.currentUserInChildGroup
 }
 }


 function nr() {
 function e(e, t) {
 return {
 isTest: oi,
 cmd: ""child_mac_rule_info"",
 mac_addr: e.mac_addr
 }
 }


 function t(e) {
 return e && void 0 !== e.child_mac_rule_info ? e : {
 child_mac_rule_info: """"
 }
 }
 return s(arguments, {}, e, t, null, !1)
 }


 function rr() {
 function e(e, t) {
 return {
 isTest: oi,
 goformId: ""CHILD_MAC_RULE_DELETE"",
 mac_addr: e.mac
 }
 }


 function t(e) {
 return e && ""success"" == e.result ? e : si
 }
 return s(arguments, 0 == n.currentUserInChildGroup ? {} : {
 errorType: ""no_auth""
 }, e, t, null, !0)
 }


 function _r() {
 function e(e, t) {
 return {
 isTest: oi,
 goformId: ""CHILD_MAC_RULE_ADD"",
 child_mac_rule_info: e.child_mac_rule_info
 }
 }


 function t(e) {
 return e && ""success"" == e.result ? e : si
 }
 return s(arguments, 0 == n.currentUserInChildGroup ? {} : {
 errorType: ""no_auth""
 }, e, t, null, !0)
 }


 function ir() {
 function e(e, t) {
 return {
 isTest: oi,
 goformId: ""CHILD_MAC_RULE_UPDATE"",
 mac_addr: e.mac_addr,
 child_mac_rule_info: e.child_mac_rule_info
 }
 }


 function t(e) {
 return e && ""success"" == e.result ? e : si
 }
 return s(arguments, 0 == n.currentUserInChildGroup ? {} : {
 errorType: ""no_auth""
 }, e, t, null, !0)
 }


 function sr() {
 return hr({
 nv: ""get_user_mac_addr""
 }, arguments[1], arguments[2])
 }


 function or() {
 return sr({}).get_user_mac_addr || sr({}).user_mac_addr
 }


 function ar() {
 function e(e, t) {
 return {
 isTest: oi,
 cmd: ""hostNameList""
 }
 }


 function t(e) {
 return e && (e.hostNameList || e.devices) ? oi ? e.hostNameList : e : {
 devices: []
 }
 }
 return s(arguments, {}, e, t, null, !1)
 }


 function ur() {
 function e(e, t) {
 return {
 isTest: oi,
 goformId: ""EDIT_HOSTNAME"",
 mac: e.mac,
 hostname: e.hostname
 }
 }


 function t(e) {
 return e && ""success"" == e.result ? e : si
 }
 return s(arguments, {}, e, t, null, !0)
 }


 function cr() {
 function e(e, t) {
 return {
 isTest: oi,
 cmd: ""site_white_list""
 }
 }


 function t(e) {
 return e && (e.site_white_list || e.siteList) ? oi ? e.site_white_list : e : {
 siteList: []
 }
 }
 return s(arguments, {}, e, t, null, !1)
 }


 function dr() {
 function e(e, t) {
 return {
 isTest: oi,
 goformId: ""REMOVE_WHITE_SITE"",
 ids: e.ids.join("","")
 }
 }


 function t(e) {
 return e && ""success"" == e.result ? e : si
 }
 return s(arguments, 0 == n.currentUserInChildGroup ? {} : {
 errorType: ""no_auth""
 }, e, t, null, !0)
 }


 function lr() {
 function e(e, t) {
 return {
 isTest: oi,
 goformId: ""ADD_WHITE_SITE"",
 name: e.name,
 site: e.site
 }
 }


 function t(e) {
 return e && ""success"" == e.result ? e : si
 }
 return s(arguments, 0 == n.currentUserInChildGroup ? {} : {
 errorType: ""no_auth""
 }, e, t, null, !0)
 }


 function pr() {
 function t(e, t) {
 return {
 isTest: oi,
 cmd: ""time_limited""
 }
 }


 function n(e) {
 return e ? r(e) : _
 }


 function r(t) {
 if ("""" == t.time_limited) return {
 time_limited: []
 };
 var n = t.time_limited.split("";"");
 return e.each(n, function(e) {
 var t = e.split(""+"");
 2 == t.length && (_[t[0]] = t[1].split("",""))
 }), _
 }
 var _ = {
 0: [],
 1: [],
 2: [],
 3: [],
 4: [],
 5: [],
 6: []
 };
 return s(arguments, {}, t, n, null, !1)
 }


 function mr() {
 function e(e, t) {
 return {
 isTest: oi,
 goformId: ""SAVE_TIME_LIMITED"",
 time_limited: e.time
 }
 }


 function t(e) {
 return e && ""success"" == e.result ? e : si
 }
 return s(arguments, 0 == n.currentUserInChildGroup ? {} : {
 errorType: ""no_auth""
 }, e, t, null, !0)
 }


 function fr() {
 function e(e, t) {
 return {
 isTest: oi,
 cmd: ""web_wake_switch,web_sleep_switch,web_wake_time,web_sleep_time"",
 multi_data: ""1""
 }
 }


 function t(e) {
 if (e) {
 if (-1 != e.web_wake_time.indexOf("":"")) {
 var t = e.web_wake_time.split("":"");
 e.openH = leftInsert(t[0], 2, ""0""), e.openM = leftInsert(t[1], 2, ""0"")
 } else e.openH = ""06"", e.openM = ""00"";
 if (-1 != e.web_sleep_time.indexOf("":"")) {
 var n = e.web_sleep_time.split("":"");
 e.closeH = leftInsert(n[0], 2, ""0""), e.closeM = leftInsert(n[1], 2, ""0"")
 } else e.closeH = ""22"", e.closeM = ""00"";
 return e
 }
 return si
 }
 return s(arguments, {}, e, t, null, !1)
 }


 function gr() {
 function e(e, t) {
 var n = {
 isTest: oi,
 goformId: ""SAVE_TSW"",
 web_wake_switch: e.openEnable,
 web_sleep_switch: e.closeEnable
 };
 return ""1"" == e.openEnable && (n.web_wake_time = e.openTime, n.web_sleep_time = e.closeTime), n
 }


 function t(e) {
 return e && ""success"" == e.result ? e : si
 }
 return s(arguments, {}, e, t, null, !0)
 }


 function vr() {
 function e(e, t) {
 return {
 isTest: oi,
 cmd: ""systime_mode,syn_done,nitz_sync_flag"",
 multi_data: ""1""
 }
 }


 function t(e) {
 return !e || ""sntp"" != e.systime_mode && ""nitz"" != e.systime_mode && ""manual"" != e.systime_mode && ""1"" != e.syn_done && ""1"" != e.nitz_sync_flag ? {
 result: !1
 } : {
 result: !0
 }
 }
 return s(arguments, {}, e, t, null, !1)
 }


 function wr() {
 function e(e, t) {
 return {
 isTest: oi,
 goformId: ""FLOW_CALIBRATION_MANUAL"",
 calibration_way: e.way,
 time: ""time"" == e.way ? e.value : 0,
 data: ""data"" == e.way ? e.value : 0
 }
 }


 function t(e) {
 return e && ""success"" == e.result ? e : si
 }
 return s(arguments, {}, e, t, null, !0)
 }


 function hr() {
 function t(t, n) {
 var r = {};
 return r.isTest = oi, e.isArray(t.nv) ? (r.cmd = t.nv.join("",""), r.multi_data = 1) : r.cmd = t.nv, r
 }


 function n(e) {
 return e || si
 }
 return s(arguments, {}, t, n, null, !1)
 }


 function Sr() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.cmd = ""vwim_mc_state,traffic_overrun,detect_new_version"", n.multi_data = 1, n
 }


 function t(e) {
 if (e) {
 var t = {};
 return t.vwim_mc_state = e.vwim_mc_state, t.traffic_overrun = e.traffic_overrun, t.detect_new_version = e.detect_new_version, t.opms_wan_mode = ""AUTO"" == ci.opms_wan_mode ? ci.opms_wan_auto_mode : ci.opms_wan_mode, t
 }
 return si
 }
 return s(arguments, {}, e, t, null, !1)
 }


 function Tr() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.goformId = ""CLEAR_REDIRECT_FLAG"", n.flag_id = e.redirectFlags, n
 }


 function t(e) {
 return e || si
 }
 return s(arguments, {}, e, t, null, !0)
 }


 function Pr() {
 function e(e, n) {
 return t.extend({
 goformId: ""DHCP_RESERVATION_TO_STATIC"",
 isTest: oi
 }, e)
 }


 function n(e) {
 return e || si
 }
 return s(arguments, {}, e, n, null, !0)
 }


 function Ir() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.cmd = ""host_name_web,mac_addr_web,ip_addr_web,lan_ipaddr,lan_netmask"", n.multi_data = 1, n
 }


 function t(e) {
 if (e) {
 var t = {};
 return t.ipAddress = e.lan_ipaddr, t.subnetMask = e.lan_netmask, t.host_name_web = e.host_name_web, t.mac_addr_web = e.mac_addr_web, t.ip_addr_web = e.ip_addr_web, t
 }
 return si
 }
 return s(arguments, {}, e, t, null, !1)
 }


 function br(e, n) {
 function r(e) {
 return t.extend({
 isTest: oi
 }, e)
 }


 function _(e) {
 return e && ""success"" == e.result ? e : si
 }
 return s(arguments, {}, r, _, null, !0)
 }


 function Ar() {
 function e(e, t) {
 return {
 isTest: oi,
 cmd: ""current_static_addr_list""
 }
 }


 function t(e) {
 var t = [];
 if (e) {
 if (null == e.current_static_addr_list || """" == e.current_static_addr_list) return {
 StaticAddressFilterRules: []
 };
 for (var n = e.current_static_addr_list, r = 0; r < n.length; r++) {
 var _ = {};
 _.index = r, _.hostName = n[r].hostname, _.macAddress = n[r].mac, _.ipAddress = n[r].ip, _.domainName = n[r].domain, t.push(_)
 }
 return {
 StaticAddressFilterRules: t
 }
 }
 return si
 }
 return s(arguments, {}, e, t, null, !1)
 }


 function yr() {
 function e(e, t) {
 return {
 isTest: oi,
 cmd: ""current_static_addr_list""
 }
 }


 function t(e) {
 if (e) {
 var t = {};
 if (null == e.current_static_addr_list || """" == e.current_static_addr_list) t.bindStaticIPInfo = [];
 else {
 for (var n = e.current_static_addr_list, r = [], _ = 0; _ < n.length; _++) r.push(n[_].ip);
 t.bindStaticIPInfo = r
 }
 return t
 }
 return si
 }
 return s(arguments, {}, e, t, null, !1)
 }


 function Er() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.cmd = ""mac_ip_status"", n.multi_data = 1, n
 }


 function t(e) {
 if (e) {
 var t = {};
 return t.mac_ip_status = ""1"" == e.mac_ip_status ? ""1"" : ""0"", t
 }
 return si
 }
 return s(arguments, {}, e, t, null, !1)
 }


 function Rr(e, n) {
 function r(e) {
 return t.extend({
 isTest: oi
 }, e)
 }


 function _(e) {
 return e && ""success"" == e.result ? e : si
 }
 return s(arguments, {}, r, _, null, !0)
 }


 function Nr() {
 function e(e) {
 return t.extend({
 goformId: ""WIFI_SPOT_PROFILE_UPDATE"",
 isTest: oi
 }, e)
 }


 function n(e) {
 return e || si
 }
 return s(arguments, {}, e, n, null, !0)
 }


 function Mr() {
 function e(e, t) {
 return {
 isTest: oi,
 multi_data: 1,
 cmd: ""wifi_profile,wifi_profile1,wifi_profile2,wifi_profile3,wifi_profile4,wifi_profile5,wifi_profile_num""
 }
 }


 function t(e) {
 return e || si
 }
 return s(arguments, {}, e, t, null, !1)
 }


 function Dr() {
 function e(e) {
 return t.extend({
 goformId: ""SET_NV"",
 isTest: oi
 }, e)
 }


 function n(e) {
 return e || si
 }
 return s(arguments, {}, e, n, null, !0)
 }


 function Cr() {
 function e(e) {
 return {
 goformId: ""SET_WIFI_BAND"",
 isTest: oi,
 wifiEnabled: e.wifiEnabled,
 wifi_band: e.wifi_band
 }
 }


 function t(e) {
 return e || si
 }
 Je(arguments, e, t)
 }


 function kr() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.cmd = ""stk_write_flag"", n
 }


 function t(e) {
 if (e) {
 var t = {};
 return t.stk_write_flag = e.stk_write_flag, t
 }
 return si
 }
 return s(arguments, {}, e, t, null, !1)
 }


 function Fr() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.cmd = ""stk"", n
 }


 function t(e) {
 if (e) {
 var t = {};
 return t.stk = e.stk, t
 }
 return si
 }
 return s(arguments, {}, e, t, null, !1)
 }


 function Wr() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.cmd = ""stk_menu"", n
 }


 function t(e) {
 if (e) {
 var t = {};
 return t.stk_menu = e.stk_menu, t
 }
 return si
 }
 return s(arguments, {}, e, t, null, !1)
 }


 function xr() {
 function e(e, t) {
 var n = {};
 return n.goformId = ""STK_PROCESS"", n.isTest = oi, n.operator = e.operator, n.item_no = e.item_no, n.stk_content = e.stk_content, n.stk_encode_type = e.stk_encode_type, n
 }


 function t(e) {
 return e || si
 }
 return s(arguments, {}, e, t, null, !0)
 }


 function Lr(e, n) {
 function r(e) {
 return t.extend({
 isTest: oi
 }, e)
 }


 function _(e) {
 return e ? {
 sntp_dst_start: e.sntp_dst_start,
 sntp_dst_end: e.sntp_dst_end,
 sntp_dst_bias: e.sntp_dst_bias
 } : si
 }
 return s(arguments, {}, r, _, null, !0)
 }


 function Or(e, n) {
 function r(e, n) {
 return t.extend({
 goformId: ""SET_BIND_STATIC_ADDRESS"",
 isTest: oi
 }, e)
 }


 function _(e) {
 return e || si
 }
 return s(arguments, {}, r, _, null, !0)
 }


 function Ur() {
 function e(e) {
 return {
 goformId: ""REDIRECT_REDIRECT_OFF""
 }
 }


 function t(e) {
 return e || si
 }
 Je(arguments, e, t)
 }


 function Br() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.cmd = ""SleepStatusForSingleChipCpe"", n
 }


 function t(e) {
 return e ? (e.curSleepStatus = ""1"" == e.SleepStatusForSingleChipCpe ? ""1"" : ""2"", e) : si
 }
 return s(arguments, {}, e, t, null, !1)
 }


 function Vr() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.goformId = ""SET_PRIVACY_NOTICE"", n.privacy_read_flag = e.privacy_read_flag, n
 }


 function t(e) {
 return e && ""success"" == e.result ? e : si
 }
 return s(arguments, {}, e, t, null, !0)
 }


 function Hr() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.cmd = ""modem_main_state,ppp_status,ipsec_status,RadioOff,puknumber,pinnumber,m_ssid_enable,HideSSID,m_HideSSID,wifi_start_fail,wifi_chip1_ssid1_wifi_coverage,NoForwarding,m_NoForwarding,wan_apn,monthly_tx_bytes,monthly_rx_bytes,station_mac,opms_wan_mode,opms_wan_auto_mode,ACL_mode,network_type,ppp_dial_fail_times,RemoteManagement,WANPingFilter,dhcpEnabled,pdp_type,prefer_dns_manual,standby_dns_manual,ipv6_prefer_dns_manual,ipv6_standby_dns_manual,web_wake_switch,upnpEnabled,prefer_dns_auto,standby_dns_auto,static_wan_primary_dns,static_wan_secondary_dns,apn_mode,ipv6_prefer_dns_auto,ipv6_standby_dns_auto,IPPortFilterEnable,DefaultFirewallPolicy,PortForwardEnable,wifi_anti_brute_force_attack_func,guest_ssid_router_enable,dns_mode,ipv6_dns_mode"", n.multi_data = 1, n
 }


 function t(e) {
 return """" == e || ""0.0.0.0"" == e || ""::0"" == e
 }


 function n(e) {
 if (e) {
 var n = {};
 return n.simCardStatus = e.modem_main_state, n.networkStatus = e.ppp_status, n.wifiSwitch = e.RadioOff, n.puknumber = e.puknumber, n.pinnumber = e.pinnumber, n.m_ssid_enable = e.m_ssid_enable, n.HideSSID = e.HideSSID, n.m_HideSSID = e.m_HideSSID, n.wifiDriverNormal = e.wifi_start_fail, n.wifi_coverage = e.wifi_chip1_ssid1_wifi_coverage, n.NoForwarding = e.NoForwarding, n.m_NoForwarding = e.m_NoForwarding, n.wanAPN = e.wan_apn, n.monthlySent = """" == e.monthly_tx_bytes ? 0 : e.monthly_tx_bytes, n.monthlyReceived = """" == e.monthly_rx_bytes ? 0 : e.monthly_rx_bytes, n.curr_connected_devices = e.station_mac && """" != e.station_mac ? e.station_mac.split("";"") : [], n.currMode = e.opms_wan_mode, n.networkType = e.network_type, n.ACL_mode = e.ACL_mode, -1 != n.networkType.toLowerCase().indexOf(""limited_service"") || -1 != n.networkType.toLowerCase().indexOf(""limited service"") ? n.networkType = ""limited_service"" : -1 == n.networkType.toLowerCase().indexOf(""no_service"") && -1 == n.networkType.toLowerCase().indexOf(""no service"") || (n.networkType = ""no_service""), n.connectFailCount = e.ppp_dial_fail_times, n.remoteFlag = e.RemoteManagement, n.pingFlag = e.WANPingFilter, n.dhcpEnabled = e.dhcpEnabled, ""PPP"" == e.opms_wan_mode || ""AUTO"" == e.opms_wan_mode && ""AUTO_LTE_GATEWAY"" == e.opms_wan_auto_mode ? ""ip"" == e.pdp_type.toLowerCase() ? ""auto"" == e.dns_mode ? n.dnsDataIsError = t(e.prefer_dns_auto) && t(e.standby_dns_auto) : n.dnsDataIsError = !1 : ""ipv6"" == e.pdp_type.toLowerCase() ? ""auto"" == e.ipv6_dns_mode ? n.dnsDataIsError = t(e.ipv6_prefer_dns_auto) && t(e.ipv6_standby_dns_auto) : n.dnsDataIsError = !1 : ""auto"" == e.dns_mode ? n.dnsDataIsError = t(e.prefer_dns_auto) && t(e.standby_dns_auto) && t(e.ipv6_prefer_dns_auto) && t(e.ipv6_standby_dns_auto) : n.dnsDataIsError = !1 : ""DHCP"" == e.opms_wan_mode || ""AUTO"" == e.opms_wan_mode && ""AUTO_DHCP"" == e.opms_wan_auto_mode ? n.dnsDataIsError = t(e.prefer_dns_auto) && t(e.standby_dns_auto) : ""PPPOE"" == e.opms_wan_mode || ""AUTO"" == e.opms_wan_mode && ""AUTO_PPPOE"" == e.opms_wan_auto_mode ? n.dnsDataIsError = t(e.prefer_dns_auto) && t(e.standby_dns_auto) : n.dnsDataIsError = !1, n.wifiAwakeSwitch = """" == e.web_wake_switch ? ""0"" : e.web_wake_switch, n.upnpSwitch = e.upnpEnabled, n.portFilterEnable = e.IPPortFilterEnable, n.defaultPolicy = e.DefaultFirewallPolicy, n.PortForwardEnable = e.PortForwardEnable, n.antiVioCraEnable = e.wifi_anti_brute_force_attack_func, n.guestRouterEnable = e.guest_ssid_router_enable, n
 }
 return si
 }
 return s(arguments, {}, e, n, null, !1)
 }


 function Gr() {
 function e(e, t) {
 return {
 isTest: oi,
 cmd: ""queryDeviceAccessControlList""
 }
 }


 function t(e) {
 if (e) {
 var t = {};
 return t.aclMode = e.AclMode, t.WhiteMacList = e.WhiteMacList, t.BlackMacList = e.BlackMacList, t.WhiteNameList = e.WhiteNameList, t.BlackNameList = e.BlackNameList, t.wifiMacWhiteList = e.WhiteMacList, t.wifiMacBlackList = e.BlackMacList, t.wifiHostnameWhiteList = e.WhiteNameList, t.wifiHostnameBlackList = e.BlackNameList, t
 }
 return si
 }
 return s(arguments, {}, e, t, null, !1)
 }


 function Kr() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.cmd = ""thermal_control_enable,thermal_led_enable"", n.multi_data = 1, n
 }


 function t(e) {
 if (e) {
 var t = {};
 return t.thermal_control_enable = ""1"" == e.thermal_control_enable ? ""1"" : ""0"", t.thermal_led_enable = e.thermal_led_enable, t
 }
 return si
 }
 return s(arguments, {}, e, t, null, !1)
 }


 function zr() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.goformId = ""SET_THERMAL_CONTROL"", n.thermal_control_enable = e.thermal_control_enable, n.thermal_led_enable = e.thermal_led_enable, n
 }


 function t(e) {
 return e && ""success"" == e.result ? e : si
 }
 return s(arguments, {}, e, t, null, !0)
 }


 function Xr() {
 function e(e, t) {
 return {
 isTest: oi,
 multi_data: ""1"",
 cmd: ""DIAG_URL,DIAG_CHECK,traceroute_flag""
 }
 }


 function t(e) {
 return e ? {
 IpUrl: e.DIAG_URL,
 CheckPingMode: e.DIAG_CHECK,
 traceroute_flag: e.traceroute_flag
 } : si
 }
 return s(arguments, {}, e, t, null, !1)
 }


 function jr(e, n) {
 function r(e) {
 return t.extend({
 isTest: oi
 }, e)
 }


 function _(e) {
 return e && ""success"" == e.result ? e : si
 }
 return s(arguments, {}, r, _, null, !0)
 }


 function qr() {
 function e(e, t) {
 return {
 isTest: oi,
 cmd: ""night_mode_switch,night_mode_start_time,night_mode_end_time,night_mode_close_all_led"",
 multi_data: ""1""
 }
 }


 function t(e) {
 if (e) {
 if (-1 != e.night_mode_start_time.indexOf("":"")) {
 var t = e.night_mode_start_time.split("":"");
 e.openH = leftInsert(t[0], 2, ""0""), e.openM = leftInsert(t[1], 2, ""0"")
 } else e.openH = ""22"", e.openM = ""00"";
 if (-1 != e.night_mode_end_time.indexOf("":"")) {
 var n = e.night_mode_end_time.split("":"");
 e.closeH = leftInsert(n[0], 2, ""0""), e.closeM = leftInsert(n[1], 2, ""0"")
 } else e.closeH = ""07"", e.closeM = ""00"";
 return e
 }
 return si
 }
 return s(arguments, {}, e, t, null, !1)
 }


 function Zr() {
 function e(e, t) {
 var n = {
 isTest: oi,
 goformId: ""SET_DEVICE_LED"",
 night_mode_switch: e.sleepProtectionEnable
 };
 return ""1"" == e.sleepProtectionEnable && (n.night_mode_start_time = e.openTime, n.night_mode_end_time = e.closeTime, n.night_mode_close_all_led = e.night_mode_close_all_led), n
 }


 function t(e) {
 return e && ""success"" == e.result ? e : si
 }
 return s(arguments, {}, e, t, null, !0)
 }


 function Yr() {
 function e(e, t) {
 return {
 isTest: oi,
 multi_data: ""1"",
 cmd: ""reboot_timeframe_hours1,reboot_timeframe_hours2,reboot_dow,reboot_dod,reboot_schedule_enable,reboot_schedule_mode,reboot_hour1,reboot_min1,reboot_hour2,reboot_min2""
 }
 }


 function t(e) {
 return e ? {
 reboot_dow: e.reboot_dow,
 reboot_dod: e.reboot_dod,
 reboot_schedule_enable: e.reboot_schedule_enable,
 reboot_schedule_mode: e.reboot_schedule_mode,
 reboot_hour1: e.reboot_hour1,
 reboot_min1: e.reboot_min1,
 reboot_hour2: e.reboot_hour2,
 reboot_min2: e.reboot_min2,
 reboot_threshold_hours1: e.reboot_timeframe_hours1,
 reboot_threshold_hours2: e.reboot_timeframe_hours2
 } : si
 }
 return s(arguments, {}, e, t, null, !1)
 }


 function Qr(e, n) {
 function r(e) {
 return t.extend({
 isTest: oi
 }, e)
 }


 function _(e) {
 return e && ""success"" == e.result ? e : si
 }
 return s(arguments, {}, r, _, null, !0)
 }


 function Jr() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.cmd = ""queryWiFiModuleSwitch"", n
 }


 function t(e) {
 if (e) {
 var t = {};
 return t.WiFiModuleSwitch = """" == e.WiFiModuleSwitch ? ""0"" : e.WiFiModuleSwitch, t
 }
 return si
 }
 return s(arguments, {}, e, t, null, !1)
 }


 function $r() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.cmd = ""queryAccessPointInfo"", n
 }


 function t(e) {
 if (e) {
 return e.ResponseList
 }
 return si
 }
 return s(arguments, {}, e, t, null, !1)
 }


 function e_() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.cmd = ""queryWiFiGuestLeftTime"", n
 }


 function t(e) {
 if (e) {
 var t = {};
 return t.WiFiGuestLeftTime = e.WiFiGuestLeftTime, t
 }
 return si
 }
 return s(arguments, {}, e, t, null, !1)
 }


 function t_() {
 function t(e, t) {
 var n = {};
 return n.isTest = oi, n.cmd = ""queryWpsStatus"", n
 }


 function n(t) {
 if (t) {
 var n = t.ResponseList;
 return e.map(n, function(e, t) {
 e.ChipIndex = e.ChipIndex, e.ActiveWpsAccessPointIndex = e.ActiveWpsAccessPointIndex, e.WpsStatus = e.WpsStatus, e.WpsMode = e.WpsMode
 }), n
 }
 return si
 }
 return s(arguments, {}, t, n, null, !1)
 }


 function n_() {
 function e(e) {
 var r = {
 goformId: void 0 !== e.goformId ? e.goformId : ""setAccessPointInfo"",
 isTest: oi,
 ChipIndex: e.ChipIndex,
 AccessPointIndex: e.AccessPointIndex,
 QrImageShow: e.QrImageShow,
 lan_sec_ssid_control: e.lan_sec_ssid_control,
 wifi_syncparas_flag: e.wifi_syncparas_flag
 };
 return 0 == e.ChipIndex && 1 == e.AccessPointIndex && (r = t.extend(r, {
 GuestSSIDActiveTime: e.GuestSSIDActiveTime
 })), e.AccessPointSwitchStatus != e.originAccessPointSwitchStatus ? r = t.extend(r, {
 AccessPointSwitchStatus: e.AccessPointSwitchStatus
 }) : (r = t.extend(r, {
 AccessPointSwitchStatus: e.AccessPointSwitchStatus,
 SSID: e.SSID,
 ApIsolate: e.ApIsolate,
 AuthMode: e.AuthMode,
 ApBroadcastDisabled: e.ApBroadcastDisabled
 }), ""WPAPSKWPA2PSK"" == e.AuthMode || ""WPA2PSK"" == e.AuthMode ? (r.EncrypType = e.cipher, r.Password = n.PASSWORD_ENCODE ? Base64.encode(e.Password) : e.Password) : r.EncrypType = ""NONE"", ""setAccessPointInfo_24G_5G"" == r.goformId && (r.SSID_CHIP1 = e.SSID + ""_5G"", r.wifi_syncparas_flag = e.wifi_syncparas_flag)), r
 }


 function r(e) {
 return e || si
 }
 Je(arguments, e, r)
 }


 function r_() {
 function e(e) {
 return {
 goformId: ""switchWiFiModule"",
 isTest: oi,
 SwitchOption: """" == e.SwitchOption ? ""0"" : e.SwitchOption
 }
 }


 function t(e) {
 return e || si
 }
 Je(arguments, e, t)
 }


 function __() {
 function e(e) {
 var t = {
 goformId: ""setWiFiChipAdvancedInfo24G_5G"",
 isTest: oi,
 ChipIndex: e.ChipIndex,
 WirelessMode: e.WirelessMode,
 CountryCode: e.CountryCode,
 Channel: e.Channel,
 WirelessMode_5G: e.WirelessMode_5G,
 CountryCode_5G: e.CountryCode_5G,
 Channel_5G: e.Channel_5G,
 ApMaxStationNumber: e.ApMaxStationNumber
 };
 return n.WIFI_BANDWIDTH_SUPPORT && (t.BandWidth = e.BandWidth, t.BandWidth_5G = e.BandWidth_5G), n.WIFI_BAND_SUPPORT && (t.Band = e.Band, t.Band_5G = e.Band_5G), n.WIFI_BAND_SUPPORT && ""a"" == e.wifiBand || (t.abg_rate = e.rate), t
 }


 function t(e) {
 return e || si
 }
 Je(arguments, e, t)
 }


 function i_() {
 function e(e) {
 var t = {
 goformId: ""setWiFiChipAdvancedInfo"",
 isTest: oi,
 ChipIndex: e.ChipIndex,
 WirelessMode: e.WirelessMode,
 CountryCode: e.CountryCode,
 Channel: e.Channel
 };
 return n.WIFI_BANDWIDTH_SUPPORT && (t.BandWidth = e.BandWidth), n.WIFI_BAND_SUPPORT && (t.Band = e.Band), n.WIFI_BAND_SUPPORT && ""a"" == e.wifiBand || (t.abg_rate = e.rate), t
 }


 function t(e) {
 return e || si
 }
 Je(arguments, e, t)
 }


 function s_() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.goformId = ""startWps"", n.ChipIndex = e.ChipIndex, n.ActiveWpsAccessPointIndex = e.ActiveWpsAccessPointIndex, n.WpsMode = e.WpsMode, ""PIN"" == n.WpsMode && (n.WpsPin = e.WpsPin), n
 }


 function t(e) {
 return e || si
 }
 return s(arguments, {}, e, t, null, !0)
 }


 function o_() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.cmd = ""queryDeviceAccessControlList"", n
 }


 function t(e) {
 if (e) {
 var t = {};
 return t.aclMode = e.AclMode, t.wifiMacWhiteList = e.WhiteMacList, t.wifiMacBlackList = e.BlackMacList, t.wifiHostnameWhiteList = e.WhiteNameList, t.wifiHostnameBlackList = e.BlackNameList, t
 }
 return si
 }
 return s(arguments, {}, e, t, null, !1)
 }


 function a_() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.cmd = ""wifi_anti_brute_force_attack_func"", n.multi_data = 1, n
 }


 function t(e) {
 if (e) {
 var t = {};
 return t.prevent_attack_enable = e.wifi_anti_brute_force_attack_func, t
 }
 return si
 }
 return s(arguments, {}, e, t, null, !1)
 }


 function u_() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.goformId = ""setDeviceAccessControlList"", n.AclMode = e.aclMode, n.WhiteMacList = e.wifiMacWhiteList, n.BlackMacList = e.wifiMacBlackList, n.WhiteNameList = e.wifiHostnameWhiteList, n.BlackNameList = e.wifiHostnameBlackList, n
 }


 function t(e) {
 return e || si
 }
 return s(arguments, {}, e, t, null, !0)
 }


 function c_() {
 return hr({
 nv: [""user_ip_addr""]
 }, arguments[1], arguments[2])
 }


 function d_() {
 function e(e) {
 return {
 goformId: ""setDeviceAccessControlList"",
 isTest: oi,
 AclMode: e.AclMode,
 WhiteMacList: e.WhiteMacList,
 BlackMacList: e.BlackMacList,
 WhiteNameList: e.WhiteNameList,
 BlackNameList: e.BlackNameList
 }
 }


 function t(e) {
 return e && ""success"" == e.result ? e : si
 }
 return s(arguments, {}, e, t, null, !0)
 }


 function l_() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.cmd = ""vpn_type,vpn_l2tp_passwd,vpn_account,vpn_passwd,vpn_server_ip,vpn_conn_status,vpn_auto_start,vpn_remote_ip,vpn_local_ip"", n.multi_data = 1, n
 }


 function t(e) {
 return e ? {
 vpn_type: e.vpn_type,
 vpn_l2tp_passwd: e.vpn_l2tp_passwd,
 vpn_account: e.vpn_account,
 vpn_passwd: e.vpn_passwd,
 vpn_server_ip: e.vpn_server_ip,
 vpn_conn_status: e.vpn_conn_status,
 vpn_auto_start: e.vpn_auto_start,
 vpn_remote_ip: e.vpn_remote_ip,
 vpn_local_ip: e.vpn_local_ip
 } : si
 }
 return s(arguments, {}, e, t, null, !1)
 }


 function p_() {
 function e(e, n) {
 var r = {
 goformId: ""VPN_CLIENT_SET"",
 vpn_type: e.vpn_type,
 vpn_account: e.vpn_account,
 vpn_passwd: e.vpn_passwd,
 vpn_server_ip: e.vpn_server_ip,
 vpn_auto_start: e.vpn_auto_start,
 isTest: oi
 };
 return ""L2TP"" == e.vpn_type && t.extend(r, {
 vpn_l2tp_passwd: e.vpn_l2tp_passwd
 }), r
 }


 function n(e) {
 return e || si
 }
 return s(arguments, {}, e, n, null, !0)
 }


 function m_() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.notCallback = !0, n.goformId = ""VPN_CONNECT"", n
 }


 function t(e) {
 ""success"" == e.result ? (_ = (new Date).getTime(), U(n)) : r({
 result: !1
 })
 }


 function n(e) {
 ""connecting"" == e.vpn_conn_status ? ci.vpn_conn_status = ""connecting"" : checkVpnConnectedStatus(e.vpn_conn_status) ? (B(n), ci.vpn_conn_status = ""connected"", r({
 result: !0,
 status: ci.connectStatus
 })) : (new Date).getTime() - _ < 1e4 ? ci.vpn_conn_status = ""connecting"" : (B(n), r({
 result: !1
 }))
 }
 var r = arguments[1],
 _ = 0;
 return s(arguments, {}, e, t, null, !0)
 }


 function f_() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.notCallback = !0, n.goformId = ""VPN_DISCONNECT"", n
 }


 function t(e) {
 ""success"" == e.result ? (_ = (new Date).getTime(), U(n)) : r({
 result: !1
 })
 }


 function n(e) {
 ""disconnecting"" == e.vpn_conn_status ? ci.vpn_conn_status = ""disconnecting"" : ""disconnected"" == e.vpn_conn_status ? (B(n), ci.vpn_conn_status = ""disconnected"", r({
 result: !0,
 status: ci.vpn_conn_status
 })) : (new Date).getTime() - _ < 1e4 ? ci.vpn_conn_status = ""disconnecting"" : (B(n), r({
 result: !1
 }))
 }
 var r = arguments[1],
 _ = 0;
 return s(arguments, {}, e, t, null, !0)
 }


 function g_() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.cmd = ""voice_work_type"", n.multi_data = 1, n
 }


 function t(e) {
 return e ? {
 voice_work_type: e.voice_work_type
 } : si
 }
 return s(arguments, {}, e, t, null, !1)
 }


 function v_() {
 function e(e, t) {
 return {
 goformId: ""VOIP_VOICE_WORK_TYPE_SET"",
 voice_work_type: e.voice_work_type,
 isTest: oi
 }
 }


 function t(e) {
 return e || si
 }
 return s(arguments, {}, e, t, null, !0)
 }


 function w_() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.goformId = ""TR069_MODULE_SET"", n.tr069_DataModule = e.tr069_DataModule, n
 }


 function t(e) {
 return e && ""success"" == e.result ? e : si
 }
 return s(arguments, {}, e, t, null, !0)
 }


 function h_() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.goformId = ""SIGNAL_QUALITY_DETECT_START"", n
 }


 function t(e) {
 return e && ""success"" == e.result ? e : si
 }
 return s(arguments, {}, e, t, null, !0)
 }


 function S_() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.goformId = ""SIGNAL_QUALITY_DETECT_CANCEL"", n
 }


 function t(e) {
 return e && ""success"" == e.result ? e : si
 }
 return s(arguments, {}, e, t, null, !0)
 }


 function T_() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.cmd = ""signal_detect_progress"", n.multi_data = 1, n
 }


 function t(e) {
 if (e) {
 var t = {};
 return t.signal_detect_progress = e.signal_detect_progress, t
 }
 return si
 }
 return s(arguments, {}, e, t, null, !1)
 }


 function P_() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.cmd = ""signal_detect_quality"", n.multi_data = 1, n
 }


 function t(e) {
 if (e) {
 var t = {};
 return t.signal_detect_quality = e.signal_detect_quality, t
 }
 return si
 }
 return s(arguments, {}, e, t, null, !1)
 }


 function I_() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.cmd = ""signal_detect_record_0,signal_detect_record_1,signal_detect_record_2,signal_detect_record_3,signal_detect_record_4,signal_detect_record_5,signal_detect_record_6,signal_detect_record_7,signal_detect_record_8,signal_detect_record_9"", n.multi_data = 1, n
 }


 function t(e) {
 return e || si
 }
 return s(arguments, {}, e, t, null, !1)
 }


 function b_() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.goformId = ""SIGNAL_QUALITY_RECORD_ADD"", n.index = e.index, n.date = e.date, n.location = e.location, n.quality = e.quality, n
 }


 function t(e) {
 return e && ""success"" == e.result ? e : si
 }
 return s(arguments, {}, e, t, null, !0)
 }


 function A_() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.goformId = ""SIGNAL_QUALITY_RECORD_DEL"", n.index = e.index, n
 }


 function t(e) {
 return e && ""success"" == e.result ? e : si
 }
 return s(arguments, {}, e, t, null, !0)
 }


 function y_() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.goformId = ""SIGNAL_QUALITY_RECORD_CLEAR"", n
 }


 function t(e) {
 return e && ""success"" == e.result ? e : si
 }
 return s(arguments, {}, e, t, null, !0)
 }


 function E_() {
 function e(e, t) {
 return {
 isTest: oi,
 cmd: ""wifi_chip_temp,therm_pa_level,therm_pa_frl_level,therm_tj_level,pm_sensor_pa1,pm_sensor_mdm,pm_modem_5g"",
 multi_data: 1
 }
 }


 function t(e) {
 return e || si
 }
 return s(arguments, {}, e, t, null, !1)
 }


 function R_() {
 function e(e) {
 var r = {
 goformId: e.goformId,
 isTest: oi,
 ChipIndex: e.ChipIndex,
 AccessPointIndex: e.AccessPointIndex,
 QrImageShow: e.QrImageShow,
 QrImageShow_5G: e.QrImageShow_5G,
 lan_sec_ssid_control: e.lan_sec_ssid_control,
 wifi_syncparas_flag: e.wifi_syncparas_flag
 };
 return e.AccessPointSwitchStatus != e.originAccessPointSwitchStatus ? r = t.extend(r, {
 AccessPointSwitchStatus: e.AccessPointSwitchStatus
 }) : (r = t.extend(r, {
 AccessPointSwitchStatus: e.AccessPointSwitchStatus,
 SSID: e.SSID,
 ApIsolate: e.ApIsolate,
 AuthMode: e.AuthMode,
 ApBroadcastDisabled: e.ApBroadcastDisabled
 }), ""WPAPSKWPA2PSK"" == e.AuthMode || ""WPA2PSK"" == e.AuthMode ? (r.EncrypType = e.cipher, r.Password = n.PASSWORD_ENCODE ? Base64.encode(e.Password) : e.Password) : r.EncrypType = ""NONE""), e.AccessPointSwitchStatus_5G != e.originAccessPointSwitchStatus_5G ? r = t.extend(r, {
 AccessPointSwitchStatus_5G: e.AccessPointSwitchStatus_5G
 }) : (r = t.extend(r, {
 AccessPointSwitchStatus_5G: e.AccessPointSwitchStatus_5G,
 SSID_5G: e.SSID_5G,
 ApIsolate_5G: e.ApIsolate_5G,
 AuthMode_5G: e.AuthMode_5G,
 ApBroadcastDisabled_5G: e.ApBroadcastDisabled_5G
 }), ""WPAPSKWPA2PSK"" == e.AuthMode_5G || ""WPA2PSK"" == e.AuthMode_5G ? (r.EncrypType_5G = e.cipher_5G, r.Password_5G = n.PASSWORD_ENCODE ? Base64.encode(e.Password_5G) : e.Password_5G) : r.EncrypType_5G = ""NONE""), r
 }


 function r(e) {
 return e || si
 }
 Je(arguments, e, r)
 }


 function N_() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.cmd = ""ant_switch_enable"", n.multi_data = 1, n
 }


 function t(e) {
 if (e) {
 var t = {};
 return t.ant_switch_enable = ""1"" == e.ant_switch_enable ? ""1"" : ""0"", t
 }
 return si
 }
 return s(arguments, {}, e, t, null, !1)
 }


 function M_() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.goformId = ""WAN_ANT_SWITCH_SET"", n.ant_switch_enable = e.ant_switch_enable, n
 }


 function t(e) {
 return e && ""success"" == e.result ? e : si
 }
 return s(arguments, {}, e, t, null, !0)
 }


 function D_() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.cmd = ""lte_band_lock,operate_mode,zte_voice_debug_ims_set,zte_voice_debug_voice_set,wifi_tputs_test_ip,wifi_tputs_test_mode,rf_mmw_status,mec_url,mec_port,mec_username,mec_password,mec_groupid,mec_alivePeriod,mec_status,mec_tls_en,mec_aes_key,mec_aes_iv,mec_enable,mec_sim_num,lte_band_lock,lte_freq_lock,lte_pci_lock,lte_earfcn_lock"", n.multi_data = 1, n
 }


 function t(e) {
 return e || si
 }
 return s(arguments, {}, e, t, null, !1)
 }


 function C_() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.goformId = ""BAND_SELECT"", n.is_gw_band = e.is_gw_band, n.gw_band_mask = e.gw_band_mask, n.is_lte_band = e.is_lte_band, n.lte_band_mask = e.lte_band_mask, n
 }


 function t(e) {
 return e || si
 }
 return s(arguments, {}, e, t, null, !0)
 }


 function k_() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.goformId = ""WAN_OPERATE_MODE_SET"", n.operate_mode = e.operate_mode, n
 }


 function t(e) {
 return e || si
 }
 return s(arguments, {}, e, t, null, !0)
 }


 function F_() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.goformId = ""VOICE_DEBUG_IMS_SET"", n.zte_voice_debug_ims_set = e.zte_voice_debug_ims_set, n
 }


 function t(e) {
 return e || si
 }
 return s(arguments, {}, e, t, null, !0)
 }


 function W_() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.goformId = ""VOICE_DEBUG_VOICE_SET"", n.zte_voice_debug_voice_set = e.zte_voice_debug_voice_set, n
 }


 function t(e) {
 return e || si
 }
 return s(arguments, {}, e, t, null, !0)
 }


 function x_() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.goformId = ""WLAN_TEST_TPUTS_SET"", n.wifi_tputs_test_ip = e.wifi_tputs_test_ip, n.wifi_tputs_test_mode = e.wifi_tputs_test_mode, n
 }


 function t(e) {
 return e || si
 }
 return s(arguments, {}, e, t, null, !0)
 }


 function L_() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.goformId = ""WAN_PERFORM_NR5G_BAND_LOCK"", n.nr5g_band_mask = e.nr5g_band_mask, n
 }


 function t(e) {
 return e || si
 }
 return s(arguments, {}, e, t, null, !0)
 }


 function O_() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.goformId = ""BSP_ANTENNA_STATE_SET"", n.antenna_name = e.antenna_name, n.state = e.state, n
 }


 function t(e) {
 return e || si
 }
 return s(arguments, {}, e, t, null, !0)
 }


 function U_() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.goformId = ""RF_MMW_DISABLE_SET"", n.rf_mmw_status = e.rf_mmw_status, n
 }


 function t(e) {
 return e || si
 }
 return s(arguments, {}, e, t, null, !0)
 }


 function B_() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.goformId = ""WAN_MBN_MODE_SET"", n.mbn_mode = e.mbn_mode, n
 }


 function t(e) {
 return e || si
 }
 return s(arguments, {}, e, t, null, !0)
 }


 function V_() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.goformId = ""MQTT_MEC_AES_SET"", n.mec_enable = e.mec_enable, ""1"" == e.mec_enable && (n.mec_url = e.mec_url, n.mec_port = e.mec_port, n.mec_username = e.mec_username, n.mec_password = e.mec_password, n.mec_groupid = e.mec_groupid, n.mec_alivePeriod = e.mec_alivePeriod, n.mec_tls_en = e.mec_tls_en, n.mec_aes_key = e.mec_aes_key, n.mec_aes_iv = e.mec_aes_iv, n.mec_sim_num = e.mec_sim_num), n
 }


 function t(e) {
 return e || si
 }
 return s(arguments, {}, e, t, null, !0)
 }


 function H_() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.cmd = ""net_link_detect_enable,net_link_detect_url,net_link_detect_time_gap,net_link_detect_ping_times,net_link_detect_timeout,watch_dog_reboot_enable"", n.multi_data = 1, n
 }


 function t(e) {
 if (e) {
 var t = {};
 return t.watchDogSetting = ""1"" == e.net_link_detect_enable ? ""1"" : ""0"", t.linkUrl = e.net_link_detect_url, t.net_link_detect_time_gap = e.net_link_detect_time_gap, t.net_link_detect_ping_times = e.net_link_detect_ping_times, t.net_link_detect_timeout = e.net_link_detect_timeout, t.watch_dog_reboot_enable = e.watch_dog_reboot_enable, t
 }
 return si
 }
 return s(arguments, {}, e, t, null, !1)
 }


 function G_() {
 function e(e, t) {
 var n = {};
 return n.notCallback = !0, n.goformId = ""WATCH_DOG_SWITCH"", n.isTest = oi, n.net_link_detect_enable = e.net_link_detect_enable, r = e.net_link_detect_enable, ""1"" == n.net_link_detect_enable && (n.net_link_detect_url = e.net_link_detect_url, n.net_link_detect_ping_times = e.net_link_detect_ping_times, n.net_link_detect_time_gap = e.net_link_detect_time_gap), n
 }


 function t(e) {
 e && ""success"" == e.result && ""1"" == r ? L(""check_watchdog_urlip_valid"", n) : _(e)
 }


 function n(e) {
 K_(e, _, K_)
 }
 var r, _ = arguments[1];
 return s(arguments, {}, e, t, null, !0)
 }


 function K_(e, t, n) {
 ""valid"" == e.check_watchdog_urlip_valid ? (O(""check_watchdog_urlip_valid"", n), t({
 result: ""success""
 })) : ""invalid"" == e.check_watchdog_urlip_valid && (O(""check_watchdog_urlip_valid"", n), t({
 result: ""failure""
 }))
 }


 function z_() {
 function e(e, t) {
 return {
 isTest: oi,
 cmd: ""nr5g_band_lock"",
 multi_data: 1
 }
 }


 function t(e) {
 return e || si
 }
 return s(arguments, {}, e, t, null, !1)
 }


 function X_() {
 function e(e) {
 return t.extend({
 goformId: ""WAN_PERFORM_NR5G_BAND_LOCK"",
 isTest: oi
 }, e)
 }


 function n(e) {
 return e || si
 }
 return s(arguments, {}, e, n, null, !0)
 }


 function j_() {
 function e(e, t) {
 return {
 isTest: oi,
 cmd: ""device_mode_get""
 }
 }


 function t(e) {
 if (e) {
 var t = {};
 return t.portMode = ""0"" == e.device_mode ? ""NORMAL"" : ""DEBUG"", t
 }
 return si
 }
 return s(arguments, {}, e, t, null, !1)
 }


 function q_() {
 function e(e) {
 return t.extend({
 goformId: ""DEVICE_MODE_SET"",
 isTest: oi
 }, e)
 }


 function n(e) {
 return e || si
 }
 return s(arguments, {}, e, n, null, !0)
 }


 function E_() {
 function e(e, t) {
 return {
 isTest: oi,
 cmd: ""wifi_chip_temp,therm_pa_level,therm_pa_frl_level,therm_tj_level,pm_sensor_pa1,pm_sensor_mdm,pm_modem_5g,wifi_temp_level_1,wifi_temp_level_2"",
 multi_data: 1
 }
 }


 function t(e) {
 return e || si
 }
 return s(arguments, {}, e, t, null, !1)
 }


 function Z_() {
 function e(e) {
 return t.extend({
 goformId: ""THERML_CONTROL_SWITCH_SET"",
 isTest: oi
 }, e)
 }


 function n(e) {
 return e || si
 }
 return s(arguments, {}, e, n, null, !0)
 }


 function Y_() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.goformId = ""USER_IMPROV_SET"", n.tr069_user_improv_flag = e.tr069_user_improv_flag, n
 }


 function t(e) {
 return e && ""success"" == e.result ? e : si
 }
 return s(arguments, {}, e, t, null, !0)
 }


 function Q_() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.cmd = ""dm_new_version,dm_description,ota_pkg_total_size"", n.multi_data = 1, n
 }


 function t(e) {
 if (e) {
 var t = {};
 return t.dm_new_version = e.dm_new_version, t.dm_description = e.dm_description, t.ota_pkg_total_size = e.ota_pkg_total_size, t
 }
 return si
 }
 return s(arguments, {}, e, t, null, !1)
 }


 function J_() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.cmd = ""wifi_pcie_powersave_enable"", n
 }


 function t(e) {
 if (e) {
 var t = {};
 return t.wifi_pcie_powersave_enable = ""1"" == e.wifi_pcie_powersave_enable ? ""1"" : ""0"", t
 }
 return si
 }
 return s(arguments, {}, e, t, null, !1)
 }


 function $_() {
 function e(e, t) {
 var n = {};
 return n.goformId = ""PCIE_POWERSAVE_SWITCH"", n.isTest = oi, n.wifi_pcie_powersave_enable = e.wifi_pcie_powersave_enable, n
 }


 function t(e) {
 return e || si
 }
 return s(arguments, {}, e, t, null, !0)
 }


 function ei() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.goformId = ""BSP_THERMAL_THERSH_SET"", n.sensor_id = e.sensor_id, n.thermal_type = e.thermal_type, n.v1 = 1e3 * e.v1, n.v2 = 1e3 * e.v2, n.v3 = 1e3 * e.v3, n
 }


 function t(e) {
 return e && ""success"" == e.result ? e : si
 }
 return s(arguments, {}, e, t, null, !0)
 }


 function ti() {
 function e(e, t) {
 return {
 isTest: oi,
 multi_data: 1,
 cmd: ""bsp_thermal_thersh_1,bsp_thermal_thersh_2,bsp_thermal_thersh_3,bsp_thermal_thersh_4,bsp_thermal_thersh_5,bsp_thermal_thersh_6,bsp_thermal_thersh_7,bsp_thermal_thersh_8,bsp_thermal_thersh_9""
 }
 }


 function t(e) {
 if (e) {
 var t = [],
 r = [];
 """" != e.bsp_thermal_thersh_1 && r.push(e.bsp_thermal_thersh_1), """" != e.bsp_thermal_thersh_2 && r.push(e.bsp_thermal_thersh_2), """" != e.bsp_thermal_thersh_3 && r.push(e.bsp_thermal_thersh_3), """" != e.bsp_thermal_thersh_4 && r.push(e.bsp_thermal_thersh_4), """" != e.bsp_thermal_thersh_5 && r.push(e.bsp_thermal_thersh_5), """" != e.bsp_thermal_thersh_6 && r.push(e.bsp_thermal_thersh_6), """" != e.bsp_thermal_thersh_7 && r.push(e.bsp_thermal_thersh_7), """" != e.bsp_thermal_thersh_8 && r.push(e.bsp_thermal_thersh_8), """" != e.bsp_thermal_thersh_9 && r.push(e.bsp_thermal_thersh_9);
 return t = n(r.join("";"")), {
 bspTcInfo: t
 }
 }
 return si
 }


 function n(e) {
 for (var t, n = /([^,;]*),([^,]*),([^,]*),([^,;]*),([^,;]*)/g, r = []; t = n.exec(e);) null != t && r.push({
 sensorId: t[1].replace(/\""/g, """"),
 thermalType: t[2].replace(/\D/g, """"),
 v1: parseInt(t[3], 10) / 1e3,
 v2: parseInt(t[4], 10) / 1e3,
 v3: parseInt(t[5], 10) / 1e3
 });
 return r
 }
 return s(arguments, {}, e, t, null, !1)
 }


 function O_() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.goformId = ""BSP_ANTENNA_STATE_SET"", n.antenna_name = e.antenna_name, n.state = e.state, n
 }


 function t(e) {
 return e || si
 }
 return s(arguments, {}, e, t, null, !0)
 }


 function ni() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.goformId = ""PS_NO_SERVICE_RESTART_SET"", n.ps_no_service_restart_flag = e.ps_no_service_restart_flag, n
 }


 function t(e) {
 return e || si
 }
 return s(arguments, {}, e, t, null, !0)
 }


 function ri() {
 function e(e) {
 return {
 isTest: oi,
 goformId: ""LTE_LOCK_CELL_SET"",
 lte_pci_lock: e.lte_pci_lock,
 lte_earfcn_lock: e.lte_earfcn_lock
 }
 }


 function t(e) {
 return e && ""success"" == e.result ? e : si
 }
 return s(arguments, {}, e, t, null, !0)
 }


 function _i() {
 function e(e, t) {
 var n = {};
 return n.isTest = oi, n.cmd = ""wifi_chip1_wps_state,wifi_chip2_wps_state"", n.multi_data = 1, n
 }


 function t(e) {
 if (e) {
 var t = {};
 return t.wifi_chip1_wps_state = e.wifi_chip1_wps_state, t.wifi_chip2_wps_state = e.wifi_chip2_wps_state, t
 }
 return si
 }
 return s(arguments, {}, e, t, null, !1)
 }
 var ii = window,
 si = {
 errorType: ""UnknownError"",
 errorId: ""123"",
 errorText: ""UnknownError""
 },
 oi = n.IS_TEST,
 ai = !0,
 ui = 0,
 ci = {
 networkType: """",
 signalImg: ""0"",
 spn_b1_flag: ""1"",
 spn_name_data: """",
 spn_b2_flag: ""1"",
 networkOperator: """",
 connectStatus: ""ppp_disconnected"",
 attachedDevices: [],
 curr_connected_devices: [],
 wifiSwitchStatus: """",
 data_counter: {
 uploadRate: 0,
 downloadRate: 0,
 totalSent: 0,
 totalReceived: 0,
 totalConnectedTime: 0,
 currentSent: 0,
 currentReceived: 0,
 currentConnectedTime: 0,
 monthlySent: 0,
 monthlyReceived: 0,
 monthlyConnectedTime: 0,
 month: """"
 },
 newSmsReceived: !1,
 smsReportReceived: !1,
 smsUnreadCount: ""0"",
 isLoggedIn: void 0,
 limitVolumeEnable: !1,
 limitVolumeType: ""1"",
 limitVolumePercent: ""100"",
 limitVolumeSize: ""0"",
 limitVolumeSizeSource: ""0"",
 allowRoamingUpdate: ""0"",
 opms_wan_mode: """",
 ap_station_enable: void 0,
 ap_station_mode: void 0,
 dialMode: """",
 is_night_mode: ""0"",
 wan_connect_status: """",
 battery_charg_type: """",
 external_charging_flag: """",
 mode_main_state: """"
 },
 di = [""modem_main_state"", ""pin_status"", ""opms_wan_mode"", ""opms_wan_auto_mode"", ""loginfo"", ""new_version_state"", ""current_upgrade_state"", ""is_mandatory"", ""wifi_dfs_status"", ""battery_value"", ""ppp_dial_conn_fail_counter"", ""dhcp_wan_status"", ""mdm_mcc"", ""mdm_mnc""],
 li = [""signalbar"", ""network_type"", ""network_provider"", ""battery_charg_type"", ""external_charging_flag"", ""mode_main_state"", ""battery_temp"", ""ppp_status"", ""EX_SSID1"", ""sta_ip_status"", ""EX_wifi_profile"", ""m_ssid_enable"", ""RadioOff"", ""wifi_onoff_state"", ""wifi_chip1_ssid1_ssid"", ""wifi_chip2_ssid1_ssid"", ""wifi_chip1_ssid1_access_sta_num"", ""wifi_chip2_ssid1_access_sta_num"", ""simcard_roam"", ""lan_ipaddr"", ""station_mac"", ""wifi_access_sta_num"", ""battery_charging"", ""battery_vol_percent"", ""battery_pers"", ""spn_name_data"", ""spn_b1_flag"", ""spn_b2_flag"", ""realtime_tx_bytes"", ""realtime_rx_bytes"", ""realtime_time"", ""realtime_tx_thrpt"", ""realtime_rx_thrpt"", ""monthly_rx_bytes"", ""monthly_tx_bytes"", ""monthly_time"", ""date_month"", ""data_volume_limit_switch"", ""data_volume_limit_size"", ""data_volume_alert_percent"", ""data_volume_limit_unit"", ""roam_setting_option"", ""upg_roam_switch"", ""ssid"", ""wifi_enable"", ""wifi_5g_enable"", ""check_web_conflict"", ""dial_mode"", ""ppp_dial_conn_fail_counter"", ""wan_lte_ca"", ""privacy_read_flag"", ""is_night_mode"", ""pppoe_status"", ""dhcp_wan_status"", ""static_wan_status"", ""vpn_conn_status"", ""wan_connect_status""];
 n.HAS_SMS && t.merge(li, [""sms_received_flag"", ""sts_received_flag"", ""sms_unread_num""]), n.HAS_MULTI_SSID && t.merge(li, [""wifi_chip1_ssid2_access_sta_num"", ""wifi_chip2_ssid2_access_sta_num""]);
 var pi = [],
 mi = [G];
 t(document).ready(function() {
 setTimeout(function() {
 W()
 }, n.IS_TEST ? 1e3 : 0)
 });
 var fi = {
 apn_interface_version: """",
 wifi_coverage: """",
 m_ssid_enable: """",
 imei: """",
 network_type: """",
 rssi: """",
 rscp: """",
 imsi: """",
 sim_imsi: """",
 cr_version: """",
 wa_version: """",
 hardware_version: """",
 web_version: """",
 wa_inner_version: """",
 MAX_Access_num: """",
 SSID1: """",
 AuthMode: """",
 WPAPSK1_encode: """",
 m_SSID: """",
 m_AuthMode: """",
 m_HideSSID: """",
 m_WPAPSK1_encode: """",
 m_MAX_Access_num: """",
 lan_ipaddr: """",
 mac_address: """",
 msisdn: """",
 LocalDomain: """",
 wan_ipaddr: """",
 static_wan_ipaddr: """",
 ipv6_wan_ipaddr: """",
 ipv6_pdp_type: """",
 ipv6_pdp_type_ui: """",
 pdp_type: """",
 pdp_type_ui: """",
 opms_wan_mode: """",
 ppp_status: """",
 wan_lte_ca: """",
 lte_ca_pcell_band: """",
 lte_ca_pcell_bandwidth: """",
 lte_ca_scell_band: """",
 lte_ca_scell_bandwidth: """",
 lte_ca_scell_freq: """",
 cell_id: """",
 lte_snr: """",
 wan_active_band: """",
 lte_ca_pcell_freq: """",
 lte_rsrq: """",
 lte_rsrp: """"
 };
 return {
 setCellLockSetting: ri,
 setPsRestart: ni,
 setAntennaState: O_,
 getBspTemperatureControlInfo: ti,
 setBspTemperatureControlInfo: ei,
 getPciePowersaveSetting: J_,
 getNewVersionSizeAnddescription: Q_,
 setPciePowersaveSetting: $_,
 setUserImprovNote: Y_,
 closeTemperatureControl: Z_,
 getTempStatus: E_,
 getPortsMode: j_,
 setPortsMode: q_,
 getFrequencyInfo: z_,
 setFrequencyInfo: X_,
 setDeviceAccessControlList: d_,
 getUserIPAddr: c_,
 setMacFilterStatus: u_,
 getAntiVioCraSetting: a_,
 getMacFilterStatus: o_,
 setWifiWpsStart: s_,
 setWifiChipAdvanceInfo: i_,
 setWifiModuleSwitchStatus: r_,
 setWifiAccessPointInfo: n_,
 getWifiWpsStatus: t_,
 getWifiAccessPointInfo: $r,
 getWifiModuleSwitchStatus: Jr,
 getSleepModeStatus: Br,
 setRedirectOff: Ur,
 setBindMacIpSwitch: Or,
 clearRedirectFlag: Tr,
 getRedirectData: Sr,
 getSntpDSTByTimeZone: Lr,
 getBindIPInfo: Ir,
 setBindIPInfo: Pr,
 delStaticAddrRules: br,
 addStaticAddress: Rr,
 getStaticMacIpAddressList: Ar,
 getStaticIpAddrList: yr,
 getWifiBasic: o,
 setWifiBasicSync: a,
 setWifiBasic: u,
 setWifiBasic4SSID2: c,
 setWifiBasicMultiSSIDSwitch: m,
 getSecurityInfo: f,
 setSecurityInfo: g,
 getCurrentlyAttachedDevicesInfo: v,
 getAttachedCableDevices: w,
 getLanguage: h,
 setLanguage: S,
 getNetSelectInfo: T,
 setBearerPreference: P,
 scanForNetwork: I,
 getConnectionInfo: A,
 getStatusInfo: b,
 connect: N,
 disconnect: M,
 setNetwork: X,
 getCurrentNetwork: j,
 savePhoneBook: q,
 deletePhoneBooks: Y,
 deleteAllPhoneBooks: Q,
 deleteAllPhoneBooksByGroup: J,
 getDevicePhoneBooks: re,
 getSIMPhoneBooks: _e,
 getPhoneBooks: ie,
 getPhoneBookReady: se,
 getPhoneBooksByGroup: ne,
 getConnectionMode: ee,
 setConnectionMode: $,
 getApnSettings: D,
 deleteApn: C,
 setDefaultApn: k,
 addOrEditApn: F,
 getSIMPhoneBookCapacity: ae,
 getDevicePhoneBookCapacity: ue,
 getLoginData: ce,
 login: de,
 logout: ye,
 getLoginStatus: le,
 enterPIN: pe,
 enterPUK: me,
 getSMSReady: Ie,
 getSMSMessages: fe,
 sendSMS: we,
 saveSMS: he,
 deleteAllMessages: Se,
 deleteMessage: Te,
 setSmsRead: be,
 resetNewSmsReceivedVar: y,
 resetSmsReportReceivedVar: E,
 getSMSDeliveryReport: Ae,
 getSmsCapability: R,
 changePassword: Ee,
 getPinData: Re,
 enablePin: Ne,
 disablePin: Me,
 changePin: De,
 getLanInfo: Ce,
 setLanInfo: ke,
 getSmsSetting: We,
 setSmsSetting: xe,
 restoreFactorySettings: Le,
 checkRestoreStatus: Oe,
 getWpsInfo: Ue,
 openWps: Be,
 getSleepMode: Ve,
 setSleepMode: He,
 getSysSecurity: Ge,
 setSysSecurity: Ke,
 getPortForward: ze,
 setPortForward: Xe,
 deleteForwardRules: je,
 enableVirtualServer: qe,
 getSDConfiguration: $e,
 setSdCardMode: et,
 checkFileExists: tt,
 getFileList: nt,
 fileRename: rt,
 getSdMemorySizes: _t,
 deleteFilesAndFolders: it,
 createFolder: st,
 checkUploadFileStatus: ot,
 setSdCardSharing: at,
 getQuickSettingInfo: Ze,
 setQuickSetting: Ye,
 setQuickSetting4IPv6: Qe,
 getPortFilter: ut,
 setPortFilterBasic: ct,
 setPortFilter: dt,
 deleteFilterRules: lt,
 getWifiAdvance: pt,
 setWifiAdvance: ft,
 getWifiRange: vt,
 getWifiCoverageInfo: ht,
 setWifiRange: wt,
 setWifiCoverageInfo: St,
 getUpnpSetting: It,
 setUpnpSetting: bt,
 getDmzSetting: At,
 setDmzSetting: yt,
 getDeviceInfo: gt,
 getPortMap: Et,
 setPortMap: Rt,
 enablePortMap: Nt,
 deleteMapRules: Mt,
 getTrafficAlertInfo: Dt,
 setTrafficAlertInfo: Ct,
 getDlnaSetting: xt,
 setDlnaSetting: Lt,
 rescanDlna: Ot,
 getUSSDResponse: kt,
 USSDReplyCancel: Wt,
 getNetworkUnlockTimes: Vt,
 unlockNetwork: Bt,
 setUpdateInfoWarning: Ht,
 getUpdateInfoWarning: Gt,
 getAPStationBasic: Kt,
 setAPStationBasic: zt,
 getHotspotList: jt,
 searchHotspot: qt,
 getSearchHotspotList: Zt,
 saveHotspot: Jt,
 deleteHotspot: $t,
 connectHotspot: en,
 disconnectHotspot: tn,
 getOpMode: nn,
 SetOperationMode: rn,
 SendUpgradeMessage: _n,
 getPppoeParams: sn,
 setPppoeDialMode: on,
 getSntpParams: an,
 setSntpSetting: cn,
 setSNTPDate: un,
 addUrlFilterRule: dn,
 getUrlFilterList: ln,
 deleteSelectedRules: pn,
 getWdsInfo: mn,
 setWDS: fn,
 getSyslogInfo: gn,
 setSysLog: vn,
 getTR069Config: wn,
 setTR069Configuration: hn,
 getVoipSettings: Sn,
 setVoipSettings: Tn,
 getVoipUserDetails: Pn,
 getVoipUserRegisterStatus: In,
 setVoipUserDetails: bn,
 setVoipAdvancedSettings: yn,
 getVoipAdvancedSettings: An,
 getVoipSupplementaryService: En,
 setVoipSupplementaryService: Rn,
 getMacFilterInfo: Nn,
 setMacFilter: Mn,
 getFastbootSetting: Dn,
 setFastbootSetting: Cn,
 restart: kn,
 shutdown: Fn,
 timerUpdaterEnable: ai,
 clearTraffic: Yn,
 switchPortForLog: Qn,
 childGroupList: Jn,
 addChildGroup: $n,
 removeChildGroup: er,
 checkCurrentUserInChildGroup: tr,
 getChildMacRuleInfo: nr,
 removeChildMacRule: rr,
 addChildAccessTimeRule: _r,
 updateChildAccessTimeRule: ir,
 getCurretnMAC: or,
 editHostName: ur,
 getSiteWhiteList: cr,
 removeSiteWhite: dr,
 saveSiteWhite: lr,
 getTimeLimited: pr,
 saveTimeLimited: mr,
 getHostNameList: ar,
 getTsw: fr,
 saveTsw: gr,
 getSysTimeMode: vr,
 trafficCalibration: wr,
 getParams: hr,
 getNewVersionState: Wn,
 getUpgradeResult: On,
 getCurrentUpgradeState: Un,
 dmUpdatePackageExit: Bn,
 setUpgradeSelectOp: Gn,
 addTimerThings: L,
 removeTimerThings: O,
 getPackSizeInfo: Vn,
 getNewVersionInfo: xn,
 getMandatory: Ln,
 getUserChoice: Hn,
 getOTAUpdateSetting: Kn,
 setOTAUpdateSetting: zn,
 getSignalStrength: qn,
 getOTAlastCheckTime: Xn,
 getOTASuccessTime: jn,
 clearUpdateResult: Zn,
 getSearchHotspotListWithoutScanFinish: Yt,
 setHotspotListSpan: Nr,
 getHotspotListSort: Mr,
 setNV: Dr,
 setWifiBand: Cr,
 refreshAPStationStatus: Xt,
 getSTKFlagInfo: kr,
 getSTKInfo: Fr,
 getSTKMenuInfo: Wr,
 setSTKMenuInfo: xr,
 getAutoPowerSave: Tt,
 setAutoPowerSave: Pt,
 getDHCPStaticAddressRules: Er,
 setMtuMss: Fe,
 setHaveReadPrivacyNote: Vr,
 setWifiFrequency: p,
 setWifiAdvanceGuest: l,
 setSkipSetting: d,
 setWifiAdvance24G5G: mt,
 diagnosisSettings: Hr,
 getDeviceAccessControlList: Gr,
 getThermalControlSetting: Kr,
 setThermalControlSetting: zr,
 getPinglogInfo: Xr,
 setPinglogInfo: jr,
 getsleepProtection: qr,
 saveSleepProtection: Zr,
 getRebootInfo: Yr,
 setRebootScheduleFixTime: Qr,
 getVPNClientSetting: l_,
 setVPNClientSetting: p_,
 vpnConnect: m_,
 vpnDisconnect: f_,
 setWifiWholeChipAdvanceInfo: __,
 getVoipVolteSetting: g_,
 setVoipVolteSetting: v_,
 setTr069Module: w_,
 setSuggestedPositionDetect: h_,
 setSuggestedPositionCancel: S_,
 getSuggestedPositionDetectProgress: T_,
 getSuggestedPositionDetectResult: P_,
 getSuggestedPositionDetectRecord: I_,
 addSuggestedPositionRecord: b_,
 deleteSingleSuggestedPositionRecord: A_,
 deleteAllSuggestedPositionRecord: y_,
 getTempStatus: E_,
 setWifiAccessPointInfo_24G5G: R_,
 getAntennaControlSetting: N_,
 setAntennaControlSetting: M_,
 getDebugInfo: D_,
 setBandSelect: C_,
 setOnlineLpm: k_,
 setIMS: F_,
 setVOICE: W_,
 setWlanTputs: x_,
 setNr5gBandSelect: L_,
 setRFMMW: U_,
 setMbnMode: B_,
 setMqttMecAes: V_,
 getWiFiGuestLeftTime: e_,
 getWatchDogSetting: H_,
 setWatchDogSetting: G_,
 getWifiWpsFailReason: _i
 }
});
//# sourceMappingURL=../sourcemaps/service.js.map"
median_pool.py,"import math
import torch
import torch.nn as nn
import torch.nn.functional as F
from torch.nn.modules.utils import _pair, _quadruple




class MedianPool2d(nn.Module):
 """""" Median pool (usable as median filter when stride=1) module.
 
    Args:
         kernel_size: size of pooling kernel, int or 2-tuple
         stride: pool stride, int or 2-tuple
         padding: pool padding, int or 4-tuple (l, r, t, b) as in pytorch F.pad
         same: override padding and enforce same padding, boolean
    """"""
 def __init__(self, kernel_size=3, stride=1, padding=0, same=False):
 super(MedianPool2d, self).__init__()
 self.k = _pair(kernel_size)
 self.stride = _pair(stride)
 self.padding = _quadruple(padding)  # convert to l, r, t, b
 self.same = same


 def _padding(self, x):
 if self.same:
 ih, iw = x.size()[2:]
 if ih % self.stride[0] == 0:
 ph = max(self.k[0] - self.stride[0], 0)
 else:
 ph = max(self.k[0] - (ih % self.stride[0]), 0)
 if iw % self.stride[1] == 0:
 pw = max(self.k[1] - self.stride[1], 0)
 else:
 pw = max(self.k[1] - (iw % self.stride[1]), 0)
 pl = pw // 2
 pr = pw - pl
 pt = ph // 2
 pb = ph - pt
 padding = (pl, pr, pt, pb)
 else:
 padding = self.padding
 return padding
 
 def forward(self, x):
 # using existing pytorch functions and tensor ops so that we get autograd, 
 # would likely be more efficient to implement from scratch at C/Cuda level
 x = F.pad(x, self._padding(x), mode='reflect')
 x = x.unfold(2, self.k[0], self.stride[0]).unfold(3, self.k[1], self.stride[1])
 x = x.contiguous().view(x.size()[:4] + (-1,)).median(dim=-1)[0]
 return x"
dragon_download.py,"from typing import List, Iterator


import os
import urllib.request
import json
from dataclasses import dataclass
import argparse


PRODUCT_URL = ""https://bad-dragon.com/api/products""
SAVE_DIR = ""models""




@dataclass
class DownloadableProduct:
 name: str


 preview_object_url: str
 preview_texture_map_url: str
 preview_normal_map_url: str




def load_products() -> List[dict]:
 with urllib.request.urlopen(PRODUCT_URL) as f:
 return json.load(f)




def process_products(products: List[dict]) -> Iterator[DownloadableProduct]:
 for product in products:
 name = product.get(""sku"")
 preview_object_url = product.get(""previewObjModel"", {}).get(""url"")
 preview_texture_map_url = product.get(""previewTextureMap"", {}).get(""url"")
 preview_normal_map_url = product.get(""previewNormalMap"", {}).get(""url"")


 if (
 not name
 or not preview_object_url
 or not preview_texture_map_url
 or not preview_normal_map_url
        ):
 continue


 yield DownloadableProduct(
 name, preview_object_url, preview_texture_map_url, preview_normal_map_url
        )




def download_file(url: str, path: str) -> None:
 if os.path.exists(path):
 print(""Already downloaded {path}"".format(path=path))
 return


 print(""Downloading {path}"".format(path=path))
 urllib.request.urlretrieve(url, path)




def download_product(
 product: DownloadableProduct, save_dir: str, include_maps: bool = False
) -> None:
 download_file(
 product.preview_object_url,
 os.path.join(save_dir, ""{name}.obj"".format(name=product.name)),
    )


 if include_maps:
 download_file(
 product.preview_texture_map_url,
 os.path.join(save_dir, ""{name}_texture_map.png"".format(name=product.name)),
        )
 download_file(
 product.preview_normal_map_url,
 os.path.join(save_dir, ""{name}_normal_map.png"".format(name=product.name)),
        )




if __name__ == ""__main__"":
 parser = argparse.ArgumentParser(description=""Download Bad Dragon preview objects."")
 parser.add_argument(
 ""--maps"", help=""include texture and normal maps"", action=""store_true""
    )
 parser.add_argument(""dir"", help=""Path to save models"", nargs=""?"", default=SAVE_DIR)


 args = parser.parse_args()


 if not os.path.exists(args.dir):
 os.mkdir(args.dir)


 print(""Saving objects to {dir}"".format(dir=args.dir))


 products = load_products()
 for product in process_products(products):
 download_product(product, args.dir, args.maps)"
client_side.py,"def post_bin_example():
 import requests
 import numpy as np
 #NOTE! the dtype used here and on the server have to match and byte ordering isn't considered in this example
 x = np.random.rand(10).astype(np.float32)
 print(f'sending {len(x)} floats : {x}')
 res = requests.post(url=ROOT_PATH+r'/readbin',
 data=x.tobytes(),
 headers={'Content-Type': 'application/octet-stream'})
 print(res)
 


# NOTE: this is code is a standard Flask view 
@app.route('/readbin', methods=['POST'])
def read_bin_example():
 chunk_size = 4096
 data = bytearray()
 while True:
 chunk = request.stream.read(chunk_size)
 if len(chunk) == 0:
 break 
 data.extend(chunk)
 if len(data):
 import numpy as np
 #NOTE! byte ordering not considered in this example
 floats = np.frombuffer(data, dtype=np.float32)
 print(f'got {len(data)} bytes, {len(floats)} floats')
 print(floats)
 
 return f'ok'
 "
demodulation.c,"#include <math.h>
#include <stdio.h>


typedef struct _complex {
 double imag;
 double real;
} complex_t;


const int SAMPLE_RATE = 160E3;
const float FREQUENCY = 40E3;
const int N_OSCILATIONS = 4;
const int N_SAMPLES_PER_SYMBOL = (N_OSCILATIONS * SAMPLE_RATE) / FREQUENCY;
const float OMEGA_PART = -2 * M_PI * FREQUENCY / SAMPLE_RATE;
const int SIGNAL_LENGTH = 2000;


int main() {
 int signal[SIGNAL_LENGTH] = ...;


 // The filter (`filterx`) is calculated only once, so you can store it
 complex_t filterx[N_SAMPLES_PER_SYMBOL];
 for (int i = 0; i < N_SAMPLES_PER_SYMBOL; i++) {
 filterx[i].real = cos(OMEGA_PART * i) / (N_SAMPLES_PER_SYMBOL / 2);
 filterx[i].imag = sin(OMEGA_PART * i) / (N_SAMPLES_PER_SYMBOL / 2);
    }


 int symbol_index = 0;
 for (int i = 0; i < SIGNAL_LENGTH - N_SAMPLES_PER_SYMBOL + 1; i += N_SAMPLES_PER_SYMBOL) {
 complex_t sum = {
            .real = 0,
            .imag = 0
        };


 // This part is computationaly the most expensive, however it can be accelerated
 // by utilising built in DSP convolution acceleration. Note that in case of using the convolution
 // `filterx` has to be inversed.
 for (int j = 0; j < N_SAMPLES_PER_SYMBOL; j++) {
 sum.real += filterx[j].real * signal[i + j];
 sum.imag += filterx[j].imag * signal[i + j];
        }


 // Here you will probably need some PLL and equalisation to get rid of real-world distortions
 // Please check fantastically explained algorithms by Joseph D. Gaeddert:
 // - PLL: https://liquidsdr.org/blog/pll-howto/
 // - LMS Equalizer: https://liquidsdr.org/blog/lms-equalizer/
 int symbol = ((sum.imag > 0) << 1) | (sum.real < 0);
 printf(""%d "", symbol);
    }
 printf(""\n"");
}
#include <stdio.h>
#include <math.h>


typedef struct _complex {
 double imag;
 double real;
} complex_t;


const double SYMBOL_DURATION = 50E-6;
const int SAMPLE_RATE = 100E3;
const int FREQUENCY = 40E3;


const float SAMPLE_DURATION = 1.0 / SAMPLE_RATE;
const int N_SAMPLES_PER_SYMBOL = SYMBOL_DURATION / SAMPLE_DURATION;


int main() {
 complex_t symbol = {
        .real = 1,
        .imag = 0
    };
 complex_t carrier[N_SAMPLES_PER_SYMBOL];
 double signal[N_SAMPLES_PER_SYMBOL];


 // Generate carrier
 for (size_t i = 0; i < N_SAMPLES_PER_SYMBOL; i++) {
 double omega = 2 * M_PI * FREQUENCY * i * SAMPLE_DURATION;
 carrier[i].real = cos(omega);
 carrier[i].imag = sin(omega);
    }
 
 // Generate signal. We can ignore imaginary part
 for (size_t i = 0; i < N_SAMPLES_PER_SYMBOL; i++) {
 signal[i] = carrier[i].real * symbol.real - carrier[i].imag * symbol.imag;
    }


 for (size_t i = 0; i < N_SAMPLES_PER_SYMBOL; i++) {
 printf(""%f "", signal[i]);
    }
 printf(""\n"");
}
#include <stdio.h>
#include <complex.h>
#include <math.h>


const double SYMBOL_DURATION = 50E-6;
const int SAMPLE_RATE = 100E3;
const int FREQUENCY = 40E3;


const float SAMPLE_DURATION = 1.0 / SAMPLE_RATE;
const int N_SAMPLES_PER_SYMBOL = SYMBOL_DURATION / SAMPLE_DURATION;


int main() {
 double carrier[N_SAMPLES_PER_SYMBOL];
 double signal[N_SAMPLES_PER_SYMBOL];


 for (size_t i = 0; i < N_SAMPLES_PER_SYMBOL; i++) {
 carrier[i] = cpow(M_E, (2*I) * M_PI * FREQUENCY * i * SAMPLE_DURATION);
    }


 double complex symbol = 1 + 0 * I;
 for (size_t i = 0; i < N_SAMPLES_PER_SYMBOL; i++) {
 signal[i] = carrier[i] * symbol;
    }


 for (size_t i = 0; i < N_SAMPLES_PER_SYMBOL; i++) {
 printf(""%f "", creal(signal[i]));
    }
 printf(""\n"");
}"
ScriptableObjectWithId.cs,"// Reference: https://github.com/Bunny83/UUID/blob/master/UUID.cs


using System;
using System.Collections.Generic;
using System.Globalization;
using UnityEngine;
#if UNITY_EDITOR
using UnityEditor;


#endif


public class ScriptableObjectWithId : ScriptableObject, ISerializationCallbackReceiver
{
 private static readonly Dictionary<ScriptableObjectWithId, string> ObjectToString =
 new Dictionary<ScriptableObjectWithId, string>();


 private static readonly Dictionary<string, ScriptableObjectWithId> StringToObject =
 new Dictionary<string, ScriptableObjectWithId>();


 [SerializeField]
 private string internalId;


 [SerializeField]
 private long createdAtTicks;


 [NonSerialized]
 private bool _internalIdWasUpdated;


 // The only attribute we want to provide externally is the InternalID value.
 // The remainder is for in-editor tracking, and scriptable object asset save/loading.
 public string InternalID => internalId;


#if UNITY_EDITOR
 private string CreatedAt => new DateTime(createdAtTicks).ToString(CultureInfo.CurrentCulture);
#endif


 protected void OnEnable()
 {
        ProcessRegistration(this);


 // If we updated the internalId during serialization, save the asset.
 if (!_internalIdWasUpdated)
 {
 return;
 }


 _internalIdWasUpdated = false;


#if UNITY_EDITOR
 // Before/After Serialize methods cannot mark dirty.
 //   Without this, the change we made in registration is not saved.
 //   If something else changed on the asset, such as the Display Name
 //   then that will cause it to be marked dirty, and saved.
 //   But, extensive testing has shown that there are cases where
 //   only the UUID is updated and never saved.
        EditorUtility.SetDirty(this);
        AssetDatabase.SaveAssets();
#endif
 }


 protected void OnDestroy()
 {
        Debug.LogWarning($""Unexpected object destroyed. {internalId}"");
        UnregisterObject(this);
 internalId = null;
 }


 public void OnAfterDeserialize()
 {
        ProcessRegistration(this);
 }


 public void OnBeforeSerialize()
 {
        ProcessRegistration(this);
 }


 private static void ProcessRegistration(ScriptableObjectWithId obj)
 {
 // See if we already know about this object.
 if (ObjectToString.TryGetValue(obj, out var existingId))
 {
 if (obj.internalId != existingId)
 {
 // Logging an error since this will change this object's ID.
                Debug.LogError($""Inconsistency: {obj.name} {obj.internalId} / {existingId}"");
                obj.internalId = existingId;
 }


 // Found object instance, ensure StringToObject contains.
 if (StringToObject.ContainsKey(existingId))
 {
 return;
 }


 // DB inconsistency
            Debug.LogWarning(""Inconsistent database tracking."");
            StringToObject.Add(existingId, obj);


 return;
 }


 // See if this object's Internal ID is empty. Easy case, create.
 if (string.IsNullOrEmpty(obj.internalId))
 {
            GenerateInternalId(obj);


            RegisterObject(obj);
 return;
 }


 // Ensure we don't already have the Internal ID registered.
 // If not, then we don't know about the object, nor the Internal ID, so just register.
 if (!StringToObject.TryGetValue(obj.internalId, out var knownObject))
 {
 // ID not known to the DB, so just register it
            RegisterObject(obj);
 return;
 }


 // We DO know about the Internal ID, and it matches this object. Weird... just register it.
 if (knownObject == obj)
 {
 // DB inconsistency
            Debug.LogWarning(""Inconsistent database tracking."");
            ObjectToString.Add(obj, obj.internalId);
 return;
 }


 // We know about the Internal ID, but it isn't tied to any object. This object claims to
 // be that Internal ID.... okay, register it.
 if (knownObject == null)
 {
 // Object in DB got destroyed, replace with current object.
            Debug.LogWarning(""Unexpected registration problem."");
            RegisterObject(obj, true);
 return;
 }


 // Otherwise:
 // 1) Object database did NOT contain this object.
 // 2) We did find a different object with the SAME identifier.
 // Thus, we have a duplicate.
 //
 // Through extensive testing, it appears the duplicated item will be updated.
 // The original item will not have its hash updated. Save games referencing that
 // hash should remain functional.
 //
 // Designers should never repurpose a checkpoint and expect it to not be
 // already unlocked or otherwise referenced in production.
 //


 // Debug.Log($""Duplicate Detected: {obj.internalId}"");
        GenerateInternalId(obj);


 // Register this new item.
        RegisterObject(obj);
 }


 private static void RegisterObject(ScriptableObjectWithId aID, bool replace = false)
 {
 if (replace)
 {
            StringToObject[aID.internalId] = aID;
 }
 else
 {
            StringToObject.Add(aID.internalId, aID);
 }


        ObjectToString.Add(aID, aID.internalId);
 }


 private static void UnregisterObject(ScriptableObjectWithId aID)
 {
        StringToObject.Remove(aID.internalId);
        ObjectToString.Remove(aID);
 }


 private static void GenerateInternalId(ScriptableObjectWithId obj)
 {
        obj.internalId = Guid.NewGuid().ToString();
        obj.createdAtTicks = DateTime.Now.Ticks;


        obj._internalIdWasUpdated = true;


 // Debug.Log($""Created Internal ID: {obj.internalId}"");
 }
}"
gi.c,"

static void gi_on_gpu(u8* in_bitmap, int w, int h) {
 #define num_cascades 7
 static bool initialized;
 static gpu_bindgroup_t texture_bindgroup[2];
 static gpu_bindgroup_t cascade_uniform_bindgroup[num_cascades];
 static gpu_bindgroup_t render_uniform_bindgroup;
 static gpu_buffer_t vertex_buffer;
 static gpu_buffer_t uniform_buffer;
 static gpu_pipeline_t pipeline;
 static gpu_bindgroup_layout_t uniform_bindgroup_layout;
 static gpu_bindgroup_layout_t texture_bindgroup_layout;
 static lifetime_t texture_lifetime;
 static gpu_texture_t textures[2];
 static gpu_texture_t input_texture;
 lifetime_t* lifetime = g_platform->lifetime;


 f32 d0 = 1.f; // distance between probes in cascade 0
 int r0 = 4; // number of rays in cascade 0
 int n0 = (int)floorf(2*w/d0); // number of probes in cascade 0 per dimension
 int cn = num_cascades;


 typedef struct {
 f32 d0;
 int r0;
 int n0;
 int ci;


 int cn;
 int do_render;
 int add_sky_light;
 int padding;


 v2 resolution;
 v2 padding2;
    } uniform_t;


 if (!initialized) {
 lifetime_t temp_lifetime = {0};
 initialized = true;


 // create bindgroup layouts
 uniform_bindgroup_layout = gpu_bindgroup_layout_make(lifetime, &(gpu_bindgroup_layout_desc_t){
            .name = ""gi uniform bgl"",
            .entries = {
                {
                    .visibility = gpu_visibility_fragment,
                    .type = gpu_binding_type_buffer,
                    .buffer.type = gpu_buffer_binding_type_uniform,
                },
            },
        });


 texture_bindgroup_layout = gpu_bindgroup_layout_make(lifetime, &(gpu_bindgroup_layout_desc_t){
            .name = ""gi texture bgl"",
            .entries = {
                {
                    .visibility = gpu_visibility_fragment,
                    .type = gpu_binding_type_sampler,
                },
                {
                    .visibility = gpu_visibility_fragment,
                    .type = gpu_binding_type_sampler,
                },
            },
        });


 // create pipeline
 pipeline = gpu_pipeline_make(lifetime, &(gpu_pipeline_desc_t){
            .name = ""gi render shader"",
            .code = file_read(""shaders/gi.glsl"", &temp_lifetime).bytes,
            .bgls = {
 uniform_bindgroup_layout,
 texture_bindgroup_layout,
            },
        });


 // create uniform buffer (we pack all our different uniforms in one buffer), one per cascade and one for rendering
        {
 gpu_uniform_packer_t p = gpu_uniform_packer_begin(sizeof(uniform_t), num_cascades+1, lifetime);
 uniform_buffer = p.handle;
 // set cascade uniforms
 for (int i = 0; i < num_cascades; ++i) {
 *(uniform_t*)p.data = (uniform_t){
                    .d0 = d0,
                    .r0 = r0,
                    .n0 = n0,
                    .ci = i,
                    .cn = num_cascades,
                    .add_sky_light = 1,
                    .resolution = {(f32)w,(f32)h},
                };
 cascade_uniform_bindgroup[i] = gpu_bindgroup_make(lifetime, &(gpu_bindgroup_desc_t){
                    .name = ""gi"",
                    .layout = uniform_bindgroup_layout,
                    .entries = {gpu_uniform_packer_bindgroup_entry(&p)},
                });
 gpu_uniform_packer_next(&p);
            }


 // set render uniform
 *(uniform_t*)p.data = (uniform_t){
                .d0 = d0,
                .r0 = r0,
                .n0 = n0,
                .ci = 0,
                .cn = num_cascades,
                .do_render = 1,
                .resolution = {(f32)w,(f32)h},
            };
 render_uniform_bindgroup = gpu_bindgroup_make(lifetime, &(gpu_bindgroup_desc_t){
                .name = ""gi"",
                .layout = uniform_bindgroup_layout,
                .entries = {gpu_uniform_packer_bindgroup_entry(&p)},
            });


 gpu_uniform_packer_end(&p);
        }


 // create textures
 input_texture = gpu_texture_make(w, h, gpu_texture_format_rgb8, filter_type_nearest, false, lifetime);
 gpu_texture_set_border(input_texture, (color_t){1,1,1,1});
 textures[0] = gpu_texture_make(r0*n0, n0, gpu_texture_format_rgba8, filter_type_nearest, false, lifetime);
 textures[1] = gpu_texture_make(r0*n0, n0, gpu_texture_format_rgba8, filter_type_nearest, false, lifetime);


 texture_bindgroup[0] = gpu_bindgroup_make(lifetime, &(gpu_bindgroup_desc_t){
            .name = ""gi"",
            .layout = texture_bindgroup_layout,
            .entries = {
                {.sampler = {input_texture}},
                {.sampler = {textures[0]}},
            },
        });


 texture_bindgroup[1] = gpu_bindgroup_make(lifetime, &(gpu_bindgroup_desc_t){
            .name = ""gi"",
            .layout = texture_bindgroup_layout,
            .entries = {
                {.sampler = {input_texture}},
                {.sampler = {textures[1]}},
            },
        });


 lifetime_destroy(&temp_lifetime);
    }


 // update input texture
 gpu_texture_set_data(input_texture, in_bitmap);


 // clear texture for pingponging
 gpu_texture_clear(textures[(cn-1)%2], (color_t){0});


 // build cascades
 for (int i = cn-1; i >= 0; --i) {
 drawcall_render(&(drawcall_t){
            .pipeline = pipeline,
            .last_vertex = 6,
            .bindgroups = {cascade_uniform_bindgroup[i], texture_bindgroup[i%2]},
            .outputs = {textures[(i+1)%2]},
        });
    }


 // render
 drawcall_render(&(drawcall_t){
        .pipeline = pipeline,
        .last_vertex = 6,
        .bindgroups = {render_uniform_bindgroup, texture_bindgroup[cn%2]},
    });


 #undef num_cascades
}
#ifdef VERTEX_SHADER


 out vec2 fuv;


 // a vertex shader that spits out a screen-size quad
 // call with vertex count = 6
 void main(void) {
 vec2[] positions = vec2[](
 vec2(-1,-1),
 vec2(1,-1),
 vec2(1,1),
 vec2(-1,-1),
 vec2(1,1),
 vec2(-1,1)
        );
 vec2 vpos = positions[gl_VertexID%6];
 gl_Position = vec4(vpos, 0, 1);
        fuv = vpos*0.5+0.5;
        fuv.y = 1 - fuv.y;
    }


#endif /* VERTEX_SHADER */


#ifdef FRAGMENT_SHADER


 layout (std140, binding = 0) uniform Uniform
    {
 float d0; // distance between probes in cascade 0
 int   r0; // number of rays in cascade 0
 int   n0; // number of probes in cascade 0 (per dimension)
 int   ci; // cascade number


 int   cn; // total number of cascades
 int   should_do_render; // we switch on this to render instead of building the cascades
 int   add_sky_light; // set to 1 to add sky lighting to uppermost cascade
 int   padding;


 vec2   u_resolution; // resolution of the input texture
 vec2   padding4;
    };
 layout(binding = 1) uniform sampler2D u_input; // world data that we raytrace through
 layout(binding = 2) uniform sampler2D u_prev; // previous cascade (ping-pong this and the output texture)


 in vec2 fuv;


 layout(location = 0) out vec4 ocolor;


 const float PI = 3.1415927;


 // raymarch2d: Implementation of Amanatides & Woo voxel marching algo
 struct raymarch2d_t {
 int x;
 int y;
 int sx;
 int sy;
 int ex;
 int ey;
 float tmx;
 float tmy;
 float tdx;
 float tdy;
    };


    raymarch2d_t raymarch2d_make(float x0, float y0, float x1, float y1) {
        raymarch2d_t res;
        res.x = int(floor(x0));
        res.y = int(floor(y0));
        res.sx = x0 < x1 ? 1 : x1 < x0 ? -1 : 0;
        res.sy = y0 < y1 ? 1 : y1 < y0 ? -1 : 0;
        res.ex = int(floor(x1)) + 2*res.sx;
        res.ey = int(floor(y1)) + 2*res.sy;
 float dx = x1 - x0;
 float dy = y1 - y0;
 float l = 1.f/sqrt(dx*dx + dy*dy);
        dx *= l;
        dy *= l;
        res.tmx = dx == 0 ? 10000000 : (x0 - res.x)/dx;
        res.tmy = dy == 0 ? 10000000 : (y0 - res.y)/dy;
        res.tdx = dx == 0 ? 0 : res.sx/dx;
        res.tdy = dy == 0 ? 0 : res.sy/dy;
 return res;
    }


 bool raymarch2d_next(inout raymarch2d_t r) {
 if (r.tmx < r.tmy) {
            r.tmx += r.tdx;
            r.x += r.sx;
 return r.x != r.ex;
        }
 else {
            r.tmy += r.tdy;
            r.y += r.sy;
 return r.y != r.ey;
        }
    }


 vec3 tonemap_aces(vec3 color) {
 const float slope = 12.0;
 vec4 x = vec4(
            color.r, color.g, color.b,
            (color.r * 0.299) + (color.g * 0.587) + (color.b * 0.114)
        );
 const float a = 2.51f;
 const float b = 0.03f;
 const float c = 2.43f;
 const float d = 0.59f;
 const float e = 0.14f;
 vec4 tonemap = clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0, 1.0);
 float t = x.a;
        t = t * t / (slope + t);
 return mix(tonemap.rgb, tonemap.aaa, t);
    }


 vec3 sky_(vec2 angle) {
 float a1 = angle[1];
 float a0 = angle[0];
 // Sky integral formula taken from
 // Analytic Direct Illumination - Mathis
 // https://www.shadertoy.com/view/NttSW7
 const vec3 SkyColor = vec3(0.2,0.5,1.);
 const vec3 SunColor = vec3(1.,0.7,0.1)*10.;
 const float SunA = 2.0;
 const float SunS = 64.0;
 const float SSunS = sqrt(SunS);
 const float ISSunS = 1./SSunS;
 vec3 SI = SkyColor*(a1-a0-0.5*(cos(a1)-cos(a0)));
        SI += SunColor*(atan(SSunS*(SunA-a0))-atan(SSunS*(SunA-a1)))*ISSunS;
 return SI / 6.0;
    }


 vec3 sky(vec2 angle) {
 // Integrate the radiance from the sky over an interval of directions
 if (angle[1] < 2.0 * PI)
 return sky_(angle);
 return
            sky_(vec2(angle[0], 2.0 * PI)) +
            sky_(vec2(0.0, angle[1] - 2.0 * PI));
    }


 void main(void) {
 if (should_do_render == 1) {
 // sample probe in cascade 0
 float x = fuv.x * u_resolution.x;
 float y = fuv.y * u_resolution.y;
 float xi = round(x/d0);
 float yi = round(y/d0);
 vec3 c = vec3(0,0,0);
 for (int r = 0; r < r0; ++r) {
 vec2 pixelcoord = floor(vec2(xi*r0 + r, yi)) + 0.5;
                c += texture(u_prev, pixelcoord / textureSize(u_prev, 0)).rgb;
            }
            ocolor = vec4(tonemap_aces(c/r0),1);
        }
 else {
 // build cascade
 int u = int(gl_FragCoord.x);
 int v = int(gl_FragCoord.y);


 int lm = 2;// ray distance branching factor. ray distance = 2^(lm*ci)
 int rm = 1;// ray count branching factor. Num rays for cascade ci = r0*2^(rm*ci) = r0*(1 << rm*ci). NOTE: increasing this removes the property that total size of all cascades converges to 2x size of cascade 0, and instead leads to linear size increase
 int n = n0 >> ci; // number of probes in one dimension
 float d = d0*(1 << ci); // distance between probes
 int rn = r0 << (rm*ci); // number of pixels/rays per probe
 int yi = v; // probe index
 int xi = u/rn; // probe index
 int r = u - xi*rn; // ray index
 float dx = d0*0.5f*(1 << ci);
 float x = xi * d + dx; // probe pos
 float y = yi * d + dx; // probe pos
 float l = 0.5 * d0; // length of ray
 float intensity = 1.0;


 if (xi >= n || xi < 0 || yi >= n || yi < 0) {
                ocolor = vec4(0,0,0,0);
 return;
            }


 float ra = ci == 0 ? 0 : l*(1 << ((ci-1)*lm)); // start of ray length interval
 float rb = l*(1 << (ci*lm)); // end of ray length interval


 float alpha = 2*PI*(float(r)+0.5)/rn;
 vec2 rot = vec2(cos(alpha), sin(alpha));
 vec2 a = vec2(x,y) + rot*ra; // start of ray
 vec2 b = vec2(x,y) + rot*rb; // end of ray
            raymarch2d_t raym = raymarch2d_make(a.x, a.y, b.x, b.y);
 vec4 col = vec4(0,0,0,0);
 while (raymarch2d_next(raym)) {
 vec3 v = texture(u_input, vec2((raym.x+0.5)/u_resolution.x, (raym.y+0.5)/u_resolution.y)).rgb;
 if (v != vec3(1,1,1)) {
                    col = vec4(v*intensity,1);
 break;
                }
            }


 // if no hit, get from upper cascade
 // TODO: do proper alpha blending to support transparent materials. Since we're only dealing with opaque materials for now it's fine
 if (col.a == 0) {
 if (ci == cn-1) {
 if (add_sky_light != 0)
                        col = vec4(sky(vec2(alpha, alpha + 2*PI/rn)) / (2*PI/rn), 1);
 else
                        col = vec4(0,0,0,0);
                }
 else {
 int xi2 = (xi+1)/2; // probe index in upper
 int yi2 = (yi+1)/2; // probe index in upper
 int r2 = r << rm; // ray index in upper
 int rn2 = rn << rm; // num rays in upper
 int n2 = n >> 1; // num probes in upper
 float tx = 0.75 - 0.5*float(xi%2); // weighting of upper cascade. we can do this magic because we know how the probes are laid out in the grid
 float ty = 0.75 - 0.5*float(yi%2); // weighting of upper cascade. we can do this magic because we know how the probes are laid out in the grid


 // loop through all the nearby rays in the upper cascade
 // TODO: in the case where there are >2 rays in the upper cascade for each ray in this cascade (i.e. rm > 1),
 //       we should choose a better weighting than just treating them all equally
 vec4 upper = vec4(0,0,0,0);
 float frac = 1.0 / (1 << rm);
 for (int ri = 0; ri < (1 << rm); ++ri) {
 vec2 pc1 = floor(vec2(clamp(xi2-1, 0, n2-1)*rn2 + r2 + ri, clamp(yi2-1, 0, n2-1))) + 0.5; // pixel coordinate of upper probe for ray r2+ri
 vec2 pc2 = floor(vec2(clamp(xi2,   0, n2-1)*rn2 + r2 + ri, clamp(yi2-1, 0, n2-1))) + 0.5; // pixel coordinate of upper probe for ray r2+ri
 vec2 pc3 = floor(vec2(clamp(xi2-1, 0, n2-1)*rn2 + r2 + ri, clamp(yi2,   0, n2-1))) + 0.5; // pixel coordinate of upper probe for ray r2+ri
 vec2 pc4 = floor(vec2(clamp(xi2,   0, n2-1)*rn2 + r2 + ri, clamp(yi2,   0, n2-1))) + 0.5; // pixel coordinate of upper probe for ray r2+ri
 vec4 c = mix(
 mix(texture(u_prev, pc1 / textureSize(u_prev, 0)), texture(u_prev, pc2 / textureSize(u_prev, 0)), tx),
 mix(texture(u_prev, pc3 / textureSize(u_prev, 0)), texture(u_prev, pc4 / textureSize(u_prev, 0)), tx),
                            ty
                        );
                        upper += c*frac;
                    }
                    col = upper;
                }
            }


            ocolor = vec4(col.rgb, 1);
        }
    }


#endif /* FRAGMENT_SHADER */"
alphas101.py,"import pandas as pd
from sklearn.feature_selection import mutual_info_regression
from talib import WMA
from dcor import distance_correlation as dcor
from joblib import Parallel, delayed, Memory, cpu_count
from numpy_ext import rolling_apply
import numpy as np
from fml.utils import get_name




def rank(df):
 return df.rank(axis=1, pct=True)




def scale(df):
 return df.div(df.abs().sum(axis=1), axis=0)




def log(df):
 return np.log1p(df)




def sign(df):
 return np.sign(df)




def power(df, exp):
 return df.pow(exp)




def ts_lag(df: pd.DataFrame, t: int = 1) -> pd.DataFrame:
 return df.shift(t)




def ts_delta(df, period=1):
 return df.diff(period)




def ts_sum(df: pd.DataFrame, window: int = 10) -> pd.DataFrame:
 return df.rolling(window).sum()




def ts_mean(df, window=10):
 return df.rolling(window).mean()




def ts_weighted_mean(df, period=10):
 return (df.apply(lambda x: WMA(x, timeperiod=period)))




def ts_std(df, window=10):
 return (df
            .rolling(window)
            .std())




def ts_rank(df, window=10):
 return (df
            .rolling(window)
            .apply(lambda x: x.rank().iloc[-1]))




def ts_product(df, window=10):
 return (df
            .rolling(window)
            .apply(np.prod))




def ts_min(df, window=10):
 return df.rolling(window).min()




def ts_max(df, window=10):
 return df.rolling(window).max()




def ts_argmax(df, window=10):
 return df.rolling(window).apply(np.argmax).add(1)




def ts_argmin(df, window=10):
 return (df.rolling(window)
            .apply(np.argmin)
            .add(1))




def ts_corr(x, y, window):
 res = Parallel(n_jobs=cpu_count())(delayed(rolling_apply)(dcor, window, x[col], y[col]) for col in x)
 res = pd.DataFrame.from_dict(dict(zip(x.columns, res)))
 res.index = x.index
 res.columns.name = 'ticker'
 return res


# def ts_corr(x, y, window=10):
 # res = x.rolling(window).corr(y)
 # return res


def ts_cov(x, y, window=10):
 return x.rolling(window).cov(y)




def get_mutual_info_score(returns, alpha, n=100000):
 df = pd.DataFrame({'y': returns, 'alpha': alpha}).dropna().sample(n=n)
 return mutual_info_regression(y=df.y, X=df[['alpha']])[0]




def alpha001(c, r):
 c[r < 0] = ts_std(r, 20)
 return (rank(ts_argmax(power(c, 2), 5)).mul(-.5)
            .stack().swaplevel())




def alpha002(o, c, v):
 s1 = rank(ts_delta(log(v), 2))
 s2 = rank((c / o) - 1)
 alpha = -ts_corr(s1, s2, 6)
 res = alpha.stack('ticker').swaplevel().replace([-np.inf, np.inf], np.nan)
 return res




def alpha003(o, v):
 return (-ts_corr(rank(o), rank(v), 10)
            .stack('ticker')
            .swaplevel()
            .replace([-np.inf, np.inf], np.nan))




def alpha004(l):
 return (-ts_rank(rank(l), 9)
            .stack('ticker')
            .swaplevel())




def alpha005(o, vwap, c):
 return (rank(o.sub(ts_mean(vwap, 10)))
            .mul(rank(c.sub(vwap)).mul(-1).abs())
            .stack('ticker')
            .swaplevel())




def alpha006(o, v):
 return (-ts_corr(o, v, 10)
            .stack('ticker')
            .swaplevel())




def alpha007(c, v, adv20):
 delta7 = ts_delta(c, 7)
 return (-ts_rank(abs(delta7), 60)
            .mul(sign(delta7))
            .where(adv20 < v, -1)
            .stack('ticker')
            .swaplevel())




def alpha008(o, r):
 return (-(rank(((ts_sum(o, 5) * ts_sum(r, 5)) -
 ts_lag((ts_sum(o, 5) * ts_sum(r, 5)), 10))))
            .stack('ticker')
            .swaplevel())




def alpha009(c):
 close_diff = ts_delta(c, 1)
 alpha = close_diff.where(ts_min(close_diff, 5) > 0,
 close_diff.where(ts_max(close_diff, 5) < 0,
 -close_diff))
 return (alpha
            .stack('ticker')
            .swaplevel())




def alpha010(c):
 close_diff = ts_delta(c, 1)
 alpha = close_diff.where(ts_min(close_diff, 4) > 0,
 close_diff.where(ts_min(close_diff, 4) > 0,
 -close_diff))


 return (rank(alpha)
            .stack('ticker')
            .swaplevel())




def alpha011(c, vwap, v):
 return (rank(ts_max(vwap.sub(c), 3))
            .add(rank(ts_min(vwap.sub(c), 3)))
            .mul(rank(ts_delta(v, 3)))
            .stack('ticker')
            .swaplevel())




def alpha012(v, c):
 return (sign(ts_delta(v, 1)).mul(-ts_delta(c, 1))
            .stack('ticker')
            .swaplevel())




def alpha013(c, v):
 return (-rank(ts_cov(rank(c), rank(v), 5))
            .stack('ticker')
            .swaplevel())




def alpha014(o, v, r):
 alpha = -rank(ts_delta(r, 3)).mul(ts_corr(o, v, 10)
                                      .replace([-np.inf,
 np.inf],
 np.nan))
 return (alpha
            .stack('ticker')
            .swaplevel())




def alpha015(h, v):
 alpha = (-ts_sum(rank(ts_corr(rank(h), rank(v), 3)
                          .replace([-np.inf, np.inf], np.nan)), 3))
 return (alpha
            .stack('ticker')
            .swaplevel())




def alpha016(h, v):
 return (-rank(ts_cov(rank(h), rank(v), 5))
            .stack('ticker')
            .swaplevel())




def alpha017(c, v):
 adv20 = ts_mean(v, 20)
 return (-rank(ts_rank(c, 10))
            .mul(rank(ts_delta(ts_delta(c, 1), 1)))
            .mul(rank(ts_rank(v.div(adv20), 5)))
            .stack('ticker')
            .swaplevel())




def alpha018(o, c):
 return (-rank(ts_std(c.sub(o).abs(), 5)
                  .add(c.sub(o))
                  .add(ts_corr(c, o, 10)
                       .replace([-np.inf,
 np.inf],
 np.nan)))
            .stack('ticker')
            .swaplevel())




def alpha019(c, r):
 return (-sign(ts_delta(c, 7) + ts_delta(c, 7))
            .mul(1 + rank(1 + ts_sum(r, 250)))
            .stack('ticker')
            .swaplevel())




def alpha020(o, h, l, c):
 return (rank(o - ts_lag(h, 1))
            .mul(rank(o - ts_lag(c, 1)))
            .mul(rank(o - ts_lag(l, 1)))
            .mul(-1)
            .stack('ticker')
            .swaplevel())




def alpha021(c, v):
 sma2 = ts_mean(c, 2)
 sma8 = ts_mean(c, 8)
 std8 = ts_std(c, 8)


 cond_1 = sma8.add(std8) < sma2
 cond_2 = sma8.add(std8) > sma2
 cond_3 = v.div(ts_mean(v, 20)) < 1


 val = np.ones_like(c)
 alpha = pd.DataFrame(np.select(condlist=[cond_1, cond_2, cond_3],
 choicelist=[-1, 1, -1], default=1),
 index=c.index,
 columns=c.columns)


 return (alpha
            .stack('ticker')
            .swaplevel())




def alpha022(h, c, v):
 return (ts_delta(ts_corr(h, v, 5)
                     .replace([-np.inf,
 np.inf],
 np.nan), 5)
            .mul(rank(ts_std(c, 20)))
            .mul(-1)
            .stack('ticker')
            .swaplevel())




def alpha023(h, c):
 return (ts_delta(h, 2)
            .mul(-1)
            .where(ts_mean(h, 20) < h, 0)
            .stack('ticker')
            .swaplevel())




def alpha024(c):
 cond = ts_delta(ts_mean(c, 100), 100) / ts_lag(c, 100) <= 0.05


 return (c.sub(ts_min(c, 100)).mul(-1).where(cond, -ts_delta(c, 3))
            .stack('ticker')
            .swaplevel())




def alpha025(h, c, r, vwap, adv20):
 return (rank(-r.mul(adv20)
                 .mul(vwap)
                 .mul(h.sub(c)))
            .stack('ticker')
            .swaplevel())




def alpha026(h, v):
 return (ts_max(ts_corr(ts_rank(v, 5),
 ts_rank(h, 5), 5)
                   .replace([-np.inf, np.inf], np.nan), 3)
            .mul(-1)
            .stack('ticker')
            .swaplevel())




def alpha027(v, vwap):
 cond = rank(ts_mean(ts_corr(rank(v),
 rank(vwap), 6), 2))
 alpha = cond.notnull().astype(float)
 return (alpha.where(cond <= 0.5, -alpha)
            .stack('ticker')
            .swaplevel())




def alpha028(h, l, c, v, adv20):
 return (scale(ts_corr(adv20, l, 5)
                  .replace([-np.inf, np.inf], 0)
                  .add(h.add(l).div(2).sub(c)))
            .stack('ticker')
            .swaplevel())




def alpha029(c, r):
 return (ts_min(rank(rank(scale(log(ts_sum(rank(rank(-rank(ts_delta((c - 1), 5)))), 2))))), 5)
            .add(ts_rank(ts_lag((-1 * r), 6), 5))
            .stack('ticker')
            .swaplevel())




def alpha030(c, v):
 close_diff = ts_delta(c, 1)
 return (rank(sign(close_diff)
                 .add(sign(ts_lag(close_diff, 1)))
                 .add(sign(ts_lag(close_diff, 2))))
            .mul(-1).add(1)
            .mul(ts_sum(v, 5))
            .div(ts_sum(v, 20))
            .stack('ticker')
            .swaplevel())




def alpha031(l, c, adv20):
 return (rank(rank(rank(ts_weighted_mean(rank(rank(ts_delta(c, 10))).mul(-1), 10))))
            .add(rank(ts_delta(c, 3).mul(-1)))
            .add(sign(scale(ts_corr(adv20, l, 12)
                            .replace([-np.inf, np.inf],
 np.nan))))
            .stack('ticker')
            .swaplevel())




def alpha032(c, vwap):
 return (scale(ts_mean(c, 7).sub(c))
            .add(20 * scale(ts_corr(vwap,
 ts_lag(c, 5), 230)))
            .stack('ticker')
            .swaplevel())




def alpha033(o, c):
 return (rank(o.div(c).mul(-1).add(1).mul(-1))
            .stack('ticker')
            .swaplevel())




def alpha034(c, r):
 return (rank(rank(ts_std(r, 2).div(ts_std(r, 5))
                      .replace([-np.inf, np.inf],
 np.nan))
                 .mul(-1)
                 .sub(rank(ts_delta(c, 1)))
                 .add(2))
            .stack('ticker')
            .swaplevel())




def alpha035(h, l, c, v, r):
 return (ts_rank(v, 32)
            .mul(1 - ts_rank(c.add(h).sub(l), 16))
            .mul(1 - ts_rank(r, 32))
            .stack('ticker')
            .swaplevel())




def alpha036(o, c, v, r, adv20, vwap):
 return (rank(ts_corr(c.sub(o), ts_lag(v, 1), 15)).mul(2.21)
            .add(rank(o.sub(c)).mul(.7))
            .add(rank(ts_rank(ts_lag(-r, 6), 5)).mul(0.73))
            .add(rank(abs(ts_corr(vwap, adv20, 6))))
            .add(rank(ts_mean(c, 200).sub(o).mul(c.sub(o))).mul(0.6))
            .stack('ticker')
            .swaplevel())




def alpha037(o, c):
 return (rank(ts_corr(ts_lag(o.sub(c), 1), c, 200))
            .add(rank(o.sub(c)))
            .stack('ticker')
            .swaplevel())




def alpha038(o, c):
 return (rank(ts_rank(o, 10))
            .mul(rank(c.div(o).replace([-np.inf, np.inf], np.nan)))
            .mul(-1)
            .stack('ticker')
            .swaplevel())




def alpha039(c, v, r, adv20):
 return (rank(ts_delta(c, 7).mul(rank(ts_weighted_mean(v.div(adv20), 9)).mul(-1).add(1))).mul(-1)
            .mul(rank(ts_mean(r, 250).add(1)))
            .stack('ticker')
            .swaplevel())




def alpha040(h, v):
 return (rank(ts_std(h, 10))
            .mul(ts_corr(h, v, 10))
            .mul(-1)
            .stack('ticker')
            .swaplevel())




def alpha041(h, l, vwap):
 return (power(h.mul(l), 0.5)
            .sub(vwap)
            .stack('ticker')
            .swaplevel())




def alpha042(c, vwap):
 return (rank(vwap.sub(c))
            .div(rank(vwap.add(c)))
            .stack('ticker')
            .swaplevel())




def alpha043(c, v, adv20):
 return (ts_rank(v.div(adv20), 20)
            .mul(ts_rank(ts_delta(c, 7).mul(-1), 8))
            .stack('ticker')
            .swaplevel())




def alpha044(h, v):
 return (ts_corr(h, rank(v), 5)
            .replace([-np.inf, np.inf], np.nan)
            .mul(-1)
            .stack('ticker')
            .swaplevel())




def alpha045(c, v):
 return (rank(ts_mean(ts_lag(c, 5), 20))
            .mul(ts_corr(c, v, 2)
                 .replace([-np.inf, np.inf], np.nan))
            .mul(rank(ts_corr(ts_sum(c, 5),
 ts_sum(c, 20), 2)))
            .mul(-1)
            .stack('ticker')
            .swaplevel())




def alpha046(c):
 cond = ts_lag(ts_delta(c, 10), 10).div(10).sub(ts_delta(c, 10).div(10))
 alpha = pd.DataFrame(-np.ones_like(cond),
 index=c.index,
 columns=c.columns)
 alpha[cond.isnull()] = np.nan
 return (cond.where(cond > 0.25,
 -alpha.where(cond < 0,
 -ts_delta(c, 1)))
            .stack('ticker')
            .swaplevel())




def alpha047(h, c, v, vwap, adv20):
 return (rank(c.pow(-1)).mul(v).div(adv20)
            .mul(h.mul(rank(h.sub(c))
                       .div(ts_mean(h, 5)))
                 .sub(rank(ts_delta(vwap, 5))))
            .stack('ticker')
            .swaplevel())




def alpha049(c):
 cond = (ts_delta(ts_lag(c, 10), 10).div(10)
            .sub(ts_delta(c, 10).div(10)) >= -0.1 * c)
 return (-ts_delta(c, 1)
            .where(cond, 1)
            .stack('ticker')
            .swaplevel())




def alpha050(v, vwap):
 return (ts_max(rank(ts_corr(rank(v),
 rank(vwap), 5)), 5)
            .mul(-1)
            .stack('ticker')
            .swaplevel())




def alpha051(c):
 cond = (ts_delta(ts_lag(c, 10), 10).div(10)
            .sub(ts_delta(c, 10).div(10)) >= -0.05 * c)
 return (-ts_delta(c, 1)
            .where(cond, 1)
            .stack('ticker')
            .swaplevel())






def alpha052(l, v, r):
 return (ts_delta(ts_min(l, 5), 5)
            .mul(rank(ts_sum(r, 240)
                      .sub(ts_sum(r, 20))
                      .div(220)))
            .mul(ts_rank(v, 5))
            .stack('ticker')
            .swaplevel())




def alpha053(h, l, c):
 inner = (c.sub(l)).add(1e-6)
 return (ts_delta(h.sub(c)
                     .mul(-1).add(1)
                     .div(c.sub(l)
                          .add(1e-6)), 9)
            .mul(-1)
            .stack('ticker')
            .swaplevel())




def alpha054(o, h, l, c):
 return (l.sub(c).mul(o.pow(5)).mul(-1)
            .div(l.sub(h).replace(0, -0.0001).mul(c ** 5))
            .stack('ticker')
            .swaplevel())




def alpha055(h, l, c, v):
 return (ts_corr(rank(c.sub(ts_min(l, 12))
                         .div(ts_max(h, 12).sub(ts_min(l, 12))
                              .replace(0, 1e-6))),
 rank(v), 6)
            .replace([-np.inf, np.inf], np.nan)
            .mul(-1)
            .stack('ticker')
            .swaplevel())




def alpha057(c, vwap):
 return (c.sub(vwap.add(1e-5))
            .div(ts_weighted_mean(rank(ts_argmax(c, 30)))).mul(-1)
            .stack('ticker')
            .swaplevel())




def alpha060(l, h, c, v):
 return (scale(rank(c.mul(2).sub(l).sub(h)
                       .div(h.sub(l).replace(0, 1e-5))
                       .mul(v))).mul(2)
            .sub(scale(rank(ts_argmax(c, 10)))).mul(-1)
            .stack('ticker')
            .swaplevel())




def alpha061(v, vwap):
 return (rank(vwap.sub(ts_min(vwap, 16)))
            .lt(rank(ts_corr(vwap, ts_mean(v, 180), 18)))
            .astype(int)
            .stack('ticker')
            .swaplevel())




def alpha062(o, h, l, vwap, adv20):
 return (rank(ts_corr(vwap, ts_sum(adv20, 22), 9))
            .lt(rank(
 rank(o).mul(2))
                .lt(rank(h.add(l).div(2))
                    .add(rank(h))))
            .mul(-1)
            .stack('ticker')
            .swaplevel())




def alpha064(o, h, l, v, vwap):
 w = 0.178404
 return (rank(ts_corr(ts_sum(o.mul(w).add(l.mul(1 - w)), 12),
 ts_sum(ts_mean(v, 120), 12), 16))
            .lt(rank(ts_delta(h.add(l).div(2).mul(w)
                              .add(vwap.mul(1 - w)), 3)))
            .mul(-1)
            .stack('ticker')
            .swaplevel())




def alpha065(o, v, vwap):
 w = 0.00817205
 return (rank(ts_corr(o.mul(w).add(vwap.mul(1 - w)),
 ts_mean(ts_mean(v, 60), 9), 6))
            .lt(rank(o.sub(ts_min(o, 13))))
            .mul(-1)
            .stack('ticker')
            .swaplevel())




def alpha066(o, l, h, vwap):
 w = 0.96633
 return (rank(ts_weighted_mean(ts_delta(vwap, 4), 7))
            .add(ts_rank(ts_weighted_mean(l.mul(w).add(l.mul(1 - w))
                                          .sub(vwap)
                                          .div(o.sub(h.add(l).div(2)).add(1e-3)), 11), 7))
            .mul(-1)
            .stack('ticker')
            .swaplevel())




def alpha068(h, l, c, v):
 w = 0.518371
 return (ts_rank(ts_corr(rank(h), rank(ts_mean(v, 15)), 9), 14)
            .lt(rank(ts_delta(c.mul(w).add(l.mul(1 - w)), 1)))
            .mul(-1)
            .stack('ticker')
            .swaplevel())




def alpha071(o, l, c, v, vwap):
 s1 = (ts_rank(ts_weighted_mean(ts_corr(ts_rank(c, 3),
 ts_rank(ts_mean(v, 180), 12), 18), 4), 16))
 s2 = (ts_rank(ts_weighted_mean(rank(l.add(o).
 sub(vwap.mul(2)))
                                   .pow(2), 16), 4))
 return (s1.where(s1 > s2, s2)
            .stack('ticker')
            .swaplevel())




def alpha072(h, l, v, vwap):
 return (rank(ts_weighted_mean(ts_corr(h.add(l).div(2), ts_mean(v, 40), 9), 10))
            .div(rank(ts_weighted_mean(ts_corr(ts_rank(vwap, 3), ts_rank(v, 18), 6), 2)))
            .stack('ticker')
            .swaplevel())




def alpha073(o, l, vwap):
 w = 0.147155
 s1 = rank(ts_weighted_mean(ts_delta(vwap, 5), 3))
 s2 = (ts_rank(ts_weighted_mean(ts_delta(o.mul(w).add(l.mul(1 - w)), 2)
                                   .div(o.mul(w).add(l.mul(1 - w)).mul(-1)), 3), 16))


 return (s1.where(s1 > s2, s2)
            .mul(-1)
            .stack('ticker')
            .swaplevel())




def alpha074(h, c, v, vwap):
 w = 0.0261661
 return (rank(ts_corr(c, ts_mean(ts_mean(v, 30), 37), 15))
            .lt(rank(ts_corr(rank(h.mul(w).add(vwap.mul(1 - w))), rank(v), 11)))
            .mul(-1)
            .stack('ticker')
            .swaplevel())




def alpha075(l, v, vwap):
 return (rank(ts_corr(vwap, v, 4))
            .lt(rank(ts_corr(rank(l), rank(ts_mean(v, 50)), 12)))
            .astype(int)
            .stack('ticker')
            .swaplevel())




def alpha077(l, h, v, vwap):
 s1 = rank(ts_weighted_mean(h.add(l).div(2).sub(vwap), 20))
 s2 = rank(ts_weighted_mean(ts_corr(h.add(l).div(2), ts_mean(v, 40), 3), 5))
 return (s1.where(s1 < s2, s2)
            .stack('ticker')
            .swaplevel())




def alpha078(l, v, vwap):
 w = 0.352233
 return (rank(ts_corr(ts_sum((l.mul(w).add(vwap.mul(1 - w))), 19),
 ts_sum(ts_mean(v, 40), 19), 6))
            .pow(rank(ts_corr(rank(vwap), rank(v), 5)))
            .stack('ticker')
            .swaplevel())




def alpha081(v, vwap):
 return (rank(log(ts_product(rank(rank(ts_corr(vwap,
 ts_sum(ts_mean(v, 10), 50), 8))
                                     .pow(4)), 15)))
            .lt(rank(ts_corr(rank(vwap), rank(v), 5)))
            .mul(-1)
            .stack('ticker')
            .swaplevel())




def alpha083(h, l, c, v, vwap):
 s = h.sub(l).div(ts_mean(c, 5))


 return (rank(rank(ts_lag(s, 2))
                 .mul(rank(rank(v)))
                 .div(s).div(vwap.sub(c).add(1e-3)))
            .stack('ticker')
            .swaplevel()
            .replace((np.inf, -np.inf), np.nan))




def alpha084(c, vwap):
 return (rank(power(ts_rank(vwap.sub(ts_max(vwap, 15)), 20),
 ts_delta(c, 6)))
            .stack('ticker')
            .swaplevel())




def alpha085(h, l, c, v):
 w = 0.876703
 return (rank(ts_corr(h.mul(w).add(c.mul(1 - w)), ts_mean(v, 30), 10))
            .pow(rank(ts_corr(ts_rank(h.add(l).div(2), 4),
 ts_rank(v, 10), 7)))
            .stack('ticker')
            .swaplevel())




def alpha086(c, v, vwap):
 return (ts_rank(ts_corr(c, ts_mean(ts_mean(v, 20), 15), 6), 20)
            .lt(rank(c.sub(vwap)))
            .mul(-1)
            .stack('ticker')
            .swaplevel())




def alpha088(o, h, l, c, v):
 s1 = (rank(ts_weighted_mean(rank(o)
                                .add(rank(l))
                                .sub(rank(h))
                                .add(rank(c)), 8)))
 s2 = ts_rank(ts_weighted_mean(ts_corr(ts_rank(c, 8),
 ts_rank(ts_mean(v, 60), 20), 8), 6), 2)


 return (s1.where(s1 < s2, s2)
            .stack('ticker')
            .swaplevel())




def alpha092(o, h, l, c, v):
 p1 = ts_rank(ts_weighted_mean(h.add(l).div(2).add(c).lt(l.add(o)), 15), 18)
 p2 = ts_rank(ts_weighted_mean(ts_corr(rank(l), rank(ts_mean(v, 30)), 7), 6), 6)


 return (p1.where(p1 < p2, p2)
            .stack('ticker')
            .swaplevel())




def alpha094(v, vwap):
 return (rank(vwap.sub(ts_min(vwap, 11)))
            .pow(ts_rank(ts_corr(ts_rank(vwap, 20),
 ts_rank(ts_mean(v, 60), 4), 18), 2))
            .mul(-1)
            .stack('ticker')
            .swaplevel())




def alpha095(o, h, l, v):
 return (rank(o.sub(ts_min(o, 12)))
            .lt(ts_rank(rank(ts_corr(ts_mean(h.add(l).div(2), 19),
 ts_sum(ts_mean(v, 40), 19), 13).pow(5)), 12))
            .astype(int)
            .stack('ticker')
            .swaplevel())




def alpha096(c, v, vwap):
 s1 = ts_rank(ts_weighted_mean(ts_corr(rank(vwap), rank(v), 10), 4), 8)
 s2 = ts_rank(ts_weighted_mean(ts_argmax(ts_corr(ts_rank(c, 7),
 ts_rank(ts_mean(v, 60), 10), 10), 12), 14), 13)
 return (s1.where(s1 > s2, s2)
            .mul(-1)
            .stack('ticker')
            .swaplevel())




def alpha098(o, v, vwap):
 adv5 = ts_mean(v, 5)
 adv15 = ts_mean(v, 15)
 return (rank(ts_weighted_mean(ts_corr(vwap, ts_mean(adv5, 26), 4), 7))
            .sub(rank(ts_weighted_mean(ts_rank(ts_argmin(ts_corr(rank(o),
 rank(adv15), 20), 8), 6))))
            .stack('ticker')
            .swaplevel())




def alpha099(h, l, v):
 return ((rank(ts_corr(ts_sum((h.add(l).div(2)), 19),
 ts_sum(ts_mean(v, 60), 19), 8))
             .lt(rank(ts_corr(l, v, 6)))
             .mul(-1))
            .stack('ticker')
            .swaplevel())




def alpha101(o, h, l, c):
 return (c.sub(o).div(h.sub(l).add(1e-3))
            .stack('ticker')
            .swaplevel())


class Alphas101:


 def __init__(self):
 memory = Memory(f""store/{get_name()}"", verbose=0)
 self.fit = memory.cache(self.fit)
 self.transform = memory.cache(self.transform)


 def fit(self, data):
 return self


 def transform(self, data):


 ohlcv = ['open', 'high', 'low', 'close', 'volume']
 adv20 = data.groupby('ticker').rolling(20).volume.mean().reset_index(0, drop=True)
 data = data.assign(adv20=adv20)
 data = data.join(data.groupby('date')[ohlcv].rank(axis=1, pct=True), rsuffix='_rank')
 data.dropna(inplace=True)


 o = data.open.unstack('ticker')
 h = data.high.unstack('ticker')
 l = data.low.unstack('ticker')
 c = data.close.unstack('ticker')
 v = data.volume.unstack('ticker')
 vwap = o.add(h).add(l).add(c).div(4)
 adv20 = v.rolling(20).mean()
 r = data.close.unstack('ticker').pct_change()


 alphas = []
 alphas.append(alpha001(c, r).rename('alpha001'))
 alphas.append(alpha002(o, c, v).rename('alpha002'))
 alphas.append(alpha003(o, v).rename('alpha003'))
 alphas.append(alpha004(l).rename('alpha004'))
 alphas.append(alpha005(o, vwap, c).rename('alpha005'))
 alphas.append(alpha006(o, v).rename('alpha006'))
 alphas.append(alpha007(c, v, adv20).rename('alpha007'))
 alphas.append(alpha008(o, r).rename('alpha008'))
 alphas.append(alpha009(c).rename('alpha009'))
 alphas.append(alpha010(c).rename('alpha010'))
 alphas.append(alpha011(c, vwap, v).rename('alpha011'))
 alphas.append(alpha012(v, c).rename('alpha012'))
 alphas.append(alpha013(c, v).rename('alpha013'))
 alphas.append(alpha014(o, v, r).rename('alpha014'))
 alphas.append(alpha015(h, v).rename('alpha015'))
 alphas.append(alpha016(h, v).rename('alpha016'))
 alphas.append(alpha017(c, v).rename('alpha017'))
 alphas.append(alpha018(o, c).rename('alpha018'))
 alphas.append(alpha019(c, r).rename('alpha019'))
 alphas.append(alpha020(o, h, l, c).rename('alpha020'))
 alphas.append(alpha021(c, v).rename('alpha021'))
 alphas.append(alpha022(h, c, v).rename('alpha022'))
 alphas.append(alpha023(h, c).rename('alpha023'))
 alphas.append(alpha024(c).rename('alpha024'))
 alphas.append(alpha025(h, c, r, vwap, adv20).rename('alpha025'))
 alphas.append(alpha026(h, v).rename('alpha026'))
 alphas.append(alpha027(v, vwap).rename('alpha027'))
 alphas.append(alpha028(h, l, c, v, adv20).rename('alpha028'))
 alphas.append(alpha029(c, r).rename('alpha029'))
 alphas.append(alpha030(c, v).rename('alpha030'))
 # alphas.append(alpha031(l, c, adv20).rename('alpha031')) # Produces all nans
 alphas.append(alpha032(c, vwap).rename('alpha032'))
 alphas.append(alpha033(o, c).rename('alpha033'))
 alphas.append(alpha034(c, r).rename('alpha034'))
 alphas.append(alpha035(h, l, c, v, r).rename('alpha035'))
 alphas.append(alpha036(o, c, v, r, adv20, vwap).rename('alpha036'))
 alphas.append(alpha037(o, c).rename('alpha037'))
 alphas.append(alpha038(o, c).rename('alpha038'))
 alphas.append(alpha039(c, v, r, adv20).rename('alpha039'))
 alphas.append(alpha040(h, v).rename('alpha040'))
 alphas.append(alpha041(h, l, vwap).rename('alpha041'))
 alphas.append(alpha042(c, vwap).rename('alpha042'))
 alphas.append(alpha043(c, v, adv20).rename('alpha043'))
 alphas.append(alpha044(h, v).rename('alpha044'))
 alphas.append(alpha045(c, v).rename('alpha045'))
 alphas.append(alpha046(c).rename('alpha046'))
 alphas.append(alpha047(h, c, v, vwap, adv20).rename('alpha047'))
 # alphas.append(alpha048(h, c, vwap, adv20).rename('alpha048'))  # No implementation
 alphas.append(alpha049(c).rename('alpha049'))
 alphas.append(alpha050(v, vwap).rename('alpha050'))
 alphas.append(alpha051(c).rename('alpha051'))
 alphas.append(alpha052(l, v, r).rename('alpha052'))
 alphas.append(alpha053(h, l, c).rename('alpha053'))
 alphas.append(alpha054(o, h, l, c).rename('alpha054'))
 alphas.append(alpha055(h, l, c, v).rename('alpha055'))
 # alphas.append(alpha056(h, l, c).rename('alpha056'))  # No implementation
 # alphas.append(alpha057(h, l, c).rename('alpha057'))  # No implementation
 # alphas.append(alpha058(h, l, c).rename('alpha057'))  # No implementation
 # alphas.append(alpha059(h, l, c).rename('alpha059'))  # No implementation
 alphas.append(alpha060(l, h, c, v).rename('alpha060'))
 alphas.append(alpha061(v, vwap).rename('alpha061'))
 alphas.append(alpha062(o, h, l, vwap, adv20).rename('alpha062'))
 # alphas.append(alpha063(o, h, l, vwap, adv20).rename('alpha063'))  # No implementation
 alphas.append(alpha064(o, h, l, v, vwap).rename('alpha064'))
 alphas.append(alpha065(o, v, vwap).rename('alpha065'))
 alphas.append(alpha066(o, l, h, vwap).rename('alpha066'))
 # alphas.append(alpha067(l, h, vwap).rename('alpha067'))
 alphas.append(alpha068(h, l, c, v).rename('alpha068'))
 # alphas.append(alpha069(h, c, v).rename('alpha069'))
 # alphas.append(alpha070(h, c, v).rename('alpha070'))
 alphas.append(alpha071(o, l, c, v, vwap).rename('alpha071'))
 alphas.append(alpha072(h, l, v, vwap).rename('alpha072'))
 alphas.append(alpha073(o, l, vwap).rename('alpha073'))
 alphas.append(alpha074(h, c, v, vwap).rename('alpha074'))
 alphas.append(alpha075(l, v, vwap).rename('alpha075'))
 # alphas.append(alpha076(l, v, vwap).rename('alpha076'))
 alphas.append(alpha077(l, h, v, vwap).rename('alpha077'))
 alphas.append(alpha078(l, v, vwap).rename('alpha078'))
 # alphas.append(alpha079(l, v, vwap).rename('alpha079'))
 # alphas.append(alpha080(l, v, vwap).rename('alpha080'))
 alphas.append(alpha081(v, vwap).rename('alpha081'))
 # alphas.append(alpha082(v, vwap).rename('alpha082'))
 alphas.append(alpha083(h, l, c, v, vwap).rename('alpha083'))
 alphas.append(alpha084(c, vwap).rename('alpha084'))
 alphas.append(alpha085(h, l, c, v).rename('alpha085'))
 alphas.append(alpha086(c, v, vwap).rename('alpha086'))
 # alphas.append(alpha087(c, v, vwap).rename('alpha087'))
 alphas.append(alpha088(o, h, l, c, v).rename('alpha088'))
 # alphas.append(alpha089(o, h, l, c, v).rename('alpha089'))
 # alphas.append(alpha090(o, h, l, c, v).rename('alpha090'))
 # alphas.append(alpha091(o, h, l, c, v).rename('alpha091'))
 alphas.append(alpha092(o, h, l, c, v).rename('alpha092'))
 # alphas.append(alpha093(o, l, c, v).rename('alpha093'))
 alphas.append(alpha094(v, vwap).rename('alpha094'))
 alphas.append(alpha095(o, h, l, v).rename('alpha095'))
 alphas.append(alpha096(c, v, vwap).rename('alpha096'))
 # alphas.append(alpha097(c, v, vwap).rename('alpha097'))
 alphas.append(alpha098(o, v, vwap).rename('alpha098'))
 alphas.append(alpha099(h, l, v).rename('alpha099'))
 # alphas.append(alpha100(l, v).rename('alpha100'))
 alphas.append(alpha101(o, h, l, c).rename('alpha101'))


 features = pd.concat(alphas, axis=1)
 features = features.reorder_levels(order=[1, 0])
 features = features.sort_index()
 return features"
browsersync.js,"// =========================================================
// Gulp Task: browsersync
// NOTE: Using gulp v4
// Description:  Sync sass, typescript, html, and browser
// using external config or add modify src
// npm install --save-dev browser-sync gulp-typescript gulpjs/gulp.git#4.0 gulp-load-plugins
// Options: node-sass gulp-sass || gulp-ruby-sass
// =========================================================
var config = require('../config.js');
var browserSync = require('browser-sync').create();


module.exports = function(gulp, plugins) {
 return function () {
 var stream = 
// -------------------------------------------- Start Task
 browserSync.init(config.browsersync.opts);


 browserSync.watch(config.sass.src, gulp.series('sass'));
 browserSync.watch(config.typescript.src, gulp.series('ts'));
 browserSync.watch(config.browsersync.watch).on('change', browserSync.reload);
// ---------------------------------------------- End Task
 return stream;
 };
};
// =========================================================
// Gulp Task: clean
// Description: deletes dist folder
// npm install --save-del del gulp-load-plugins
// =========================================================
var config = require('../config.js'),
 del = require('del');


module.exports = function(gulp, plugins) {
 return function (cb) {
 var stream = 
// -------------------------------------------- Start Task
 // del(config.clean.folders, cb);
 del('./dist/', cb);
// ---------------------------------------------- End Task
 return stream;
 };
};
// =========================================================
// Project: PROJECT-NAME
// =========================================================
// ------------------------------------------ Export Configs
module.exports = {
 production: false, // use to programmatically operate on 
 // gulp tasks based on environment
// -------------------------------------------- autoprefixer
 autoprefixer: {
 opts: {
 browsers: ['last 3 versions']
 }
 },
// --------------------------------------------- browsersync
 browsersync: {
 opts: {
 server: './src/'
 },
 watch: [
 './src/assets/styles/css/**/*.css',
 './src/assets/scripts/js/**/*.js',
 './src/**/*.html'
 ]
 },
// --------------------------------------------------- clean
 clean: {
 folders: [
 './dist/'
 ] 
 },
 html: {
 src: ['./src/**/*.html', '!src/assets/bin/**/*'],
 htmlmin: { // In case more html file operations are needed.
 opts: {
 // https://github.com/kangax/html-minifier
 collapseWhitespace: true,
 removeComments: true
 }
 },
 dest: './dist/'
 },
// ------------------------------------------------ new-task
 newtask: {
 src: [
 ""./gulp/utils/newTaskTemplate.js""
 ],
 outputName: ""TASK-TEMPLATE.js"",
 dest: ""./gulp/tasks/""
 },
// -------------------------------------------------- rename
 rename: {
 min: { suffix: '.min' }
 },
// ---------------------------------------------------- sass
 sass: {
 src: [
 ""./src/assets/styles/sass/**/*.{scss,sass}""
 ],
 opts: { }, // add sass options here
 outputName: 'main.css',
 dest: './src/assets/styles/css/'
 },
// ------------------------------------------------- scripts
 scripts: {
 src: [
 './src/assets/scripts/js/**/*.js',
 ],
 dest: './dist/assets/js'
 },
// -------------------------------------------------- styles
 styles: {
 src: [
 './src/assets/styles/css/**/*.css',
 ],
 dest: './dist/assets/css'
 },
// ---------------------------------------------- typescript
 typescript: {
 src: [
 './src/assets/scripts/ts/**/*.ts'
 ],
 dest: './src/assets/scripts/js',
 opts: {
 noImplicitAny: true
 }
 },
// ------------------------------------------------- vendors
 vendors: {
 js: {
 src: [
 './bower_components/bootstrap/dist/js/bootstrap.min.js',
 './bower_components/jquery/dist/jquery.min.js',
 './src/assets/bin/bootstrap-4.0.0-alpha/dist/js/bootstrap.min.js'
 ],
 dest: './dist/assets/js/vendors'
 },
 css: {
 src: [
 './bower_components/font-awesome/css/font-awesome.min.css',
 './bower_components/font-awesome/css/font-awesome.css.map',
 './bower_components/bootstrap/dist/css/bootstrap.min.css',
 './bower_components/bootstrap/dist/css/bootstrap.min.css.map'
 ],
 dest: './dist/assets/css/vendors'
 },
 sass: {
 // NOTE: This is to perform operations on the sass files
 src: [
 './bower_components/font-awesome/scss/**/*.scss', // ex
 './src/assets/bin/bootstrap-4.0.0-alpha/scss/**/*.scss' // ex
 ],
 opts: { },
 dest: './dist/assets/css/vendors'
 },
 less: {
 src: [
 './bower_components/bootstrap/less/**/*.less'
 ],
 opts: { },
 dest: './dist/assets/css/vendors'
 },
 fonts: {
 src: [
 './bower_components/bootstrap/fonts/**/*.*',
 './bower_components/font-awesome/fonts/**/*.*'
 ],
 dest: './dist/assets/fonts'
 }
 }
}
// =========================================================
// Project: PROJECT-NAME
// NOTE: Using Gulp 4
// npm install --save-dev gulp-load-plugins gulpjs/gulp.git#4.0
// =========================================================
var gulp = require('gulp'),
 config = require('./gulp/config'),
 plugins = require('gulp-load-plugins')();


// ---------------------------------- Gulp Terminal Commands
// ---- gulp
// ---- gulp build
// ---- gulp new-task


// --------------------function to get tasks from gulp/tasks
function getTask(task) {
 return require('./gulp/tasks/' + task)(gulp, plugins);
}


// ---------------------------------------------- Gulp Tasks
gulp.task('sass', getTask('sass'));
gulp.task('scripts', getTask('scripts'));
gulp.task('styles', getTask('styles'));
gulp.task('ts', getTask('typescript'));
gulp.task('new-task', getTask('new-task'));
gulp.task('sync', getTask('browsersync'));
gulp.task('clean', getTask('clean'));
gulp.task('moveDist', getTask('move-dist'));
gulp.task('vendors', getTask('vendors'));
gulp.task('html', getTask('html'));


// --------------------------------------- Default Gulp Task
gulp.task('default', gulp.series(
 gulp.parallel('sass', 'ts'), 'sync')
);


// ---------------------------------------------- gulp build
// vendors - task which moves and operates on node_modules
// and bower_components dependencies
// moveDist: moves dist folder to another location
// on the file system (useful for multiple repos e.g. gh-pages)
gulp.task('build', gulp.series('clean',
 gulp.parallel('scripts', 'styles', 'html'), 'vendors', 'moveDist')
);




// =========================================================
// Basic example of gulp multifile tasks folder structure
// =========================================================
// **** Project-Directory/
// ------ gulpfile.js
// ****** src/
// ****** dist/
// ****** gulp/
// -------- config.js
// ******** tasks/
// ******** utils/
// ----------- newTaskTemplate.js
// =========================================================
// Gulp Task: html
// Description: minify html
// Dependencies: npm install --save-dev gulp-htmlmin
// =========================================================
var config = require('../config.js');


module.exports = function(gulp, plugins) {
 return function () {
 var stream = 
// -------------------------------------------- Start Task
 gulp.src(config.html.src)
 .pipe(plugins.htmlmin(config.html.htmlmin.opts))
 .pipe(gulp.dest(config.html.dest));
// ---------------------------------------------- End Task
 return stream;
 };
};
// =========================================================
// Gulp Task: moveDist
// Description: move dist folder to external folder. Useful
// for multirepo projects. e.g. a gh-pages-site.
// npm install --save-dev gulp-load-plugins
// =========================================================
var config = require('../config.js');


module.exports = function(gulp, plugins) {
 return function () {
 var stream = 
// -------------------------------------------- Start Task
 gulp.src('./dist/**/*.*')
 .pipe(gulp.dest('./../gh-pages-site'));
// ---------------------------------------------- End Task
 return stream;
 };
};
// =========================================================
// Gulp Task: newTask
// Description: creates a new multifile task template
// Dependencies: npm install gulp-rename gulp-load-plugins
// =========================================================
var config = require('../config.js');


module.exports = function(gulp, plugins) {
 return function() {
 var stream = 
// -------------------------------------------- Start Task
 gulp.src(config.newtask.src)
 .pipe(plugins.rename(config.newtask.outputName))
 .pipe(gulp.dest(config.newtask.dest));
// ---------------------------------------------- End Task
 return stream;
 };
};
// =========================================================
// Gulp Task: 
// Description: 
// Dependencies: npm install 
// =========================================================
var config = require('../config.js');


module.exports = function(gulp, plugins) {
 return function () {
 var stream = 
// -------------------------------------------- Start Task
 gulp.src('')
// ---------------------------------------------- End Task
 return stream;
 };
};
// =========================================================
// Gulp Task: sass
// Description: transpiles sass, adds sourcemaps, prefixes
// npm install --save-dev node-sass gulp-sass gulp-sourcemaps gulp-autoprefixer gulp-load-plugins
// =========================================================
var config = require('../config.js');


module.exports = function(gulp, plugins) {
 return function () {
 var stream = 
// -------------------------------------------- Start Task
 gulp.src(config.sass.src)
 .pipe(plugins.sourcemaps.init())
 .pipe(plugins.sass().on('error', plugins.sass.logError))
 .pipe(plugins.autoprefixer(config.autoprefixer.opts))
 .pipe(plugins.sourcemaps.write('.'))
 .pipe(gulp.dest(config.sass.dest))
// ---------------------------------------------- End Task
 return stream;
 };
};
// =========================================================
// Gulp Task: scripts
// Description: uglify all js, add sourcemaps, rename
// npm install --save-dev gulp-uglify gulp-rename gulp-sourcemaps merge-stream gulp-load-plugins
// =========================================================
var config = require('../config.js'),
 merge = require('merge-stream');


module.exports = function(gulp, plugins) {
 return function () { 
// -------------------------------------------------- src js
 var stream = 
 gulp.src(config.scripts.src)
 .pipe(plugins.sourcemaps.init())
 .pipe(plugins.uglify())
 .pipe(plugins.rename(config.rename.min))
 .pipe(plugins.sourcemaps.write('.'))
 .pipe(gulp.dest(config.dist.scripts.js));
// ------------------------------------------------ End Task
 return stream;
 };
};
// =========================================================
// Gulp Task: styles
// Description: minify all css, add sourcemaps, rename
// Dependencies: npm install --save-dev gulp-minify-css gulp-rename gulp-sourcemaps gulp-load-plugins
// =========================================================
var config = require('../config.js');


module.exports = function(gulp, plugins) {
 return function () {
 var stream = 
// -------------------------------------------- Start Task
 gulp.src(config.styles.src)
 .pipe(plugins.sourcemaps.init())
 .pipe(plugins.minifyCss())
 .pipe(plugins.rename(config.rename.min))
 .pipe(plugins.sourcemaps.write('.'))
 .pipe(gulp.dest(config.dist.styles.css));
// ---------------------------------------------- End Task
 return stream;
 };
};
// =========================================================
// Gulp Task: typescript
// Description: Transpile .ts files and add sourcemaps
// npm install --save-dev gulp-typescript gulp-sourcemaps gulp-load-plugins
// =========================================================
var config = require('../config.js');


module.exports = function(gulp, plugins) {
 return function () {
 var stream = 
// -------------------------------------------- Start Task
 gulp.src(config.typescript.src)
 .pipe(plugins.sourcemaps.init())
 .pipe(plugins.typescript(config.typescript.opts));


// ---------------------------------------------- End Task
 return stream.js.pipe(plugins.sourcemaps.write('.')).pipe(gulp.dest(config.typescript.dest));
 };
};
// =========================================================
// Gulp Task: vendors
// Description: move all node and bower dependencies to dist
// easily add sass, less, etc. Operate on each as needed.
// basic configuration supplied
// npm install --save-dev merge-stream gulp-newer
// gulp-load-plugins
// =========================================================
var config = require('../config.js'),
 merge = require('merge-stream');


module.exports = function(gulp, plugins) {
 return function () {
// ---------------------------------------------- Start Task
// ---- move js files
 var js = 
 gulp.src(config.vendors.js.src)
 .pipe(plugins.newer(config.vendors.js.dest))
 .pipe(gulp.dest(config.vendors.js.dest));


// ---- move css files
 var css =
 gulp.src(config.vendors.css.src)
 .pipe(plugins.newer(config.vendors.css.dest))
 .pipe(gulp.dest(config.vendors.css.dest));


// ---- move font files
 var fonts =
 gulp.src(config.vendors.fonts.src)
 .pipe(plugins.newer(config.vendors.fonts.dest))
 .pipe(gulp.dest(config.vendors.fonts.dest));
 
// ---- sass
 // var sass =
 // gulp.src(config.vendors.sass.src)
 //     .pipe(plugins.newer(config.vendors.sass.dest))
 //     .pipe(gulp.dest(config.vendors.sass.dest));


// ---- less
 // var sass =
 // gulp.src(config.vendors.less.src)
 //     .pipe(plugins.newer(config.vendors.less.dest))
 //     .pipe(gulp.dest(config.vendors.less.dest));


// ------------------------------------------------ End Task
 return merge( js, css, fonts ); // add sass and/or less
 };
};"
celery_app.py,"import multiprocessing
import re
from celery import Celery
from celery.worker.autoscale import Autoscaler as CeleryAutoscaler


class DAAutoscaler(CeleryAutoscaler):
 # Try to keep the load above this point.
 LOAD_MIN = .8
 # Try to keep the load below this.
 LOAD_MAX = 1.1
 # We need this percentage of free memory to scale up.
 MEM_FREE_SCALE_UP = .3
 # Any less than this memory and we scale down.
 MEM_FREE_SCALE_DOWN = .2
 
 def __init__(self, *args, **kwargs):
 self.num_cpus = multiprocessing.cpu_count()
 logging.info(""DAAutoscaler: Num CPUs %s"", self.num_cpus)
 super(DAAutoscaler, self).__init__(*args, **kwargs)
 
 def _maybe_scale(self, req = None):
 '''Scale up or down if we too much/little load or memory.'''
 cur_load = self._get_load()
 mem_free = self._get_free_mem()
 if cur_load < self.LOAD_MIN and mem_free > self.MEM_FREE_SCALE_UP:
 mul = int(self.LOAD_MAX / cur_load)
 logging.info(""DAAutoscaler: Scale Up %dX %.2f free=%.2f%%"",
 mul, cur_load, 100*mem_free)
 self.scale_up(1)
 return True
 if cur_load > self.LOAD_MAX or mem_free < self.MEM_FREE_SCALE_DOWN:
 mul = int(cur_load / self.LOAD_MAX)
 logging.info(""DAAutoscaler: Scale Down %dX %.2f free=%.2f%%"", 
 mul, cur_load, 100*mem_free)
 self.scale_down(mul)
 return True
 logging.info(""DAAutoscaler: Ok %.2f .2f%%"", cur_load, 100*mem_free)
 
 def _get_load(self):
 load1min, load5min, load15min = os.getloadavg()
 # Prevent divide by zero
 if load1min < 0.001:
 load1min = 0.001
 return 1.0 * load1min / self.num_cpus
 
 re_total = re.compile(r""MemTotal:\s+(?P<total>\d+)\s+kB"")
 re_free = re.compile(r""MemFree:\s+(?P<free>\d+)\s+kB"")
 def _get_free_mem(self):
 '''Return percentage of free memory 0.0 to 1.0.'''
 try:
 # Try using the cross platform method.
 import psutil
 except ImportError:
 # If not, make it work for most linux distros.
 with open('/proc/meminfo', 'rb') as f:
 mem = f.read()
 return (1.0 * int(self.re_free.search(mem).group(""free"")) /
 int(self.re_total.search(mem).group(""total"")))
 else:
 return psutil.virtual_memory().percent / 100"
main.py,"import requests
import json
import gradio as gr


url = ""http://localhost:11434/api/generate""


headers = {
 'Content-Type': 'application/json',
}


conversation_history = []


def generate_response(prompt):
 conversation_history.append(prompt)


 full_prompt = ""\n"".join(conversation_history)


 data = {
 ""model"": ""mistral"",
 ""stream"": False,
 ""prompt"": full_prompt,
    }


 response = requests.post(url, headers=headers, data=json.dumps(data))


 if response.status_code == 200:
 response_text = response.text
 data = json.loads(response_text)
 actual_response = data[""response""]
 conversation_history.append(actual_response)
 return actual_response
 else:
 print(""Error:"", response.status_code, response.text)
 return None


iface = gr.Interface(
 fn=generate_response,
 inputs=gr.inputs.Textbox(lines=2, placeholder=""Enter your prompt here...""),
 outputs=""text""
)


iface.launch()"
ctc_decoder.py,"""""""
Author: Awni Hannun

This is an example CTC decoder written in Python. The code is
intended to be a simple example and is not designed to be
especially efficient.

The algorithm is a prefix beam search for a model trained
with the CTC loss function.

For more details checkout either of these references:
  https://distill.pub/2017/ctc/#inference
  https://arxiv.org/abs/1408.2873

""""""


import numpy as np
import math
import collections


NEG_INF = -float(""inf"")


def make_new_beam():
 fn = lambda : (NEG_INF, NEG_INF)
 return collections.defaultdict(fn)


def logsumexp(*args):
 """"""
  Stable log sum exp.
  """"""
 if all(a == NEG_INF for a in args):
 return NEG_INF
 a_max = max(args)
 lsp = math.log(sum(math.exp(a - a_max)
 for a in args))
 return a_max + lsp


def decode(probs, beam_size=100, blank=0):
 """"""
  Performs inference for the given output probabilities.

  Arguments:
      probs: The output probabilities (e.g. post-softmax) for each
        time step. Should be an array of shape (time x output dim).
      beam_size (int): Size of the beam to use during inference.
      blank (int): Index of the CTC blank label.

  Returns the output label sequence and the corresponding negative
  log-likelihood estimated by the decoder.
  """"""
 T, S = probs.shape
 probs = np.log(probs)


 # Elements in the beam are (prefix, (p_blank, p_no_blank))
 # Initialize the beam with the empty sequence, a probability of
 # 1 for ending in blank and zero for ending in non-blank
 # (in log space).
 beam = [(tuple(), (0.0, NEG_INF))]


 for t in range(T): # Loop over time


 # A default dictionary to store the next step candidates.
 next_beam = make_new_beam()


 for s in range(S): # Loop over vocab
 p = probs[t, s]


 # The variables p_b and p_nb are respectively the
 # probabilities for the prefix given that it ends in a
 # blank and does not end in a blank at this time step.
 for prefix, (p_b, p_nb) in beam: # Loop over beam


 # If we propose a blank the prefix doesn't change.
 # Only the probability of ending in blank gets updated.
 if s == blank:
 n_p_b, n_p_nb = next_beam[prefix]
 n_p_b = logsumexp(n_p_b, p_b + p, p_nb + p)
 next_beam[prefix] = (n_p_b, n_p_nb)
 continue


 # Extend the prefix by the new character s and add it to
 # the beam. Only the probability of not ending in blank
 # gets updated.
 end_t = prefix[-1] if prefix else None
 n_prefix = prefix + (s,)
 n_p_b, n_p_nb = next_beam[n_prefix]
 if s != end_t:
 n_p_nb = logsumexp(n_p_nb, p_b + p, p_nb + p)
 else:
 # We don't include the previous probability of not ending
 # in blank (p_nb) if s is repeated at the end. The CTC
 # algorithm merges characters not separated by a blank.
 n_p_nb = logsumexp(n_p_nb, p_b + p)
 
 # *NB* this would be a good place to include an LM score.
 next_beam[n_prefix] = (n_p_b, n_p_nb)


 # If s is repeated at the end we also update the unchanged
 # prefix. This is the merging case.
 if s == end_t:
 n_p_b, n_p_nb = next_beam[prefix]
 n_p_nb = logsumexp(n_p_nb, p_nb + p)
 next_beam[prefix] = (n_p_b, n_p_nb)


 # Sort and trim the beam before moving on to the
 # next time-step.
 beam = sorted(next_beam.items(),
 key=lambda x : logsumexp(*x[1]),
 reverse=True)
 beam = beam[:beam_size]


 best = beam[0]
 return best[0], -logsumexp(*best[1])


if __name__ == ""__main__"":
 np.random.seed(3)


 time = 50
 output_dim = 20


 probs = np.random.rand(time, output_dim)
 probs = probs / np.sum(probs, axis=1, keepdims=True)


 labels, score = decode(probs)
 print(""Score {:.3f}"".format(score))"
mindwave.py,"import numpy as np
import pandas as pd
import sys
import json
import time
from telnetlib import Telnet


# Initializing the arrays required to store the data.
attention_values = np.array([])
meditation_values = np.array([])
delta_values = np.array([])
theta_values = np.array([])
lowAlpha_values = np.array([])
highAlpha_values = np.array([])
lowBeta_values = np.array([])
highBeta_values = np.array([])
lowGamma_values = np.array([])
highGamma_values = np.array([])
blinkStrength_values = np.array([])
time_array = np.array([])


tn=Telnet('localhost',13854);


start=time.clock();


i=0;
tn.write('{""enableRawOutput"": true, ""format"": ""Json""}');




outfile=""null"";
if len(sys.argv)>1:
 outfile=sys.argv[len(sys.argv)-1];
 outfptr=open(outfile,'w');


eSenseDict={'attention':0, 'meditation':0};
waveDict={'lowGamma':0, 'highGamma':0, 'highAlpha':0, 'delta':0, 'highBeta':0, 'lowAlpha':0, 'lowBeta':0, 'theta':0};
signalLevel=0;


while time.clock() - start < 30:
 blinkStrength=0;
 line=tn.read_until('\r');
 if len(line) > 20:	
 timediff=time.clock()-start;
 dict=json.loads(str(line));
 if ""poorSignalLevel"" in dict:
 signalLevel=dict['poorSignalLevel'];
 if ""blinkStrength"" in dict:
 blinkStrength=dict['blinkStrength'];
 if ""eegPower"" in dict:
 waveDict=dict['eegPower'];
 eSenseDict=dict['eSense'];
 outputstr=str(timediff)+ "", ""+ str(signalLevel)+"", ""+str(blinkStrength)+"", "" + str(eSenseDict['attention']) + "", "" + str(eSenseDict['meditation']) + "", ""+str(waveDict['lowGamma'])+"", "" + str(waveDict['highGamma'])+"", ""+ str(waveDict['highAlpha'])+"", ""+str(waveDict['delta'])+"", ""+ str(waveDict['highBeta'])+"", ""+str(waveDict['lowAlpha'])+"", ""+str(waveDict['lowBeta'])+ "", ""+str(waveDict['theta']);
 time_array = np.append(time_array, [timediff]);
 blinkStrength_values = np.append(blinkStrength_values, [blinkStrength]);
 lowGamma_values = np.append(lowGamma_values, [waveDict['lowGamma']]);
 highGamma_values = np.append(highGamma_values, [waveDict['highGamma']]);
 highAlpha_values = np.append(highAlpha_values, [waveDict['highAlpha']]);
 delta_values = np.append(delta_values, [waveDict['delta']]);
 lowBeta_values = np.append(lowBeta_values, [waveDict['lowBeta']]);
 highBeta_values = np.append(highBeta_values, [waveDict['highBeta']]);
 theta_values = np.append(theta_values, [waveDict['theta']]);
 lowAlpha_values = np.append(lowAlpha_values, [waveDict['lowAlpha']]);
 attention_values = np.append(attention_values, [eSenseDict['attention']]);
 meditation_values = np.append(meditation_values, [eSenseDict['meditation']]);
 print (outputstr);
 if outfile!=""null"":	
 outfptr.write(outputstr+""\n"");		


person_name = input('Enter the name of the person: ')
blink_label = input('Enter left or right eye blink(1 for left, 2 for right): ')
time_starting = input('When does TGC start: ')
lefty_righty = input('Is the person left-handed or right-handed: ')
time_blinking = input('The time of the blink: ')


# Data Recorded for a single person
data_row = pd.DataFrame({'Name': person_name, 'attention': [attention_values], 'meditation': [meditation_values], 'delta': [delta_values], 'theta': [theta_values], 'lowAlpha': [lowAlpha_values], 'highAlpha': [highAlpha_values], 'lowBeta': [lowBeta_values], 'highBeta': [highBeta_values],
 'lowGamma':[lowGamma_values] , 'highGamma': [highGamma_values], 'blinkStrength': [blinkStrength_values], 'time': [time_array], 'LOR': blink_label})


# Reading the data stored till now
dataset = pd.read_csv('data_eeg.csv')


from numpy import nan as Nan


dataset = dataset.append(pd.Series([blink_label, person_name, [attention_values], [blinkStrength_values], [delta_values]
	, [highAlpha_values], [highBeta_values], [highGamma_values], [lowAlpha_values], [lowBeta_values], [lowGamma_values], [meditation_values], 
	[theta_values], [time_array], time_starting, lefty_righty, time_blinking], index=['LOR', 'Name', 'attention', 'blinkStrength', 'delta', 'highAlpha', 'highBeta', 'highGamma', 'lowAlpha', 'lowBeta', 'lowGamma', 'meditation', 'theta', 'time', 'time_start', 'LTYRTY', 'time_blink']),  ignore_index = True)


#Appending and storing the data in the same csv
#dataset.append(data_row)
dataset.to_csv('data_eeg.csv')      
 
tn.close();
#outfptr.close();"
main.py,"import requests
import json
import gradio as gr


url = ""http://localhost:11434/api/generate""


headers = {
 'Content-Type': 'application/json',
}


conversation_history = []


def generate_response(prompt):
 conversation_history.append(prompt)


 full_prompt = ""\n"".join(conversation_history)


 data = {
 ""model"": ""mistral"",
 ""stream"": False,
 ""prompt"": full_prompt,
    }


 response = requests.post(url, headers=headers, data=json.dumps(data))


 if response.status_code == 200:
 response_text = response.text
 data = json.loads(response_text)
 actual_response = data[""response""]
 conversation_history.append(actual_response)
 return actual_response
 else:
 print(""Error:"", response.status_code, response.text)
 return None


iface = gr.Interface(
 fn=generate_response,
 inputs=gr.inputs.Textbox(lines=2, placeholder=""Enter your prompt here...""),
 outputs=""text""
)


iface.launch()"
cohere_embed_v3.py,"# This snippet shows and example how to use the Cohere Embed V3 models for semantic search.
# Make sure to have the Cohere SDK in at least v4.30 install: pip install -U cohere 
# Get your API key from: www.cohere.com
import cohere
import numpy as np


cohere_key = ""{YOUR_COHERE_API_KEY}"" #Get your API key from www.cohere.com
co = cohere.Client(cohere_key)


docs = [""The capital of France is Paris"",
 ""PyTorch is a machine learning framework based on the Torch library."",
 ""The average cat lifespan is between 13-17 years""]




#Encode your documents with input type 'search_document'
doc_emb = co.embed(docs, input_type=""search_document"", model=""embed-english-v3.0"").embeddings
doc_emb = np.asarray(doc_emb)




#Encode your query with input type 'search_query'
query = ""What is Pytorch""
query_emb = co.embed([query], input_type=""search_query"", model=""embed-english-v3.0"").embeddings
query_emb = np.asarray(query_emb)
query_emb.shape


#Compute the dot product between query embedding and document embedding
scores = np.dot(query_emb, doc_emb.T)[0]


#Find the highest scores
max_idx = np.argsort(-scores)


print(f""Query: {query}"")
for idx in max_idx:
 print(f""Score: {scores[idx]:.2f}"")
 print(docs[idx])
 print(""--------"")"
main.py,"# dependencies
# pip install -U openai gradio


import os, openai
import gradio as gr
openai.api_key = 'sk-xxxxxx'


messages = [{""role"": ""system"", ""content"": """"""Assistant is an expert candidate in
             technical IT job interviews. Currently, the interview is
             focused on a position for Platform Engineer. So, you have skills
             with Terraform, Kubernetes, Docker, Ansible, Python, AWS, and
             more. For technical code questions, use Python. Provide clear,
             short, and concise answers and code. 
             Answers should look human and avoid too much formality when replying.
             Always provide answers in English!""""""}]


def transcribe(audio):
 global messages


 audio_filename_with_extension = audio + '.mp3'
 os.rename(audio, audio_filename_with_extension)


 audio_file = open(audio_filename_with_extension, ""rb"")
 transcript = openai.audio.transcriptions.create(
 model=""whisper-1"",
 file=audio_file,
 response_format=""text"",
 language='en'
    )


 messages.append({""role"": ""user"", ""content"": transcript})


 response = openai.chat.completions.create(model=""gpt-4-1106-preview"", messages=messages)


 message_role = response.choices[0].message.role
 message_content = response.choices[0].message.content
 messages.append({""role"": message_role, ""content"": message_content})


 chat_transcript = """"
 for message in messages:
 if message['role'] != 'system':
 chat_transcript += message['role'] + "": "" + message['content'] + ""\n\n""
 return chat_transcript




ui = gr.Interface(fn=transcribe, inputs=gr.Audio(sources=[""microphone""], type=""filepath""), outputs=""text"").launch()
ui.launch()"
vimeo-download.py,"import requests
import base64
from tqdm import tqdm




master_json_url = 'https://178skyfiregce-a.akamaihd.net/exp=1474107106~acl=%2F142089577%2F%2A~hmac=0d9becc441fc5385462d53bf59cf019c0184690862f49b414e9a2f1c5bafbe0d/142089577/video/426274424,426274425,426274423,426274422/master.json?base64_init=1'
base_url = master_json_url[:master_json_url.rfind('/', 0, -26) + 1]


resp = requests.get(master_json_url)
content = resp.json()


heights = [(i, d['height']) for (i, d) in enumerate(content['video'])]
idx, _ = max(heights, key=lambda (_, h): h)
video = content['video'][idx]
video_base_url = base_url + video['base_url']
print 'base url:', video_base_url


filename = 'video_%d.mp4' % video['id']
print 'saving to %s' % filename


video_file = open(filename, 'wb')


init_segment = base64.b64decode(video['init_segment'])
video_file.write(init_segment)


for segment in tqdm(video['segments']):
 segment_url = video_base_url + segment['url']
 resp = requests.get(segment_url, stream=True)
 if resp.status_code != 200:
 print 'not 200!'
 print resp
 print segment_url
 break
 for chunk in resp:
 video_file.write(chunk)


video_file.flush()
video_file.close()"
inpaint-person.py,"""""""
Remove a person from an image using a stable diffusion server

This short demo accompanies the Medium article ""Stable Diffusion as an API: Make a Person-Removing Microservice"".
The full article can be found here: https://towardsdatascience.com/stable-diffusion-as-an-api-5e381aec1f6

Example usage:
    python inpaint-person.py my-image.jpg -W 768 -H 768 -o my-output.png
""""""


import os
import json
import base64
import io


import requests
import torch
from torchvision.models.segmentation import fcn_resnet50, FCN_ResNet50_Weights
from torchvision import transforms
from torchvision.io.image import read_image




IMG2IMG_URL = 'http://127.0.0.1:7860/sdapi/v1/img2img'




def generate_request(b64image: str, prompt: str, **kwargs):
 """"""
    Generate a request object from the given input image and prompt.
    """"""
 return {
 'prompt': prompt,
 'init_images': [b64image],
 **kwargs
    }




def submit_post(url: str, data: dict):
 """"""
    Submit a POST request to the given URL with the given data.
    """"""
 return requests.post(url, data=json.dumps(data))




def _b64encode(x: bytes) -> str:
 return base64.b64encode(x).decode(""utf-8"")




def img2b64(img):
 """"""
    Convert a PIL image to a base64-encoded string.
    """"""
 buffered = io.BytesIO()
 img.save(buffered, format='PNG')
 return _b64encode(buffered.getvalue())




def convert_mask_to_bounding_box(mask, dilation: int = 16) -> torch.Tensor:
 """"""
    Convert a mask to its bounding box.
    """"""
 # Get indices of mask
 mask_indices = torch.nonzero(mask)


 # Get bounding box
 min_y, min_x = mask_indices.min(dim=0)[0]
 max_y, max_x = mask_indices.max(dim=0)[0]


 # Dilate mask
 min_y = int(max(0, min_y - dilation))
 min_x = int(max(0, min_x - dilation))
 max_y = int(min(mask.shape[0], max_y + dilation))
 max_x = int(min(mask.shape[1], max_x + dilation))


 # Set bounding box to 1
 mask[min_y:max_y, min_x:max_x] = 1
 return mask




def save_encoded_image(b64_image: str, output_path: str):
 """"""
    Save the given image to the given output path.
    """"""
 
 with open(output_path, ""wb"") as image_file:
 image_file.write(base64.b64decode(b64_image))




INPAINTING_FILL_METHODS = ['fill', 'original', 'latent_noise', 'latent_nothing']




if __name__ == '__main__':
 import argparse
 parser = argparse.ArgumentParser(description='Inpaint instances of people using stable '
 'diffusion.')
 parser.add_argument('img_path', type=str, help='Path to input image.')
 parser.add_argument('-o', '--output_path', type=str, default='inpaint-person.png',
 help='Path to output image.')
 parser.add_argument('-p', '--prompt', type=str, default='',
 help='Stable diffusion prompt to use.')
 parser.add_argument('-n', '--negative_prompt', type=str, default='person',
 help='Stable diffusion negative prompt.')
 parser.add_argument('-W', '--width', type=int, default=768, help='Width of output image.')
 parser.add_argument('-H', '--height', type=int, default=768, help='Height of output image.')
 parser.add_argument('-s', '--steps', type=int, default=30, help='Number of diffusion steps.')
 parser.add_argument('-c', '--cfg_scale', type=int, default=8, help='Classifier free guidance '
 'scale, i.e. how strongly the image should conform to prompt.')
 parser.add_argument('-S', '--sampler_name', type=str, default='Euler a', help='Name of sampler '
 'to use.')
 parser.add_argument('-d', '--denoising_strength', type=float, default=0.75, help='How much to '
 'disregard original image.')
 parser.add_argument('-f', '--fill', type=str, default=INPAINTING_FILL_METHODS[0],
 help='The fill method to use for inpainting.')
 parser.add_argument('-b', '--mask_blur', type=int, default=8, help='Blur radius of Gaussian '
 'filter to apply to mask.')
 parser.add_argument('-B', '--bounding_box', action='store_true', help='Convert mask to '
 'bounding box.')
 parser.add_argument('-D', '--bbox_dilation', type=float, default=16, help='Number of pixels '
 'to dilate bounding box.')
 args = parser.parse_args()
 assert args.fill in INPAINTING_FILL_METHODS, \
 f'Fill method must be one of {INPAINTING_FILL_METHODS}.'


 # Load image
 img = read_image(args.img_path)
 img = img[:3] if img.shape[0] > 3 else img


 # Load model
 weights = FCN_ResNet50_Weights.DEFAULT
 model = fcn_resnet50(weights=weights, progress=False)
 model = model.eval()


 # Run model
 input_tform = weights.transforms(resize_size=None)
 batch = torch.stack([input_tform(img)])
 output = model(batch)['out']


 # Apply softmax to outputs
 sem_class_to_idx = {cls: idx for (idx, cls) in enumerate(weights.meta['categories'])}
 normalized_mask = torch.nn.functional.softmax(output, dim=1)


 # Extract mask
 tensor_to_pil = transforms.ToPILImage()
 mask = normalized_mask[0, sem_class_to_idx['person']]
 mask = mask > 0.5


 # Convert mask to bounding box
 if args.bounding_box:
 mask = convert_mask_to_bounding_box(mask, dilation=args.bbox_dilation)


 # Convert images to base64
 img = tensor_to_pil(img.cpu())
 img_b64 = img2b64(img)
 mask = tensor_to_pil(mask.to(torch.float32).cpu())
 mask_b64 = img2b64(mask)


 # Run inpainting
 extra_options = {
 'width': args.width,
 'height': args.height,
 'steps': args.steps,
 'cfg_scale': args.cfg_scale,
 'sampler_name': args.sampler_name,
 'denoising_strength': args.denoising_strength,
 'mask_blur': args.mask_blur,
 'inpainting_fill': INPAINTING_FILL_METHODS.index(args.fill),
 'inpaint_full_res': False
    }
 request = generate_request(img_b64, prompt=args.prompt, mask=mask_b64,
 negative_prompt=args.negative_prompt, **extra_options)
 response = submit_post(IMG2IMG_URL, request)
 output_img_b64 = response.json()['images'][0]


 # Save images
 save_encoded_image(output_img_b64, args.output_path)
 mask_path = os.path.join(os.path.dirname(args.output_path),
 f'mask_{os.path.basename(args.output_path)}')
 save_encoded_image(mask_b64, mask_path)"
main.py,"import requests
import json
import gradio as gr


url = ""http://localhost:11434/api/generate""


headers = {
 'Content-Type': 'application/json',
}


conversation_history = []


def generate_response(prompt):
 conversation_history.append(prompt)


 full_prompt = ""\n"".join(conversation_history)


 data = {
 ""model"": ""mistral"",
 ""stream"": False,
 ""prompt"": full_prompt,
    }


 response = requests.post(url, headers=headers, data=json.dumps(data))


 if response.status_code == 200:
 response_text = response.text
 data = json.loads(response_text)
 actual_response = data[""response""]
 conversation_history.append(actual_response)
 return actual_response
 else:
 print(""Error:"", response.status_code, response.text)
 return None


iface = gr.Interface(
 fn=generate_response,
 inputs=gr.inputs.Textbox(lines=2, placeholder=""Enter your prompt here...""),
 outputs=""text""
)


iface.launch()"
flow_matching.py,"#!/usr/bin/env python


import math
import matplotlib.pyplot as plt
import torch
import torch.nn as nn


from sklearn.datasets import make_moons
from torch import Tensor
from tqdm import tqdm
from typing import *
from zuko.utils import odeint




def log_normal(x: Tensor) -> Tensor:
 return -(x.square() + math.log(2 * math.pi)).sum(dim=-1) / 2




class MLP(nn.Sequential):
 def __init__(
 self,
 in_features: int,
 out_features: int,
 hidden_features: List[int] = [64, 64],
    ):
 layers = []


 for a, b in zip(
            (in_features, *hidden_features),
            (*hidden_features, out_features),
        ):
 layers.extend([nn.Linear(a, b), nn.ELU()])


 super().__init__(*layers[:-1])




class CNF(nn.Module):
 def __init__(self, features: int, freqs: int = 3, **kwargs):
 super().__init__()


 self.net = MLP(2 * freqs + features, features, **kwargs)


 self.register_buffer('freqs', torch.arange(1, freqs + 1) * torch.pi)


 def forward(self, t: Tensor, x: Tensor) -> Tensor:
 t = self.freqs * t[..., None]
 t = torch.cat((t.cos(), t.sin()), dim=-1)
 t = t.expand(*x.shape[:-1], -1)


 return self.net(torch.cat((t, x), dim=-1))


 def encode(self, x: Tensor) -> Tensor:
 return odeint(self, x, 0.0, 1.0, phi=self.parameters())


 def decode(self, z: Tensor) -> Tensor:
 return odeint(self, z, 1.0, 0.0, phi=self.parameters())


 def log_prob(self, x: Tensor) -> Tensor:
 I = torch.eye(x.shape[-1], dtype=x.dtype, device=x.device)
 I = I.expand(*x.shape, x.shape[-1]).movedim(-1, 0)


 def augmented(t: Tensor, x: Tensor, ladj: Tensor) -> Tensor:
 with torch.enable_grad():
 x = x.requires_grad_()
 dx = self(t, x)


 jacobian = torch.autograd.grad(dx, x, I, create_graph=True, is_grads_batched=True)[0]
 trace = torch.einsum('i...i', jacobian)


 return dx, trace * 1e-2


 ladj = torch.zeros_like(x[..., 0])
 z, ladj = odeint(augmented, (x, ladj), 0.0, 1.0, phi=self.parameters())


 return log_normal(z) + ladj * 1e2




class FlowMatchingLoss(nn.Module):
 def __init__(self, v: nn.Module):
 super().__init__()


 self.v = v


 def forward(self, x: Tensor) -> Tensor:
 t = torch.rand_like(x[..., 0, None])
 z = torch.randn_like(x)
 y = (1 - t) * x + (1e-4 + (1 - 1e-4) * t) * z
 u = (1 - 1e-4) * z - x


 return (self.v(t.squeeze(-1), y) - u).square().mean()




if __name__ == '__main__':
 flow = CNF(2, hidden_features=[64] * 3)


 # Training
 loss = FlowMatchingLoss(flow)
 optimizer = torch.optim.Adam(flow.parameters(), lr=1e-3)


 data, _ = make_moons(16384, noise=0.05)
 data = torch.from_numpy(data).float()


 for epoch in tqdm(range(16384), ncols=88):
 subset = torch.randint(0, len(data), (256,))
 x = data[subset]


 loss(x).backward()


 optimizer.step()
 optimizer.zero_grad()


 # Sampling
 with torch.no_grad():
 z = torch.randn(16384, 2)
 x = flow.decode(z)


 plt.figure(figsize=(4.8, 4.8), dpi=150)
 plt.hist2d(*x.T, bins=64)
 plt.savefig('moons_fm.pdf')


 # Log-likelihood
 with torch.no_grad():
 log_p = flow.log_prob(data[:4])


 print(log_p)"
find-elem-with-breakout-width.js,"function findBreakoutElem(rootElem = document.body) {
 function checkElemWidth(elem) {
 if (elem.clientWidth > window.outerWidth) {
 console.log(""The following element has a larger width than the window's outer width"");
 console.log(elem);
 console.log('<-------------------------------------------------------------------->');
 } else if (elem.scrollWidth > window.outerWidth) {
 console.log(""The following element has a larger width than the window's scroll width"");
 console.log(elem);
 console.log('<-------------------------------------------------------------------->');
 }


 // Recursively check all the children
 // of the element to find the culprit.
 [...elem.children].forEach(checkElemWidth);
 }
 
 checkElemWidth(rootElem);
}"
cursortable.js,"import React, { useEffect, useState } from ""react"";


import { Table, Button, Space, Row, Col } from ""antd"";
import { LeftOutlined, RightOutlined } from ""@ant-design/icons"";


const CursorPagination = ({ startKey, lastEvaluatedKey, onChange, size }) => {
 /* Use stack to keep track of which evaluated keys have been previously seen */
 const [ prevEvaluatedKeys, setPrevEvaluatedKeys ] = useState([]);
 /* Keep track of the current evaluated key */
 const [ currentEvaluatedKey, setCurrentEvaluatedKey ] = useState(null);
 /* Button style changes based on size */
 const [ buttonStyle, setButtonStyle ] = useState({});


 const popEvaluatedKey = () => {
 const prevEvaluatedKey = prevEvaluatedKeys.pop();
 setCurrentEvaluatedKey(prevEvaluatedKey);
 return prevEvaluatedKey;
 };
 const pushEvaluatedKey = (evaluatedKey) => {
 setPrevEvaluatedKeys([...prevEvaluatedKeys, currentEvaluatedKey]);
 setCurrentEvaluatedKey(evaluatedKey);
 return evaluatedKey;
 };


 const extra = { action: ""paginate"" };


 useEffect(() => {
 switch (size) {
 case ""small"":
 setButtonStyle({paddingLeft: ""4px"", paddingRight: ""4px"", borderColor: ""transparent""});
 break;
 case ""default"":
 default:
 setButtonStyle({paddingLeft: ""7px"", paddingRight: ""7px""});
 break;
 }
 }, [size]);


 useEffect(() => {
 /* Reset stack of keys when pagination is reset back to the beginning */
 if (!startKey) {
 setPrevEvaluatedKeys([]);
 setCurrentEvaluatedKey(null);
 }
 }, [startKey]);
 
 /* Display forward and back buttons */
 return (
 <Space direction=""horizontal"">
 <Button tabIndex={-1} size={size}
 disabled={!prevEvaluatedKeys.length && prevEvaluatedKeys.length <= 1}
 style={buttonStyle}
 onClick={() => onChange(popEvaluatedKey(), undefined, undefined, extra)}>
 <LeftOutlined/>
 </Button>
 <Button tabIndex={-1} size={size}
 disabled={!lastEvaluatedKey}
 style={buttonStyle}
 onClick={() => onChange(pushEvaluatedKey(lastEvaluatedKey), undefined, undefined, extra)}>
 <RightOutlined/>
 </Button>
 </Space>
 );
};


export default function CursorTable(props) {
 const { children, pagination, dataSource, onChange } = props;
 const { position = ""bottomRight"", size = ""default"" } = pagination || {};
 const [ lastEvaluatedKey, setLastEvaluatedKey ] = useState(null);


 const [ verticalPosition, alignmentPosition ] =
 position.match(/[A-Z]?[a-z]+/g);


 const justifyPosition = {
 left: ""start"",
 center: ""center"",
 right: ""end""
 }[alignmentPosition.toLowerCase()];


 useEffect(() => {
 /* Get last evaluated key from last item in data source */
 const [ lastDataItem ] = (dataSource || []).slice(-1);
 setLastEvaluatedKey(lastDataItem?.lastEvaluatedKey);
 }, [dataSource]);


 return (
 <Space direction=""vertical"" style={{width: ""100%""}}>
 {verticalPosition === ""top"" &&
 <Row justify={justifyPosition}>
 <Col>
 <CursorPagination
 lastEvaluatedKey={lastEvaluatedKey}
 onChange={onChange}
 size={size}/>
 </Col>
 </Row>}
 <Table {...props} pagination={{position: [""none"", ""none""]}}>
 {children}
 </Table>
 {verticalPosition === ""bottom"" &&
 <Row justify={justifyPosition}>
 <Col>
 <CursorPagination
 lastEvaluatedKey={lastEvaluatedKey}
 onChange={onChange}
 size={size}/>
 </Col>
 </Row>}
 </Space>
 );
}"
main.py,"# dependencies
# pip install -U openai gradio


import os, openai
import gradio as gr
openai.api_key = 'sk-xxxxxx'


messages = [{""role"": ""system"", ""content"": """"""Assistant is an expert candidate in
             technical IT job interviews. Currently, the interview is
             focused on a position for Platform Engineer. So, you have skills
             with Terraform, Kubernetes, Docker, Ansible, Python, AWS, and
             more. For technical code questions, use Python. Provide clear,
             short, and concise answers and code. 
             Answers should look human and avoid too much formality when replying.
             Always provide answers in English!""""""}]


def transcribe(audio):
 global messages


 audio_filename_with_extension = audio + '.mp3'
 os.rename(audio, audio_filename_with_extension)


 audio_file = open(audio_filename_with_extension, ""rb"")
 transcript = openai.audio.transcriptions.create(
 model=""whisper-1"",
 file=audio_file,
 response_format=""text"",
 language='en'
    )


 messages.append({""role"": ""user"", ""content"": transcript})


 response = openai.chat.completions.create(model=""gpt-4-1106-preview"", messages=messages)


 message_role = response.choices[0].message.role
 message_content = response.choices[0].message.content
 messages.append({""role"": message_role, ""content"": message_content})


 chat_transcript = """"
 for message in messages:
 if message['role'] != 'system':
 chat_transcript += message['role'] + "": "" + message['content'] + ""\n\n""
 return chat_transcript




ui = gr.Interface(fn=transcribe, inputs=gr.Audio(sources=[""microphone""], type=""filepath""), outputs=""text"").launch()
ui.launch()"
LinkedList.c,"#include<stdio.h>
#include<stdlib.h>


struct node //make node for linked list using structure
{
 int value;            //value part of node contains the element
 struct node *next;    //the next part of node contains the address of next element of list
};


struct node *head;    //contains the address of first element of linked list


void init()
{
 head=NULL;    //initialize the beginning(head) of list to NULL
}


void insertfirst(int element)   //inserts element in linked list
{
 struct node *New;
 New=(struct node*)malloc(sizeof(struct node));    //New named node declared with size of node declared before
 New->value=element;       //inserts the new element to the value part of node New
 New->next=NULL;           //makes the next part of node New NULL so that no garbage value remains
 New->next=head;         //the address of previously first node, which was stored in head is now assigned to next part of node New
 head=New;              //the address of new first element which is present in node New is assigned to head node
}


void print()
{
 if(head==NULL)    //condition to check whether list is empty
    {
 printf(""list is empty\n"");
 return;
    }
 struct node *cur=head;            
 int count;
 count=0;
 while(cur!=NULL)                  //the loop traverse until it gets any NULL node
    {
 printf(""%d->"",cur->value);    
 count++;                      //counts the number of nodes or elements present in list
 cur=cur->next;                //moves cur pointer to next node to check and get value
    }
 printf(""NULL\n"");
 printf(""number of nodes %d\n"",count);
}


void deleteitem(int ele)
{
 if(head==NULL)
 printf(""list is empty and nothing to delete\n"");
 struct node* cur=head;
 struct node* prev=NULL;
 while(cur->value!=ele)
    {
 prev=cur;
 cur=cur->next;
    }
 if(prev!=NULL)
 prev->next=cur->next;       //the address of next node after the node containing element to be deleted is assigned to the previous node of the node containing the element to be deleted
 free(cur);                      //memory of the structure cur is deallocated
}


int searchitem(int ele)
{
 struct node* temp ;
 temp = head;
 while (temp != 0)
	{
 if (temp->value == ele)
 return 1 ;          //element is found
 temp = temp->next;
	}
 return 0 ;
}


void insertlast(int ele)    //insert at the last of linked list
{
 struct node *New, *temp;
 New = (struct node*)malloc(sizeof(struct node));
 if(New== NULL)
    {
 printf(""Unable to allocate memory."");
 return;
    }
 else
    {
 New->value = ele;
 New->next = NULL;
 temp = head;
 while(temp->next != NULL)
 temp = temp->next;
 temp->next = New;
 printf(""DATA INSERTED SUCCESSFULLY\n"");
    }
}


void deletelast()   //delete the last element
{
 if(head==NULL)
    {
 printf(""list is empty and nothing to delete\n"");
    }
 struct node* cur=head;
 struct node* prev=NULL;
 while(cur->next!=NULL)
    {
 prev=cur;
 cur=cur->next;
    }
 if(prev->next!=NULL)
 prev->next=NULL;
 free(cur);
}


void deletefirst()    //delete the first element
{
 struct node* cur;
 if(head==NULL)
 printf(""list is empty and nothing to delete\n"");
 cur=head;
 head=head->next;
 free(cur);
}


void insertafter(int elem, int num)   //inserts element for any given element present in linked list
{
 struct node* New;
 New=(struct node*)malloc(sizeof(struct node));
 New->value=elem;
 New->next=NULL;
 struct node* prev=head;
 while(prev->value!=num)
    {
 prev=prev->next;
    }
 New->next=prev->next;
 prev->next=New;
}


void printReverse(struct node* head)    //print the linked list in reverse way using recursion
{
 if (head == NULL)
 return;
 printReverse(head->next);
 printf(""%d->"", head->value);
}


void reverselist()    //reverse the linked list
{
 struct node* prev=NULL;
 struct node* cur=head;
 struct node* nxt;
 while(cur!=NULL)
    {
 nxt=cur->next;
 cur->next=prev;
 prev=cur;
 cur=nxt;
    }
 head=prev;      //points the head pointer to prev as it the new head or beginning in reverse list
}


void sum()    //sum of elements of the linked list
{
 int s;
 struct node *cur=head;
 s=0;
 while(cur!=NULL)
    {
 s+=cur->value;
 cur=cur->next;
    }
 printf(""Sum of elements is %d\n"",s);
}




int main()
{
 init();


 int ch,element;
 while(1)
    {
 printf(""\n1. Insert new item. 2. Delete item. 3. Search item. 4. Insert Last. 5. Print. 6.Delete Last 7.Delete First 8.Insert After 9.Print Linked List in Reverse way. 10.Sum 11.Make the linked list reverse 12.Exit\n--------------------------------------------------------------------------------------\n"");
 printf(""enter choice of input: "");
 scanf(""%d"",&ch);
 if(ch==1)
        {
 printf(""enter element to list: "");
 scanf(""%d"",&element);
 insertfirst(element);
        }
 else if(ch==2)
        {
 int de;
 printf(""enter element to delete "");
 scanf(""%d"",&de);
 deleteitem(de);
        }
 else if(ch==3)
        {
 int se,reply;
 printf(""enter element to search "");
 scanf(""%d"",&se);
 reply=searchitem(se);
 if(reply==1)
 printf(""element found\n"");
 else
 printf(""element not found\n"");
        }
 else if(ch==4)
        {
 int le;
 printf(""enter element to insert at last "");
 scanf(""%d"",&le);
 insertlast(le);
        }
 else if(ch==5)
        {
 print();
        }
 else if(ch==6)
        {
 deletelast();
        }
 else if(ch==7)
        {
 deletefirst();
        }
 else if(ch==8)
        {
 int ie,p;
 printf(""enter element to insert: "");
 scanf(""%d"",&ie);
 printf(""enter after which element to insert: "");
 scanf(""%d"",&p);
 insertafter(ie,p);
        }
 else if(ch==9)
        {
 printReverse(head);
        }
 else if(ch==10)
        {
 sum();
        }
 else if(ch==11)
        {
 reverselist();
        }
 else if(ch==12)
 return 0;
 else
 return 0;
    }
 return 0;
}"
jit.cpp,"#include <AK/DistinctNumeric.h>
#include <AK/NonnullOwnPtr.h>
#include <AK/Vector.h>
#include <LibMain/Main.h>
#include <sys/mman.h>


// JS::Bytecode::Executable (jitme)
// 1:
//[   0] Store $5
//[  20] LoadImmediate 0
//[  40] SetLocal 0
//[  60] Load $5
//[  80] LoadImmediate undefined
//[  a0] Store $6
//[  c0] Jump @4
// 2:
// 3:
//[   0] LoadImmediate undefined
//[  20] Jump @5
// 4:
//[   0] GetLocal 0
//[  20] Store $7
//[  40] LoadImmediate 100000000
//[  60] LessThan $7
//[  80] JumpConditional true:@3 false:@6
// 5:
//[   0] Store $6
//[  20] GetLocal 0
//[  40] Increment
//[  58] SetLocal 0
//[  78] Jump @4
// 6:
//[   0] Load $6
//[  20] Jump @2


struct Value {
    u64 value { 0 };
};


AK_TYPEDEF_DISTINCT_NUMERIC_GENERAL(size_t, VMRegister);
AK_TYPEDEF_DISTINCT_NUMERIC_GENERAL(size_t, VMLocal);


struct Instruction {
 enum class Type {
        LoadImmediate,
        Load,
        Store,
        SetLocal,
        GetLocal,
        Increment,
        LessThan,
        Jump,
        JumpConditional,
        Exit,
    };


    Type type {};


protected:
 explicit Instruction(Type type)
        : type(type)
    {
    }
};


struct BasicBlock {
    Vector<NonnullOwnPtr<Instruction>> instructions;


 // Offset into the instruction stream where this code block starts.
 size_t offset { 0 };


 // Offsets into the instruction stream where we have RIP-relative jump offsets to here that need patching.
    Vector<size_t> jumps_to_here;


 template<typename T, typename... Args>
 void append(Args&&... args)
    {
        instructions.empend(make<T>(forward<Args>(args)...));
    }


 void dump() const
    {
 for (size_t i = 0; i < instructions.size(); ++i) {
 dbgln(""    [{}] {}"", i, to_underlying(instructions[i]->type));
        }
    }
};


struct LoadImmediate : public Instruction {
 LoadImmediate(Value value)
        : Instruction(Type::LoadImmediate)
        , value(value)
    {
    }


    Value value;
};


struct Store : public Instruction {
 Store(VMRegister reg)
        : Instruction(Type::Store)
        , reg(reg)
    {
    }


    VMRegister reg;
};


struct Load : public Instruction {
 Load(VMRegister reg)
        : Instruction(Type::Load)
        , reg(reg)
    {
    }


    VMRegister reg;
};


struct SetLocal : public Instruction {
 SetLocal(VMLocal local)
        : Instruction(Type::SetLocal)
        , local(local)
    {
    }


    VMLocal local;
};


struct GetLocal : public Instruction {
 GetLocal(VMLocal local)
        : Instruction(Type::GetLocal)
        , local(local)
    {
    }


    VMLocal local;
};


struct Increment : public Instruction {
 Increment()
        : Instruction(Type::Increment)
    {
    }
};


struct LessThan : public Instruction {
 LessThan(VMRegister lhs)
        : Instruction(Type::LessThan)
        , lhs(lhs)
    {
    }


    VMRegister lhs;
};


struct Exit : public Instruction {
 Exit()
        : Instruction(Type::Exit)
    {
    }
};


struct Jump : public Instruction {
 Jump(BasicBlock& target)
        : Instruction(Type::Jump)
        , target(target)
    {
    }


    BasicBlock& target;
};


struct JumpConditional : public Instruction {
 JumpConditional(BasicBlock& true_target, BasicBlock& false_target)
        : Instruction(Type::JumpConditional)
        , true_target(true_target)
        , false_target(false_target)
    {
    }


    BasicBlock& true_target;
    BasicBlock& false_target;
};


struct VM {
    Vector<Value> registers;
    Vector<Value> locals;


 void dump() const
    {
 dbgln(""Registers:"");
 for (size_t i = 0; i < registers.size(); ++i) {
 dbgln(""    [{}] {}"", i, registers[i].value);
        }
 dbgln(""Locals:"");
 for (size_t i = 0; i < locals.size(); ++i) {
 dbgln(""    [{}] {}"", i, locals[i].value);
        }
    }
};


struct Program {
    Vector<NonnullOwnPtr<BasicBlock>> blocks;


    BasicBlock& make_block()
    {
        blocks.append(make<BasicBlock>());
 return *blocks.last();
    }


 void dump() const
    {
 for (size_t i = 0; i < blocks.size(); ++i) {
 dbgln(""Block {}:"", i + 1);
            blocks[i]->dump();
        }
    }
};


struct Executable {
 void* code { nullptr };
 size_t code_size { 0 };


 void run(VM& vm)
    {
 // RDI: VM&
 // RSI: Value* registers
 // RDX: Value* locals
 typedef void (*JittedFunction)(VM&, Value* registers, Value* locals);
        (*(JittedFunction)code)(vm, vm.registers.data(), vm.locals.data());
    }
};


struct Assembler {
 Assembler(Vector<u8>& output)
        : m_output(output)
    {
    }


    Vector<u8>& m_output;


 enum class Reg {
        GPR0 = 0, // RAX
        GPR1 = 1, // RCX


        RegisterArrayBase = 6, // RSI
        LocalsArrayBase = 2,   // RDX
    };


 struct Operand {
 enum class Type {
            Reg,
            Imm64,
            Mem64BaseAndOffset,
        };


        Type type {};


        Reg reg {};
        u64 offset_or_immediate { 0 };


 static Operand Register(Reg reg)
        {
            Operand operand;
            operand.type = Type::Reg;
            operand.reg = reg;
 return operand;
        }


 static Operand Imm64(u64 imm64)
        {
            Operand operand;
            operand.type = Type::Imm64;
            operand.offset_or_immediate = imm64;
 return operand;
        }


 static Operand Mem64BaseAndOffset(Reg base, u64 offset)
        {
            Operand operand;
            operand.type = Type::Mem64BaseAndOffset;
            operand.reg = base;
            operand.offset_or_immediate = offset;
 return operand;
        }
    };


 void mov(Operand dst, Operand src)
    {
 if (dst.type == Operand::Type::Reg && src.type == Operand::Type::Reg) {
 emit8(0x48);
 emit8(0x89);
 emit8(0xc0 | (to_underlying(dst.reg) << 3) | to_underlying(src.reg));
 return;
        }


 if (dst.type == Operand::Type::Reg && src.type == Operand::Type::Imm64) {
 emit8(0x48);
 emit8(0xb8 | to_underlying(dst.reg));
 emit64(src.offset_or_immediate);
 return;
        }


 if (dst.type == Operand::Type::Mem64BaseAndOffset && src.type == Operand::Type::Reg) {
 emit8(0x48);
 emit8(0x89);
 emit8(0x80 | (to_underlying(src.reg) << 3) | to_underlying(dst.reg));
 emit32(dst.offset_or_immediate);
 return;
        }


 if (dst.type == Operand::Type::Reg && src.type == Operand::Type::Mem64BaseAndOffset) {
 emit8(0x48);
 emit8(0x8b);
 emit8(0x80 | (to_underlying(dst.reg) << 3) | to_underlying(src.reg));
 emit32(src.offset_or_immediate);
 return;
        }


 VERIFY_NOT_REACHED();
    }


 void emit8(u8 value)
    {
        m_output.append(value);
    }


 void emit32(u32 value)
    {
        m_output.append((value >> 0) & 0xff);
        m_output.append((value >> 8) & 0xff);
        m_output.append((value >> 16) & 0xff);
        m_output.append((value >> 24) & 0xff);
    }


 void emit64(u64 value)
    {
        m_output.append((value >> 0) & 0xff);
        m_output.append((value >> 8) & 0xff);
        m_output.append((value >> 16) & 0xff);
        m_output.append((value >> 24) & 0xff);
        m_output.append((value >> 32) & 0xff);
        m_output.append((value >> 40) & 0xff);
        m_output.append((value >> 48) & 0xff);
        m_output.append((value >> 56) & 0xff);
    }


 void load_immediate64(Reg dst, u64 imm)
    {
 mov(Operand::Register(dst), Operand::Imm64(imm));
    }


 void store_vm_register(VMRegister dst, Reg src)
    {
 mov(Operand::Mem64BaseAndOffset(Reg::RegisterArrayBase, dst.value() * sizeof(Value)), Operand::Register(src));
    }


 void load_vm_register(Reg dst, VMRegister src)
    {
 mov(Operand::Register(dst), Operand::Mem64BaseAndOffset(Reg::RegisterArrayBase, src.value() * sizeof(Value)));
    }


 void store_vm_local(VMLocal dst, Reg src)
    {
 mov(Operand::Mem64BaseAndOffset(Reg::LocalsArrayBase, dst.value() * sizeof(Value)), Operand::Register(src));
    }


 void load_vm_local(Reg dst, VMLocal src)
    {
 mov(Operand::Register(dst), Operand::Mem64BaseAndOffset(Reg::LocalsArrayBase, src.value() * sizeof(Value)));
    }


 void increment(Reg dst)
    {
 emit8(0x48);
 emit8(0xff);
 emit8(0xc0 | to_underlying(dst));
    }


 void less_than(Reg dst, Reg src)
    {
 // cmp src, dst
 emit8(0x48);
 emit8(0x39);
 emit8(0xc0 | (to_underlying(src) << 3) | to_underlying(dst));


 // setl dst
 emit8(0x0f);
 emit8(0x9c);
 emit8(0xc0 | to_underlying(dst));


 // movzx dst, dst
 emit8(0x48);
 emit8(0x0f);
 emit8(0xb6);
 emit8(0xc0 | (to_underlying(dst) << 3) | to_underlying(dst));
    }


 void jump(BasicBlock& target)
    {
 // jmp target (RIP-relative 32-bit offset)
 emit8(0xe9);
        target.jumps_to_here.append(m_output.size());
 emit32(0xdeadbeef);
    }


 void jump_conditional(Reg reg, BasicBlock& true_target, BasicBlock& false_target)
    {
 // if reg == 0, jump to false_target, else jump to true_target
 // cmp reg, 0
 emit8(0x48);
 emit8(0x83);
 emit8(0xf8);
 emit8(0x00 | to_underlying(reg));


 // jz false_target (RIP-relative 32-bit offset)
 emit8(0x0f);
 emit8(0x84);
        false_target.jumps_to_here.append(m_output.size());
 emit32(0xdeadbeef);


 // jmp true_target (RIP-relative 32-bit offset)
 jump(true_target);
    }


 void exit()
    {
 // ret
 emit8(0xc3);
    }
};


struct JIT {
    Vector<u8> m_output;
    Assembler m_assembler { m_output };


 void compile_load_immediate(LoadImmediate const& instruction)
    {
        m_assembler.load_immediate64(Assembler::Reg::GPR0, instruction.value.value);
        m_assembler.store_vm_register(VMRegister { 0 }, Assembler::Reg::GPR0);
    }


 void compile_load(Load const& instruction)
    {
        m_assembler.load_vm_register(Assembler::Reg::GPR0, instruction.reg);
        m_assembler.store_vm_register(VMRegister { 0 }, Assembler::Reg::GPR0);
    }


 void compile_store(Store const& instruction)
    {
        m_assembler.load_vm_register(Assembler::Reg::GPR0, VMRegister { 0 });
        m_assembler.store_vm_register(instruction.reg, Assembler::Reg::GPR0);
    }


 void compile_get_local(GetLocal const& instruction)
    {
        m_assembler.load_vm_local(Assembler::Reg::GPR0, instruction.local);
        m_assembler.store_vm_register(VMRegister { 0 }, Assembler::Reg::GPR0);
    }


 void compile_set_local(SetLocal const& instruction)
    {
        m_assembler.load_vm_register(Assembler::Reg::GPR0, VMRegister { 0 });
        m_assembler.store_vm_local(instruction.local, Assembler::Reg::GPR0);
    }


 void compile_increment(Increment const&)
    {
        m_assembler.load_vm_register(Assembler::Reg::GPR0, VMRegister { 0 });
        m_assembler.increment(Assembler::Reg::GPR0);
        m_assembler.store_vm_register(VMRegister { 0 }, Assembler::Reg::GPR0);
    }


 void compile_less_than(LessThan const& instruction)
    {
        m_assembler.load_vm_register(Assembler::Reg::GPR0, instruction.lhs);
        m_assembler.load_vm_register(Assembler::Reg::GPR1, VMRegister { 0 });


        m_assembler.less_than(Assembler::Reg::GPR0, Assembler::Reg::GPR1);


        m_assembler.store_vm_register(VMRegister { 0 }, Assembler::Reg::GPR0);
    }


 void compile_jump(Jump const& instruction)
    {
        m_assembler.jump(instruction.target);
    }


 void compile_jump_conditional(JumpConditional const& instruction)
    {
        m_assembler.load_vm_register(Assembler::Reg::GPR0, VMRegister { 0 });
        m_assembler.jump_conditional(Assembler::Reg::GPR0, instruction.true_target, instruction.false_target);
    }


 void compile_exit(Exit const&)
    {
        m_assembler.exit();
    }


 static Executable compile(Program const& program)
    {
        JIT jit;


 for (auto& block : program.blocks) {
            block->offset = jit.m_output.size();
 for (auto& instruction : block->instructions) {
 switch (instruction->type) {
 case Instruction::Type::LoadImmediate:
                    jit.compile_load_immediate(static_cast<LoadImmediate&>(*instruction));
 break;
 case Instruction::Type::Load:
                    jit.compile_load(static_cast<Load&>(*instruction));
 break;
 case Instruction::Type::Store:
                    jit.compile_store(static_cast<Store&>(*instruction));
 break;
 case Instruction::Type::SetLocal:
                    jit.compile_set_local(static_cast<SetLocal&>(*instruction));
 break;
 case Instruction::Type::GetLocal:
                    jit.compile_get_local(static_cast<GetLocal&>(*instruction));
 break;
 case Instruction::Type::Increment:
                    jit.compile_increment(static_cast<Increment&>(*instruction));
 break;
 case Instruction::Type::LessThan:
                    jit.compile_less_than(static_cast<LessThan&>(*instruction));
 break;
 case Instruction::Type::Jump:
                    jit.compile_jump(static_cast<Jump&>(*instruction));
 break;
 case Instruction::Type::JumpConditional:
                    jit.compile_jump_conditional(static_cast<JumpConditional&>(*instruction));
 break;
 case Instruction::Type::Exit:
                    jit.compile_exit(static_cast<Exit&>(*instruction));
 break;
 default:
 VERIFY_NOT_REACHED();
                }
            }
        }


 for (auto& block : program.blocks) {
 for (auto& jump : block->jumps_to_here) {
 auto offset = block->offset - jump - 4;
                jit.m_output[jump + 0] = (offset >> 0) & 0xff;
                jit.m_output[jump + 1] = (offset >> 8) & 0xff;
                jit.m_output[jump + 2] = (offset >> 16) & 0xff;
                jit.m_output[jump + 3] = (offset >> 24) & 0xff;
            }
        }


 write(STDOUT_FILENO, jit.m_output.data(), jit.m_output.size());


 auto* executable_memory = mmap(nullptr, jit.m_output.size(), PROT_READ | PROT_WRITE | PROT_EXEC, MAP_ANONYMOUS | MAP_PRIVATE, 0, 0);
 VERIFY(executable_memory != MAP_FAILED);


 memcpy(executable_memory, jit.m_output.data(), jit.m_output.size());


 return Executable {
            .code = executable_memory,
            .code_size = jit.m_output.size(),
        };
    }
};


ErrorOr<int> serenity_main(Main::Arguments)
{
 auto program = Program {};
 auto& block1 = program.make_block();
 auto& block2 = program.make_block();
 auto& block3 = program.make_block();
 auto& block4 = program.make_block();
 auto& block5 = program.make_block();
 auto& block6 = program.make_block();


    block1.append<Store>(VMRegister { 5 });
    block1.append<LoadImmediate>(Value(0));
    block1.append<SetLocal>(VMLocal(0));
    block1.append<Load>(VMRegister(5));
    block1.append<LoadImmediate>(Value(0));
    block1.append<Store>(VMRegister(6));
    block1.append<Jump>(block4);


    block2.append<Exit>();


    block3.append<LoadImmediate>(Value(0));
    block3.append<Jump>(block5);


    block4.append<GetLocal>(VMLocal(0));
    block4.append<Store>(VMRegister(7));
    block4.append<LoadImmediate>(Value(100000000));
    block4.append<LessThan>(VMRegister(7));
    block4.append<JumpConditional>(block3, block6);


    block5.append<Store>(VMRegister(6));
    block5.append<GetLocal>(VMLocal(0));
    block5.append<Increment>();
    block5.append<SetLocal>(VMLocal(0));
    block5.append<Jump>(block4);


    block6.append<Load>(VMRegister(6));
    block6.append<Jump>(block2);


    program.dump();


 auto vm = VM {};
    vm.registers.resize(8);
    vm.locals.resize(1);


 auto executable = JIT::compile(program);
    executable.run(vm);


#if 0
    auto* current_block = &block1;
    size_t instruction_index = 0;


    for (;;) {
        if (instruction_index >= current_block->instructions.size()) {
            break;
        }
        auto& instruction = current_block->instructions[instruction_index];
        switch (instruction->type) {
        case Instruction::Type::LoadImmediate:
            vm.registers[0].value = static_cast<LoadImmediate&>(*instruction).value.value;
            break;
        case Instruction::Type::Load:
            vm.registers[0].value = vm.registers[static_cast<Load&>(*instruction).reg.value()].value;
            break;
        case Instruction::Type::Store:
            vm.registers[static_cast<Store&>(*instruction).reg.value()].value = vm.registers[0].value;
            break;
        case Instruction::Type::SetLocal:
            vm.locals[static_cast<SetLocal&>(*instruction).local.value()].value = vm.registers[0].value;
            break;
        case Instruction::Type::GetLocal:
            vm.registers[0].value = vm.locals[static_cast<GetLocal&>(*instruction).local.value()].value;
            break;
        case Instruction::Type::Increment:
            vm.registers[0].value += 1;
            break;
        case Instruction::Type::LessThan:
            vm.registers[0].value = vm.registers[static_cast<LessThan&>(*instruction).lhs.value()].value < vm.registers[0].value;
            break;
        case Instruction::Type::Jump:
            current_block = &static_cast<Jump&>(*instruction).target;
            instruction_index = 0;
            continue;
        case Instruction::Type::JumpConditional:
            if (vm.registers[0].value) {
                current_block = &static_cast<JumpConditional&>(*instruction).true_target;
            } else {
                current_block = &static_cast<JumpConditional&>(*instruction).false_target;
            }
            instruction_index = 0;
            continue;
        case Instruction::Type::Exit:
            vm.dump();
            return 0;
        default:
            VERIFY_NOT_REACHED();
        }


        ++instruction_index;
    }
#endif


    vm.dump();


 return 0;
}"
tile.py,"# SPDX-FileCopyrightText: 2023 geisserml <geisserml@gmail.com>
# SPDX-License-Identifier: CC-BY-4.0 OR Apache-2.0 OR BSD-3-Clause


import math
import argparse
import itertools
import pypdfium2 as pdfium 
from pathlib import Path


parser = argparse.ArgumentParser()
parser.add_argument(""files"", nargs=""+"", type=Path)
parser.add_argument(""--output"", ""-o"", type=Path)
args = parser.parse_args()


ROWS, COLS = 2, 2
PAGE_W, PAGE_H = 595, 842
ROTATION = 90
H_ALIGNS = [""right"", ""left""]  # left, mid, right
V_ALIGNS = [""mid""] * ROWS # bottom, mid, top




def main():
 
 n_tiles = ROWS*COLS
 box_w, box_h = PAGE_W/COLS, PAGE_H/ROWS
 n_pages = math.ceil( len(args.files) / n_tiles )
 
 new_pdf = pdfium.PdfDocument.new()
 
 for i in range(n_pages):
 page = new_pdf.new_page(PAGE_W, PAGE_H)
 
 for r, c in itertools.product(range(ROWS), range(COLS)):
 
 file_idx = i*n_tiles + r*COLS + c
 if not file_idx < len(args.files):
 break
 
 img = pdfium.PdfImage.new(new_pdf)
 img.load_jpeg(args.files[file_idx])
 page.insert_obj(img)
 px_w, px_h = img.get_size()
 
 tile_w, tile_h = box_w, box_h
 if ROTATION in (90, 270):
 tile_w, tile_h = tile_h, tile_w
 
 scale = min(tile_w/px_w, tile_h/px_h)
 scaled_w, scaled_h = px_w*scale, px_h*scale
 w_diff, h_diff = tile_w-scaled_w, tile_h-scaled_h
 tile_w, tile_h = scaled_w, scaled_h
 
 m = pdfium.PdfMatrix()
 m = m.scale(tile_w, tile_h)
 
 if ROTATION != 0:
 # TODO pypdfium2: consider adding abstraction for rotating an object around a point on itself - translating back and forth is slightly annoying
 m = m.translate(-tile_w/2, -tile_h/2)
 m = m.rotate(ROTATION)
 if ROTATION in (90, 270):
 tile_w, tile_h = tile_h, tile_w
 w_diff, h_diff = h_diff, w_diff
 m = m.translate(tile_w/2, tile_h/2)
 
 pos_y = PAGE_H - box_h*(r+1)
 pos_x = box_w * c
 pos_x += dict(left=0, mid=w_diff/2, right=w_diff)[ H_ALIGNS[c] ]
 pos_y += dict(bottom=0, mid=h_diff/2, top=h_diff)[ V_ALIGNS[r] ]
 
 m = m.translate(pos_x, pos_y)
 img.set_matrix(m)
 
 page.gen_content()
 
 new_pdf.save(args.output)




main()"
App.js,"import React, { useState } from ""react"";
import axios from 'axios';
import ""./App.css"";


export default function App() {
 const [process, setProcess] = useState({});
 const [message, setMessage] = useState({});
 const [listening, setListening] = useState(false);


 const statusMessage = {
 subscribed: ""Subscribed"",
 unsubscribed: ""Unsubscribed""
 };


 const subscribe = async () => {
 const status = listening;
 if (!status) {
 const events = new EventSource(""http://localhost:8000/events"");
 events.onmessage = event => {
 const parsedData = JSON.parse(event.data);
 console.log(event)
 switch (parsedData.type) {
 case ""init-connection"":
 setProcess(parsedData.processId);
 break;
 case ""message"":
 setMessage(parsedData.message);
 break;
 }
 };
 } else {
 setProcess({});
 setMessage({});
 await axios.delete(`http://localhost:8000/closes/${process}`)
 }
 setListening(!listening);
 };


 return (
 <div>
 <p>{listening ? statusMessage.subscribed : statusMessage.unsubscribed}</p>
 <p>{JSON.stringify(process)}</p>
 <button onClick={subscribe}>
 {listening ? statusMessage.unsubscribed : statusMessage.subscribed}
 </button>
 <br />
 <p>{JSON.stringify(message)}</p>
 </div>
 );
}"
langchain_flyte_pipeline.py,"import json
import os
from functools import partial


import flytekit
from flytekit import ImageSpec, Resources, Secret, map_task, task, workflow


embed_image = ImageSpec(
 name=""langchain-flyte-vectordb"",
 packages=[
 ""langchain"",
 ""pinecone-client"",
 ""huggingface_hub"",
 ""sentence_transformers"",
 ""yt_dlp"",
 ""pydub"",
 ""openai"",
    ],
 apt_packages=[""ffmpeg""],
 registry=""ghcr.io/samhita-alla"",
 base_image=""ghcr.io/flyteorg/flytekit:py3.11-1.7.0"",
)


query_image = ImageSpec(
 name=""langchain-flyte-query"",
 packages=[
 ""langchain"",
 ""pinecone-client"",
 ""huggingface_hub"",
 ""sentence_transformers"",
 ""openai"",
 ""spacy"",
 ""textstat"",
 ""https://github.com/explosion/spacy-models/releases/download/en_core_web_sm-3.5.0/en_core_web_sm-3.5.0.tar.gz"",
    ],
 registry=""ghcr.io/samhita-alla"",
 base_image=""ghcr.io/flyteorg/flytekit:py3.11-1.7.0"",
)


SECRET_GROUP = ""arn:aws:secretsmanager:us-east-2:356633062068:secret""
SECRET_KEY = ""flyte_langchain-YtD8OW""




@task(
 cache=True,
 cache_version=""1.0"",
 secret_requests=[
 Secret(
 group=SECRET_GROUP,
 key=SECRET_KEY,
 mount_requirement=Secret.MountType.FILE,
        ),
    ],
 container_image=embed_image,
 requests=Resources(mem=""5Gi""),
)
def embed_and_store(url: str, index_name: str) -> str:
 import openai
 import pinecone
 from langchain.document_loaders.blob_loaders.youtube_audio import YoutubeAudioLoader
 from langchain.document_loaders.generic import GenericLoader
 from langchain.document_loaders.parsers import OpenAIWhisperParser
 from langchain.embeddings import HuggingFaceEmbeddings
 from langchain.text_splitter import RecursiveCharacterTextSplitter
 from langchain.vectorstores import Pinecone


 pinecone.init(
 api_key=json.loads(
 flytekit.current_context().secrets.get(SECRET_GROUP, SECRET_KEY)
        )[""pinecone_api_key""],
 environment=json.loads(
 flytekit.current_context().secrets.get(SECRET_GROUP, SECRET_KEY)
        )[""pinecone_environment""],
    )
 openai.api_key = json.loads(
 flytekit.current_context().secrets.get(SECRET_GROUP, SECRET_KEY)
    )[""openai_api_key""]


 # Directory to save audio files
 save_dir = os.path.join(flytekit.current_context().working_directory, ""youtube"")


 # Transcribe the videos to text
 loader = GenericLoader(YoutubeAudioLoader([url], save_dir), OpenAIWhisperParser())
 docs = loader.load()


 combined_docs = [doc.page_content for doc in docs]
 text = "" "".join(combined_docs)


 # Split them
 text_splitter = RecursiveCharacterTextSplitter(chunk_size=1500, chunk_overlap=150)
 splits = text_splitter.split_text(text)


 huggingface_embeddings = HuggingFaceEmbeddings(
 cache_folder=os.path.join(
 flytekit.current_context().working_directory, ""embeddings-cache-folder""
        )
    )


 Pinecone.from_texts(
 texts=splits, embedding=huggingface_embeddings, index_name=index_name
    )
 return f""{url} data is stored in the vectordb.""




@task(
 disable_deck=False,
 secret_requests=[
 Secret(
 group=SECRET_GROUP,
 key=SECRET_KEY,
 mount_requirement=Secret.MountType.FILE,
        ),
    ],
 container_image=query_image,
 requests=Resources(mem=""5Gi""),
)
def query_vectordb(index_name: str, query: str) -> str:
 import pinecone
 from langchain.callbacks import FlyteCallbackHandler
 from langchain.chains import RetrievalQA
 from langchain.chat_models import ChatOpenAI
 from langchain.embeddings import HuggingFaceEmbeddings
 from langchain.vectorstores import Pinecone


 pinecone.init(
 api_key=json.loads(
 flytekit.current_context().secrets.get(SECRET_GROUP, SECRET_KEY)
        )[""pinecone_api_key""],
 environment=json.loads(
 flytekit.current_context().secrets.get(SECRET_GROUP, SECRET_KEY)
        )[""pinecone_environment""],
    )


 huggingface_embeddings = HuggingFaceEmbeddings(
 cache_folder=os.path.join(
 flytekit.current_context().working_directory, ""embeddings-cache-folder""
        )
    )


 vectordb = Pinecone.from_existing_index(index_name, huggingface_embeddings)
 retriever = vectordb.as_retriever(search_type=""similarity"", search_kwargs={""k"": 2})


 qa_chain = RetrievalQA.from_chain_type(
 llm=ChatOpenAI(
 model_name=""gpt-3.5-turbo"",
 callbacks=[FlyteCallbackHandler()],
 temperature=0,
 openai_api_key=json.loads(
 flytekit.current_context().secrets.get(SECRET_GROUP, SECRET_KEY)
            )[""openai_api_key""],
        ),
 chain_type=""stuff"",
 retriever=retriever,
    )


 result = qa_chain.run(query)
 return result




@workflow
def flyte_youtube_embed_wf(
 index_name: str = ""flyte-youtube-data"",
 urls: list[str] = [
 ""https://youtu.be/CNmO1q3MamM"",
 ""https://youtu.be/8rLj_YVOpzE"",
 ""https://youtu.be/sGqS8PFQz6c"",
 ""https://youtu.be/1668vZczslw"",
 ""https://youtu.be/NrFOXQKrREA"",
 ""https://youtu.be/4ktHNeT8kq4"",
 ""https://youtu.be/gMyTz8gKWVc"",
    ],
) -> list[str]:
 partial_embed_and_store = partial(embed_and_store, index_name=index_name)
 return map_task(partial_embed_and_store)(url=urls)"
singlyLinkedList.c,"#include <stdio.h>
#include <stdlib.h>


typedef struct {
 int info;
} DATA;


typedef struct node {
 DATA data;
 struct node* next;
} NODE;


void init(NODE** head) {
 *head = NULL;
}


void print_list(NODE* head) {
 NODE * temp;
 for (temp = head; temp; temp = temp->next)
 printf(""%5d"", temp->data.info);
}


NODE* add(NODE* node, DATA data) {
 NODE* temp = (NODE*) malloc(sizeof (NODE));
 if (temp == NULL) {
 exit(0); // no memory available
    }
 temp->data = data;
 temp->next = node;
 node = temp;
 return node;
}


void add_at(NODE* node, DATA data) {
 NODE* temp = (NODE*) malloc(sizeof (NODE));
 if (temp == NULL) {
 exit(EXIT_FAILURE); // no memory available
    }
 temp->data = data;
 temp->next = node->next;
 node->next = temp;
}


void remove_node(NODE* head) {
 NODE* temp = (NODE*) malloc(sizeof (NODE));
 if (temp == NULL) {
 exit(EXIT_FAILURE); // no memory available
    }
 temp = head->next;
 head->next = head->next->next;
 free(temp);
}


NODE * reverse_rec(NODE * ptr, NODE * previous) {
 NODE * temp;
 if (ptr->next == NULL) {
 ptr->next = previous;
 return ptr;
    } else {
 temp = reverse_rec(ptr->next, ptr);
 ptr->next = previous;
 return temp;
    }
}


NODE * reverse(NODE * node) {
 NODE * temp;
 NODE * previous = NULL;
 while (node != NULL) {
 temp = node->next;
 node->next = previous;
 previous = node;
 node = temp;
    }
 return previous;
}


NODE *free_list(NODE *head) {
 NODE *tmpPtr = head;
 NODE *followPtr;
 while (tmpPtr != NULL) {
 followPtr = tmpPtr;
 tmpPtr = tmpPtr->next;
 free(followPtr);
    }
 return NULL;
}


NODE *sort_list(NODE *head) {
 NODE *tmpPtr = head, *tmpNxt = head->next;
 DATA tmp;
 while (tmpNxt != NULL) {
 while (tmpNxt != tmpPtr) {
 if (tmpNxt->data.info < tmpPtr->data.info) {
 tmp = tmpPtr->data;
 tmpPtr->data = tmpNxt->data;
 tmpNxt->data = tmp;
            }
 tmpPtr = tmpPtr->next;
        }
 tmpPtr = head;
 tmpNxt = tmpNxt->next;
    }
 return tmpPtr;
}


int main() {
 int i;
 NODE* head;
 NODE* node;
 DATA element;
 printf(""Add Elements to List:\n"");
 init(&head);
 for (i = 53; i <= 63; i++) {
 element.info = i;
 printf(""Add Element %2d To The List.\n"", element.info);
 head = add(head, element);
    }
 printf(""\nPrint The List:\n"");
 print_list(head);
 printf(""\nRemove Element From The List:\n"");
 node = head->next->next;
 remove_node(node);
 printf(""\nAdd Element To The List:\n"");
 node = head->next->next->next;
 element.info = 2000;
 add_at(node, element);
 head = reverse(head); // Revers The List
 head = sort_list(head); // Sort The List
 head = free_list(head);
 return (EXIT_SUCCESS);
}"
foundry-vtt-macro-playlist-next.js,"(function() {
 game.playlists.filter(p => p.playing).forEach(p => p.playNext());
})()"
foundry-vtt-macro-stop-all-playlists.js,"(function({fadeDuration=5000}={}) {
 function fadeOutPlaylist(playlist, fadeDuration) {
 if (!playlist.playing) return;
 let playingSound = playlist.sounds.filter(s => s.playing).find(_ => true).sound;
 if (!!!playingSound) return; // should not happen
 let currVol = playingSound.volume;
 let globalVol = game.settings.get(""core"", ""globalPlaylistVolume"");
 if (currVol == 0) return;
 playingSound.fade(0, { duration: fadeDuration, from: currVol})
 setTimeout(() => playlist.stopAll(), fadeDuration);
 return;
 }


 game.playlists.filter(p => p.playing).forEach(p => fadeOutPlaylist(p, fadeDuration));
 ui.notifications.info(""Stopping all playlists"");
 
})({fadeDuration: 5000});"
foundry-vtt-macro-crossfade.js,"(function({fadeIn="""", fadeDuration=5000}={}) {
 function fadeInPlaylist(playlist, fadeDuration) {
 playlist.playAll().then(function(p) {
 let globalVol = game.settings.get(""core"", ""globalPlaylistVolume"");
 p.sounds.filter(s => s.playing).find(_ => true)
 .sound
 .fade(globalVol, { duration: fadeDuration, from: 0});
 });
 }
 
 function fadeOutPlaylist(playlist, fadeDuration) {
 if (!playlist.playing) return;
 let playingSound = playlist.sounds.filter(s => s.playing).find(_ => true).sound;
 if (!!!playingSound) return; // should not happen
 let currVol = playingSound.volume;
 let globalVol = game.settings.get(""core"", ""globalPlaylistVolume"");
 if (currVol == 0) return;
 playingSound.fade(0, { duration: fadeDuration, from: currVol})
 setTimeout(() => playlist.stopAll(), fadeDuration);
 return;
 }




 let playlistIn = game.playlists.filter(p => p.name == fadeIn).find(_ => true);
 let playlistOut = game.playlists.filter(p => p.playing).find(_ => true);
 if (!!!playlistIn) {
 ui.notifications.error(`Playlist not found: ""${fadeIn}""`);
 return;
 }
 
 let alreadyPlaying = game.playlists.filter(p => p.playing)
 .filter(p => p.id == playlistIn.id)
 .find(_ => true);
 if (!!alreadyPlaying) { 
 ui.notifications.info(`Already playing ${fadeIn}`);
 return;
 }
 
 game.playlists.filter(p => p.playing).forEach(p => fadeOutPlaylist(p, fadeDuration));
 fadeInPlaylist(playlistIn, fadeDuration);
 
})({fadeIn: ""playlist name"", fadeDuration: 5000});"
RPGF3_projects_on_EAS.py,"import json
import os
import requests




PROJECT_APP_SCHEMA = ""0x76e98cce95f3ba992c2ee25cef25f756495147608a3da3aa2e5ca43109fe77cc""
PROJECT_REVIEW_SCHEMA = ""0xebbf697d5d3ca4b53579917ffc3597fb8d1a85b8c6ca10ec10039709903b9277""
REVIEWER_ADDRESS = ""0x621477dBA416E12df7FF0d48E14c4D20DC85D7D9""
DATA_EXPORT_JSON = ""rpgf3_applicant_data.json""




def fetch_attestations(schema_id, time_created_after=0):
 """"""
    Generalized function to fetch attestations for a given schema ID.
    """"""


 url = 'https://optimism.easscan.org/graphql'
 query_limit = 100


 query = '''
    query Attestations($schemaId: StringFilter!, $skip: Int!, $take: Int!, $timeCreatedAfter: IntFilter) {
        attestations(where: {schemaId: $schemaId, timeCreated: $timeCreatedAfter}, take: $take, skip: $skip) {
            id
            attester
            recipient
            refUID
            revocable
            revocationTime
            expirationTime
            timeCreated 
            decodedDataJson    
        }
    }
    '''
 
 variables = {
 ""schemaId"": {
 ""equals"": schema_id
        },
 ""skip"": 0,
 ""take"": query_limit,
 ""timeCreatedAfter"": {
 ""gt"": time_created_after
        },
    }


 headers = {
 'Content-Type': 'application/json',
    }


 all_attestations = []


 while True:
 payload = {
 'query': query,
 'variables': variables
        }


 try:
 response = requests.post(url, headers=headers, data=json.dumps(payload))
 response.raise_for_status()


 data = response.json()
 attestations = data.get('data', {}).get('attestations', [])
 all_attestations.extend(attestations)


 if len(attestations) < query_limit:
 break


 variables[""skip""] += query_limit


 except (requests.exceptions.RequestException, json.JSONDecodeError) as e:
 print(f""Failed to fetch attestations for {schema_id}: {str(e)}"")
 break


 print(f""Total attestations for Schema ID {schema_id}: {len(all_attestations)}"")
 return all_attestations




def fetch_project_applications(app_schema_id):
 """"""
    Fetch all project applications from EAS and decode the data.
    """"""


 project_apps = fetch_attestations(app_schema_id)
 project_data = []
 for a in project_apps:
 decoded_data = json.loads(a[""decodedDataJson""])
 project_data.append({
 ""id"": a[""id""],
 ""attester"": a[""attester""],
 ""timeCreated"": a[""timeCreated""],
 ""data"": decoded_data
        })
 return project_data




def fetch_approved_project_ids(approval_schema_id, approver_address):
 """"""
    Fetch all approved project IDs from EAS.
    """"""


 approved_projects = fetch_attestations(approval_schema_id)
 approved_project_ids = []
 rejected_project_ids = []
 for a in approved_projects:
 if a[""attester""] != approver_address:
 continue
 data = json.loads(a[""decodedDataJson""])
 if data[0]['value']['value'] == True:
 approved_project_ids.append(a[""refUID""])
 else:
 rejected_project_ids.append(a[""refUID""])
 for rejected_id in rejected_project_ids:        
 if rejected_id in approved_project_ids:
 approved_project_ids.remove(rejected_id)
 return approved_project_ids




def fetch_json_data(url):
 """"""
    Fetch JSON data from a URL.
    """"""
 
 try:
 response = requests.get(url)
 response.raise_for_status()
 return response.json()
 except (requests.exceptions.RequestException, json.JSONDecodeError) as e:
 print(f""Error fetching JSON data from URL: {url}. Error: {str(e)}"")
 return None




def request_json_data(project_attestations):
 """"""
    Request and insert the JSON data for each project application.
    """"""


 for a in project_attestations:
 url = a[""data""][2][""value""][""value""]
 if isinstance(url, str) and "".json"" in url:
 json_data = fetch_json_data(url)
 if json_data:
 a.update({""json_data"": json_data})




def main():


 project_apps = fetch_project_applications(PROJECT_APP_SCHEMA)
 approved_project_ids = fetch_approved_project_ids(PROJECT_REVIEW_SCHEMA, REVIEWER_ADDRESS)
 approved_apps = [project for project in project_apps if project[""id""] in approved_project_ids]
 print(f""\nTotal approved projects: {len(approved_apps)}"")


 print(""\nRequesting JSON data for approved projects (this may take a minute)..."")
 request_json_data(approved_apps)


 with open(DATA_EXPORT_JSON, ""w"") as json_file:
 json.dump(approved_apps, json_file, indent=4)
 print(f""\nExported data to {DATA_EXPORT_JSON}."")




if __name__ == ""__main__"":
 main()"
WebCamDetect.cs,"using UnityEngine;


public class WebCamDetect : MonoBehaviour
{


 void Start()
 {
        WebCamDevice[] devices = WebCamTexture.devices;
        Debug.Log(""Number of web cams connected: "" + devices.Length);


 for (int i = 0; i < devices.Length; i++)
 {
            Debug.Log(i + "" "" + devices[i].name);
 }


 Renderer rend = this.GetComponentInChildren<Renderer>();


 WebCamTexture mycam = new WebCamTexture();
 string camName = devices[2].name;
        Debug.Log(""The webcam name is "" + camName);
        mycam.deviceName = camName;
        rend.material.mainTexture = mycam;


        mycam.Play();
 }
}"
main.py,"# dependencies
# pip install -U openai gradio


import os, openai
import gradio as gr
openai.api_key = 'sk-xxxxxx'


messages = [{""role"": ""system"", ""content"": """"""Assistant is an expert candidate in
             technical IT job interviews. Currently, the interview is
             focused on a position for Platform Engineer. So, you have skills
             with Terraform, Kubernetes, Docker, Ansible, Python, AWS, and
             more. For technical code questions, use Python. Provide clear,
             short, and concise answers and code. 
             Answers should look human and avoid too much formality when replying.
             Always provide answers in English!""""""}]


def transcribe(audio):
 global messages


 audio_filename_with_extension = audio + '.mp3'
 os.rename(audio, audio_filename_with_extension)


 audio_file = open(audio_filename_with_extension, ""rb"")
 transcript = openai.audio.transcriptions.create(
 model=""whisper-1"",
 file=audio_file,
 response_format=""text"",
 language='en'
    )


 messages.append({""role"": ""user"", ""content"": transcript})


 response = openai.chat.completions.create(model=""gpt-4-1106-preview"", messages=messages)


 message_role = response.choices[0].message.role
 message_content = response.choices[0].message.content
 messages.append({""role"": message_role, ""content"": message_content})


 chat_transcript = """"
 for message in messages:
 if message['role'] != 'system':
 chat_transcript += message['role'] + "": "" + message['content'] + ""\n\n""
 return chat_transcript




ui = gr.Interface(fn=transcribe, inputs=gr.Audio(sources=[""microphone""], type=""filepath""), outputs=""text"").launch()
ui.launch()"
scpitester.c,"/* Compile with -DUSE_READLINE and -lreadline to use readline for input. */


#include <arpa/inet.h>
#include <errno.h>
#include <poll.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <unistd.h>


#ifdef USE_READLINE
#include <readline/history.h>
#include <readline/readline.h>
#endif /* USE_READLINE */


#define NETBFRLEN 1024


int clientsocket;


void closeclient() {
 if (clientsocket != -1 && clientsocket != 0) {
 // shutdown(clientsocket, SHUT_WR);
 // shutdown(clientsocket, SHUT_RD);
 close(clientsocket);
  }
}


void sighandler(int s) {
 closeclient();
 _exit(0);
}


int main(int argc, char** argv) {
 if (argc == 1) {
 fprintf(stderr, ""Please supply address and port\n"");
 return 1;
  }


 struct sigaction sigint_handler;
 sigint_handler.sa_handler = sighandler;
 sigemptyset(&sigint_handler.sa_mask);
 sigint_handler.sa_flags = 0;
 sigaction(SIGINT, &sigint_handler, NULL);


 char inbuffer[NETBFRLEN] = {0};
 struct sockaddr_in server_addr;
 socklen_t addr_size;


 if ((clientsocket = socket(PF_INET, SOCK_DGRAM, 0)) == -1) {
 perror(""socket"");
 return 1;
  }


 server_addr.sin_family = AF_INET;
 server_addr.sin_port = htons(atoi(argv[2]));
 server_addr.sin_addr.s_addr = inet_addr(argv[1]);
 memset(server_addr.sin_zero, 0, sizeof(server_addr.sin_zero));


 addr_size = sizeof(server_addr);
#if 0
 if (connect(clientsocket, (struct sockaddr*)&serverAddr, addr_size) == -1) {
 perror(""connect"");
 return 1;
  }
#endif


#ifndef USE_READLINE
 char input[256] = {0};
#else
 char* input;
#endif /* USE_READLINE */
 ssize_t outbytes, inbytes;
 int status;


 struct pollfd pfd;
 pfd.events = POLLIN;
 pfd.fd = clientsocket;


 puts(""Enter SCPI commands here.\n""
 ""Queries will timeout after 1 second.\n""
 ""Type 'quit', 'exit', or Control-C to quit."");


#ifdef USE_READLINE
 puts(""Readline line editing features are supported."");
#endif /* USE_READLINE */


 while (1) {
#ifndef USE_READLINE
 printf(""> "");
 scanf("" %253[^\n]"", input);
#else
 input = readline(""> "");
 if (!input) {
 closeclient();
 return 0;
    }
#endif /* USE_READLINE */


 if (0 == strcmp(input, ""quit"") || 0 == strcmp(input, ""exit"")) {
 closeclient();
 return 0;
    }


#ifdef USE_READLINE
 add_history(input);
#endif /* USE_READLINE */


 size_t l = strlen(input);
#ifdef USE_READLINE
 input = realloc(input, l + 3);
 if (!input) {
 perror(""realloc"");
 closeclient();
 return 1;
    }
#endif /* USE_READLINE */


 strcpy(input + l, ""\r\n"");


 // outbytes = write(clientsocket, input, strlen(input));
 outbytes = sendto(clientsocket, input, strlen(input), 0,
                      (struct sockaddr*)&server_addr, addr_size);
 if (outbytes == -1) {
 perror(""write"");
 closeclient();
 return 1;
    }


 if (NULL != strchr(input, '?')) {
 status = poll(&pfd, 1, 1000);
 if (status == 0) {
 printf(""No response from server within 1 second!\n"");
      } else if (status == -1) {
 perror(""poll"");
 closeclient();
 return 1;
      } else {
 inbytes = read(clientsocket, inbuffer, NETBFRLEN);
 if (inbytes == -1) {
 perror(""read"");
 closeclient();
 return 1;
        }


 printf(""%s"", inbuffer);
 memset(inbuffer, 0, NETBFRLEN);
      }
    }


#ifdef USE_READLINE
 free(input);
#endif /* USE_READLINE */
  }


 return 0;
}"
simple-hash.js,"// This is a simple, *insecure* hash that's short, fast, and has no dependencies.
// For algorithmic use, where security isn't needed, it's way simpler than sha1 (and all its deps)
// or similar, and with a short, clean (base 36 alphanumeric) result.
// Loosely based on the Java version; see
// https://stackoverflow.com/questions/6122571/simple-non-secure-hash-function-for-javascript
const simpleHash = str => {
 let hash = 0;
 for (let i = 0; i < str.length; i++) {
 const char = str.charCodeAt(i);
 hash = (hash << 5) - hash + char;
 hash &= hash; // Convert to 32bit integer
 }
 return new Uint32Array([hash])[0].toString(36);
};"
jQuery.js,"// callback-функция, которая выполнится, когда DOM будет загружен. 
$(function(){
 // DOM загружен. 
 });


// селекторы
$('div') // выберет все элементы div.


$('#el') // выберет элемент с id #el


$('.elements') // выберет все элементы с классом elements


$('li:odd') // выберет нечетные элементы li


$('li:even') // выберет четные элементы li


$('div , a') // выберет все эллементы div и a


$('#el a') // выберет все элементы a, находящиеся внутри #el


$('#el > a') // выберет все а, которые являются дочерними для #el


$('#el + a') // выберет все a, которые идут сразу после #el


$('a:not(""#el a"")'); // выберет все элементы a, не находящиеся внутри #el


$('p[align=""left""]') // выберет все p со значением left в атрибуте align


$(""div"", $("".new"")) и $("".new div"") // выберет все элементы внутри элементов с классом new (в этом случае второй вариант предпочтительнее). 


$('#new').parent() // выберет родительский эллемент (тот в который вложен наш #new)


$('#new').next() // выберет следующиё эллемент после #new


$('#new').siblings() // выберет всех соседей #new


$('#new').find('ul') // выберет все ul которые находятся внутри #new


$('#new').closest('div') // выберет ближайший к #new эллемент div


// события


$(window).resize(function(){ // при изминении окна браузера
 console.log(window.innerHeight, window.innerWidth); // выводим в консовь высоту и ширину окна 
});


$('#nav').on(""click"", function () {
 $(this).css('color','red');
 });
// изменит цвет элемента с id nav, при клике


$('#nav').on(""click"", function () {
 $('span', this).css('color','red');
 });
// изменит цвет span, который нвходится внутри элемента с id nav, при клике
 
$('button').on(""click"", {user:""Test""} ,function (e) {
 $(this).css('color','red');
 console.log(e.data.user)
 });
// изменит цвет элемента с id nav, при клике, 
// и при этом событии (е) вызовет console.log(e.data.user), 
// user мы объявили в самой функции


$('.someDiv').on(""click"", function (e) {
 $('#modal-div').css(""background-color"", $(e.target).css(""background-color""));
 });
// при клике на .someDiv, будет меняться фон #modal-div, на тот что указан в .someDiv...
// $(e.target) это тот элемент с которым было соверешено событие


$('#send').trigger('click'); // выполнит событие клик на элементе #send и вызовет обработчик(если такое есть)


$('.list').wrap('<span></span>') // обернёт в спан все эллементы с классом list


 $('<a/>', {
 text    :   'Ссылка на Яндекс',
 title   :   'Это Яндекс',
 href    :   'http://ya.ru',
 target  :   '_blank',
 'class' :   'red',
 css     :   {
 fontSize       :   16,
 textTransform  :   'uppercase',
 fontWeight     :   700 
 },
 click   :   function(){
 alert('Сейчас пойдем на Яндекс');
 return true;
 } 
 }).appendTo('#parentDiv');
// создаст ссылку со всеми атрибутами что мы задали в том числе и с оброботчиком события click, и вставит её в #parentDiv
// кроме appendTo() есть ещё prependTo(), after(), before и тд.


// Анимация
$(""#book"").animate({
 opacity: 0.25,
 left: ""+=50""
 }, 5000);
 // анимирует #book, меняет свойства его css с заданной скоростью


$('#modal').animate({height: 400}, {duration: 1000, queue: false})
 .animate({width: 400}, {duration: 1000, queue: false})
 .animate({top:(window.innerHeight - 400) / 2}, {duration: 1000, queue: false})
 .animate({left:(window.innerWidth - 400) / 2}, {duration: 1000, queue: false});
// анимирует элемент #modal, все анимации происходят одновременно(queue: false)
// .animate(css, дополнительные параметры)


$(this).animate({width:300},{duration: 1000, specialEasing:{width:'swing'}, complete: function(){alert('анимация закончилась')}});
// параметр specialEasing изменяет метод анимации в данном случае (swing)
// в параметре complete - функция которая вызовется по окончанию анимации


/*-------------Ajax---------------------------------------*/


<p id=""content""></p>
<form id=""mail_send"">
 <input type=""email"" name=""mail"">
 <button type=""submit"">Send</button>
</form>


<script>
 $('#mail_send').submit(function () {
 var str = $(this).serialize(); // тут получаем сериализованую строку значений полей формы
 $.ajax({
 type: ""POST"", // метод
 url: ""mail.php"", // путь
 data: str, // передаём в php сериализованую строку, которую он получет виде массива $_POST
 success: function (html) { // функция в случе успеха
 $('#content').html(html); // записываем в #content, то что нам вернул файл mail.php
 }
 });
 return false; // для того что бы остановить выполнение
 });
</script>


/*--------------------Передаём данные с PHP в JS с помощью Ajax--------------------------------*/
// cars.php
<?php
$cars = ['audi','bmw','lexus'=>['rx', 'gx']];
print json_encode($cars); // ковертируем в JSON формат
?>
// js
$('#cars').click(function () {
        $.ajax({
            url: ""cars.php"",
            success: function (html) {
                var res = $.parseJSON(html); // конвертируем плученый JSON, в javascript-объект
                console.dir(res); // выводим в консоль
            }
        });
    });


/*--------------------Передаём данные с JS в PHP с помощью Ajax--------------------------------*/
// cars.php
<?php
print_r($_POST['cars']);
?>
 
var cars = ['toyota', 'nissan', 'honda']; // js массив

    $('#cars').click(function () {
        $.ajax({
            url: ""php/hello.php"",
            type: ""POST"",
            data: {cars: cars}, // передаём массив cars, в PHP получем его в виде $_POST['cars']
            success: function (html) {
                console.log(html); // выводим в консоль
            }
        });
    });"
hyper.js,"module.exports = {
 config: {
 // default font size in pixels for all tabs
 fontSize: 12,


 // font family with optional fallbacks
 fontFamily: 'Menlo, ""DejaVu Sans Mono"", Consolas, ""Lucida Console"", monospace',


 // terminal cursor background color and opacity (hex, rgb, hsl, hsv, hwb or cmyk)
 cursorColor: 'rgba(248,28,229,0.8)',


 // `BEAM` for |, `UNDERLINE` for _, `BLOCK` for █
 cursorShape: 'BLOCK',


 // color of the text
 foregroundColor: '#fff',


 // terminal background color
 backgroundColor: '#000',


 // border color (window, tabs)
 borderColor: '#333',


 // custom css to embed in the main window
 css: '',


 // custom css to embed in the terminal window
 termCSS: '',


 // set to `true` (without backticks) if you're using a Linux setup that doesn't show native menus
 // default: `false` on Linux, `true` on Windows (ignored on macOS)
 showHamburgerMenu: '',


 // set to `false` if you want to hide the minimize, maximize and close buttons
 // additionally, set to `'left'` if you want them on the left, like in Ubuntu
 // default: `true` on windows and Linux (ignored on macOS)
 showWindowControls: '',


 // custom padding (css format, i.e.: `top right bottom left`)
 padding: '12px 14px',


 // the full list. if you're going to provide the full color palette,
 // including the 6 x 6 color cubes and the grayscale map, just provide
 // an array here instead of a color map object
 colors: {
 black: '#000000',
 red: '#ff0000',
 green: '#33ff00',
 yellow: '#ffff00',
 blue: '#0066ff',
 magenta: '#cc00ff',
 cyan: '#00ffff',
 white: '#d0d0d0',
 lightBlack: '#808080',
 lightRed: '#ff0000',
 lightGreen: '#33ff00',
 lightYellow: '#ffff00',
 lightBlue: '#0066ff',
 lightMagenta: '#cc00ff',
 lightCyan: '#00ffff',
 lightWhite: '#ffffff'
 },


 // the shell to run when spawning a new session (i.e. /usr/local/bin/fish)
 // if left empty, your system's login shell will be used by default
 // make sure to use a full path if the binary name doesn't work
 // (e.g `C:\\Windows\\System32\\bash.exe` instad of just `bash.exe`)
 // if you're using powershell, make sure to remove the `--login` below
 shell: 'C:\\Program Files\\Git\\git-cmd.exe',


 // for setting shell arguments (i.e. for using interactive shellArgs: ['-i'])
 // by default ['--login'] will be used
 shellArgs: ['--command=usr/bin/bash.exe', '-l', '-i'],


 // for environment variables
 env: { TERM: 'cygwin'},


 // set to false for no bell
 bell: 'SOUND',


 // if true, selected text will automatically be copied to the clipboard
 copyOnSelect: false


 // if true, on right click selected text will be copied or pasted if no
 // selection is present (true by default on Windows)
 // quickEdit: true


 // URL to custom bell
 // bellSoundURL: 'http://example.com/bell.mp3',


 // for advanced config flags please refer to https://hyper.is/#cfg
 },


 // a list of plugins to fetch and install from npm
 // format: [@org/]project[#version]
 // examples:
 //   `hyperpower`
 //   `@company/project`
 //   `project#1.0.1`
 plugins: [],


 // in development, you can create a directory under
 // `~/.hyper_plugins/local/` and include it here
 // to load it and avoid it being `npm install`ed
 localPlugins: []
};"
be_x64.cpp,"#define _CRT_SECURE_NO_WARNINGS
#include <string.h>
#include <stdio.h>
#include <windows.h>
#pragma warning (disable: 4146)
#include <stdint.h>


#ifdef _DEBUG
#define Assert(x) \
 if (!(x)) { MessageBoxA(0, #x, ""Assertion Failure"", MB_OK); __debugbreak(); }
#else
#define Assert(x)
#endif


bool IsPowerOfTwo(uint32_t value) {
 return value != 0 && (value & (value - 1)) == 0;
}


uint32_t Log2(uint32_t value) {
 uint32_t n = 0;
 while (value > 1) {
        value /= 2;
        n++;
    }
 return n;
}


// Emitter


enum {
    RAX = 0,
    RCX = 1,
    RDX = 2,
    RBX = 3,
    RSP = 4,
    RBP = 5,
    RSI = 6,
    RDI = 7,
    R8 = 8,
    R9 = 9,
    R10 = 10,
    R11 = 11,
    R12 = 12,
    R13 = 13,
    R14 = 14,
    R15 = 15
};


typedef uint8_t Register;


enum Scale {
    X1 = 0,
    X2 = 1,
    X4 = 2,
    X8 = 3
};


enum Mode {
    INDIRECT = 0,
    INDIRECT_BYTE_DISPLACED = 1,
    INDIRECT_DISPLACED = 2,
    DIRECT = 3,
};


enum ConditionCode {
    O,
    NO,
    B,
    NB,
    E,
    NE,
    NA,
    A,
    S,
    NS,
    P,
    NP,
    L,
    NL,
    NG,
    G,
    NAE = B,
    C = B,
    AE = NB,
    NC = NB,
    Z = E,
    NZ = NE,
    BE = NA,
    NBE = A,
    PE = P,
    PO = NP,
    NGE = L,
    GE = NL,
    LE = NG,
    NLE = G
};


uint8_t *data;
uint8_t *code;
uint8_t *next_code;


void DumpCode(char *filename) {
    FILE *file = fopen(filename, ""wb"");
 fwrite(code, next_code - code, 1, file);
 fclose(file);
}


void Emit(uint8_t value) {
    *next_code = value;
    next_code++;
}


void Emit4(uint32_t value) {
 Emit(value & 0xFF);
 Emit((value >> 8) & 0xFF);
 Emit((value >> 16) & 0xFF);
 Emit((value >> 24) & 0xFF);
}


void Emit8(uint64_t value) {
 Emit(value & 0xFF);
 Emit((value >> 8) & 0xFF);
 Emit((value >> 16) & 0xFF);
 Emit((value >> 24) & 0xFF);
 Emit((value >> 32) & 0xFF);
 Emit((value >> 40) & 0xFF);
 Emit((value >> 48) & 0xFF);
 Emit((value >> 56) & 0xFF);
}


void EmitModRxRm(uint8_t mod, uint8_t rx, uint8_t rm) {
 Assert(mod < 4);
 Assert(rx < 16);
 Assert(rm < 16);
 Emit((mod << 6) | ((rx & 7) << 3) | (rm & 7));
}


void EmitRexIndexed(uint8_t rx, uint8_t base, uint8_t index) {
 Emit(0x48 | (base >> 3) | ((index >> 3) << 1) | ((rx >> 3) << 2));
}


void EmitRex(uint8_t rx, uint8_t base) {
 EmitRexIndexed(rx, base, 0);
}


// op rax, rcx
// rx = RAX, reg = RCX
void EmitDirect(uint8_t rx, Register reg) {
 EmitModRxRm(DIRECT, rx, reg);
}


// op rax, [rcx]
// rx = RAX, base = RCX
void EmitIndirect(uint8_t rx, Register base) {
 Assert((base & 7) != RSP);
 Assert((base & 7) != RBP);
 EmitModRxRm(INDIRECT, rx, base);
}


// op rax, [rip + 0x12345678]
// rx = RAX, displacement = 0x12345678
void EmitIndirectDisplacedRip(uint8_t rx, int32_t displacement) {
 EmitModRxRm(INDIRECT, rx, RBP);
 Emit4(displacement);
}


// op rax, [rcx + 0x12]
// rx = RAX, base = RCX, displacement = 0x12
void EmitIndirectByteDisplaced(uint8_t rx, Register base, int8_t displacement) {
 Assert((base & 7) != RSP);
 EmitModRxRm(INDIRECT_BYTE_DISPLACED, rx, base);
 Emit(displacement);
}


// op rax, [rcx + 0x12345678]
// rx = RAX, base = RCX, displacement = 0x12345678
void EmitIndirectDisplaced(uint8_t rx, Register base, int32_t displacement) {
 Assert((base & 7) != RSP);
 EmitModRxRm(INDIRECT_DISPLACED, rx, base);
 Emit4(displacement);
}


// op rax, [rcx + 4*rdx]
// rx = RAX, base = RCX, index = RDX, scale = X4
void EmitIndirectIndexed(uint8_t rx, Register base, Register index, Scale scale) {
 Assert((base & 7) != RBP);
 EmitModRxRm(INDIRECT, rx, RSP);
 EmitModRxRm(scale, index, base);
}


// op rax, [rcx + 4*rdx + 0x12]
// rx = RAX, base = RCX, index = RDX, scale = X4, displacement = 0x12
void EmitIndirectIndexedByteDisplaced(uint8_t rx, Register base, Register index, Scale scale, int8_t displacement) {
 EmitModRxRm(INDIRECT_BYTE_DISPLACED, rx, RSP);
 EmitModRxRm(scale, index, base);
 Emit(displacement);
}


// op rax, [rcx + 4*rdx + 0x12345678]
// rx = RAX, base = RCX, index = RDX, scale = X4, displacement = 0x12345678
void EmitIndirectIndexedDisplaced(uint8_t rx, Register base, Register index, Scale scale, int32_t displacement) {
 EmitModRxRm(INDIRECT_DISPLACED, rx, RSP);
 EmitModRxRm(scale, index, base);
 Emit4(displacement);
}


// op rax, [0x12345678]
// rx = RAX, displacement = 0x12345678
void EmitDisplaced(uint8_t rx, int32_t displacement) {
 EmitModRxRm(INDIRECT, rx, RSP);
 EmitModRxRm(X1, RSP, RBP);
 Emit4(displacement);
}


#define EMIT_I(operation, source_immediate) \
 EmitRex(0, 0); \
    Emit_##operation##_I(); \
 Emit4(source_immediate)


#define EMIT_MOV64_R_I(destination, source_immediate) \
 EmitRex(0, destination); \
 Emit(0xB8 + (destination & 7)); \
 Emit8(source_immediate)


#define EMIT_MOV64_RAX_OFF(source_offset) \
 EmitRex(0, 0); \
 Emit(0xA1); \
 Emit8(source_offset)


#define EMIT_MOV64_OFF_RAX(destination_offset) \
 EmitRex(0, 0); \
 Emit(0xA3); \
 Emit8(destination_offset)


#define EMIT_R_R(operation, destination, source) \
 EmitRex(destination, source); \
    Emit_##operation##_R(); \
 EmitDirect(destination, source)


#define EMIT_R_RIPD(operation, destination, source_displacement) \
 EmitRex(destination, 0); \
    Emit_##operation##_R(); \
 EmitIndirectDisplacedRip(destination, source_displacement);


#define EMIT_R_D(operation, destination, source_displacement) \
 EmitRex(destination, 0); \
    Emit_##operation##_R(); \
 EmitDisplaced(destination, source_displacement)


#define EMIT_R_M(operation, destination, source) \
 EmitRex(destination, source); \
    Emit_##operation##_R(); \
 EmitIndirect(destination, source)


#define EMIT_R_MD1(operation, destination, source, source_displacement) \
 EmitRex(destination, source); \
    Emit_##operation##_R(); \
 EmitIndirectByteDisplaced(destination, source, source_displacement)


#define EMIT_R_MD(operation, destination, source, source_displacement) \
 EmitRex(destination, source); \
    Emit_##operation##_R(); \
 EmitIndirectDisplaced(destination, source, source_displacement)


#define EMIT_R_SIB(operation, destination, source_base, source_scale, source_index) \
 EmitRexIndexed(destination, source_base, source_index); \
    Emit_##operation##_R(); \
 EmitIndirectIndexed(destination, source_base, source_index, source_scale)


#define EMIT_R_SIBD1(operation, destination, source_base, source_scale, source_index, source_displacement) \
 EmitRexIndexed(destination, source_base, source_index); \
    Emit_##operation##_R(); \
 EmitIndirectIndexedByteDisplaced(destination, source_base, source_index, source_scale, source_displacement)


#define EMIT_R_SIBD(operation, destination, source_base, source_scale, source_index, source_displacement) \
 EmitRexIndexed(destination, source_base, source_index); \
    Emit_##operation##_R(); \
 EmitIndirectIndexedDisplaced(destination, source_base, source_index, source_scale, source_displacement)


#define EMIT_M_R(operation, destination, source) \
 EmitRex(source, destination); \
    Emit_##operation##_M(); \
 EmitIndirect(source, destination)


#define EMIT_D_R(operation, destination_displacement, source) \
 EmitRex(source, 0); \
    Emit_##operation##_M(); \
 EmitDisplaced(source, destination_displacement)


#define EMIT_RIPD_R(operation, destination_displacement, source) \
 EmitRex(source, 0); \
    Emit_##operation##_M(); \
 EmitIndirectDisplacedRip(source, destination_displacement);


#define EMIT_MD1_R(operation, destination, destination_displacement, source) \
 EmitRex(source, destination); \
    Emit_##operation##_M(); \
 EmitIndirectByteDisplaced(source, destination, destination_displacement)


#define EMIT_MD_R(operation, destination, destination_displacement, source) \
 EmitRex(source, destination); \
    Emit_##operation##_M(); \
 EmitIndirectDisplaced(source, destination, destination_displacement)


#define EMIT_SIB_R(operation, destination_base, destination_scale, destination_index, source) \
 EmitRexIndexed(source, destination_base, destination_index); \
    Emit_##operation##_M(); \
 EmitIndirectIndexed(source, destination_base, destination_index, destination_scale)


#define EMIT_SIBD1_R(operation, destination_base, destination_scale, destination_index, destination_displacement, source) \
 EmitRexIndexed(source, destination_base, destination_index); \
    Emit_##operation##_M(); \
 EmitIndirectIndexedByteDisplaced(source, destination_base, destination_index, destination_scale, destination_displacement)


#define EMIT_SIBD_R(operation, destination_base, destination_scale, destination_index, destination_displacement, source) \
 EmitRexIndexed(source, destination_base, destination_index); \
    Emit_##operation##_M(); \
 EmitIndirectIndexedDisplaced(source, destination_base, destination_index, destination_scale, destination_displacement)


#define EMIT_R_I(operation, destination, source_immediate) \
 EmitRex(0, destination); \
    Emit_##operation##_I(); \
 EmitDirect(extension_##operation##_I, destination); \
 Emit4(source_immediate)


#define EMIT_R_I1(operation, destination, source_immediate) \
 EmitRex(0, destination); \
    Emit_##operation##_I1(); \
 EmitDirect(extension_##operation##_I1, destination); \
 Emit(source_immediate)


#define EMIT_M_I(operation, destination, source_immediate) \
 EmitRex(0, destination); \
    Emit_##operation##_I(); \
 EmitIndirect(extension_##operation##_I, destination); \
 Emit4(source_immediate)


#define EMIT_D_I(operation, destination_displacement, source_immediate) \
 EmitRex(0, 0); \
    Emit_##operation##_I(); \
 EmitDisplaced(extension_##operation##_I, destination_displacement); \
 Emit4(source_immediate)


#define EMIT_RIPD_I(operation, destination_displacement, source_immediate) \
 EmitRex(0, 0); \
    Emit_##operation##_I(); \
 EmitIndirectDisplacedRip(extension_##operation##_I, destination_displacement); \
 Emit4(source_immediate)


#define EMIT_MD1_I(operation, destination, destination_displacement, source_immediate) \
 EmitRex(0, destination); \
    Emit_##operation##_I(); \
 EmitIndirectByteDisplaced(extension_##operation##_I, destination, destination_displacement); \
 Emit4(source_immediate)


#define EMIT_MD_I(operation, destination, destination_displacement, source_immediate) \
 EmitRex(0, destination); \
    Emit_##operation##_I(); \
 EmitIndirectDisplaced(extension_##operation##_I, destination, destination_displacement); \
 Emit4(source_immediate)


#define EMIT_SIB_I(operation, destination_base, destination_scale, destination_index, source_immediate) \
 EmitRexIndexed(0, destination_base, destination_index); \
    Emit_##operation##_I(); \
 EmitIndirectIndexed(extension_##operation##_I, destination_base, destination_index, destination_scale); \
 Emit4(source_immediate)


#define EMIT_SIBD1_I(operation, destination_base, destination_scale, destination_index, destination_displacement, source_immediate) \
 EmitRexIndexed(0, destination_base, destination_index); \
    Emit_##operation##_I(); \
 EmitIndirectIndexedByteDisplaced(extension_##operation##_I, destination_base, destination_index, destination_scale, destination_displacement); \
 Emit4(source_immediate)


#define EMIT_SIBD_I(operation, destination_base, destination_scale, destination_index, destination_displacement, source_immediate) \
 EmitRexIndexed(0, destination_base, destination_index); \
    Emit_##operation##_I(); \
 EmitIndirectIndexedDisplaced(extension_##operation##_I, destination_base, destination_index, destination_scale, destination_displacement); \
 Emit4(source_immediate)


#define EMIT_X_R(operation, source) \
 EmitRex(0, source); \
    Emit_##operation##_X(); \
 EmitDirect(extension_##operation##_X, source)


#define EMIT_X_RIPD(operation, source_displacement) \
 EmitRex(0, 0); \
    Emit_##operation##_X(); \
 EmitIndirectDisplacedRip(extension_##operation##_X, source_displacement);


#define EMIT_X_D(operation, source_displacement) \
 EmitRex(0, 0); \
    Emit_##operation##_X(); \
 EmitDisplaced(extension_##operation##_X, source_displacement)


#define EMIT_X_M(operation, source) \
 EmitRex(0, source); \
    Emit_##operation##_X(); \
 EmitIndirect(extension_##operation##_X, source)


#define EMIT_X_MD1(operation, source, source_displacement) \
 EmitRex(0, source); \
    Emit_##operation##_X(); \
 EmitIndirectByteDisplaced(extension_##operation##_X, source, source_displacement)


#define EMIT_X_MD(operation, source, source_displacement) \
 EmitRex(0, source); \
    Emit_##operation##_X(); \
 EmitIndirectDisplaced(extension_##operation##_X, source, source_displacement)


#define EMIT_X_SIB(operation, source_base, source_scale, source_index) \
 EmitRexIndexed(0, source_base, source_index); \
    Emit_##operation##_X(); \
 EmitIndirectIndexed(extension_##operation##_X, source_base, source_index, source_scale)


#define EMIT_X_SIBD1(operation, source_base, source_scale, source_index, source_displacement) \
 EmitRexIndexed(0, source_base, source_index); \
    Emit_##operation##_X(); \
 EmitIndirectIndexedByteDisplaced(extension_##operation##_X, source_base, source_index, source_scale, source_displacement)


#define EMIT_X_SIBD(operation, source_base, source_scale, source_index, source_displacement) \
 EmitRexIndexed(0, source_base, source_index); \
    Emit_##operation##_X(); \
 EmitIndirectIndexedDisplaced(extension_##operation##_X, source_base, source_index, source_scale, source_displacement)


#define EMIT_C_I(operation, condition_code, source_immediate) \
    Emit_##operation##_C_I(condition_code); \
 Emit4(source_immediate)


#define OPERATION_1_R(operation, opcode) \
 void Emit_##operation##_R() { \
 Emit(opcode); \
    }


#define OPERATION_1_M(operation, opcode) \
 void Emit_##operation##_M() { \
 Emit(opcode); \
    }


#define OPERATION_1_I(operation, opcode, extension) \
 void Emit_##operation##_I() { \
 Emit(opcode); \
    } \
 enum { extension_##operation##_I = extension };


#define OPERATION_1_I1(operation, opcode, extension) \
 void Emit_##operation##_I1() { \
 Emit(opcode); \
    } \
 enum { extension_##operation##_I1 = extension };


#define OPERATION_1_X(operation, opcode, extension) \
 void Emit_##operation##_X() { \
 Emit(opcode); \
    } \
 enum { extension_##operation##_X = extension };


#define OPERATION_2_C_I(operation, opcode) \
 void Emit_##operation##_C_I(ConditionCode condition_code) { \
 Emit(0x0F); \
 Emit(opcode + condition_code); \
    }


OPERATION_1_R(MOV, 0x8B)
OPERATION_1_M(MOV, 0x89)
OPERATION_1_I(MOVSX, 0xC7, 0x00)


OPERATION_1_I1(SHL, 0xC1, 0x04)


OPERATION_1_I1(SHR, 0xC1, 0x05)


OPERATION_1_R(ADD, 0x03)
OPERATION_1_M(ADD, 0x01)
OPERATION_1_I(ADD, 0x81, 0x00)


OPERATION_1_R(SUB, 0x2B)
OPERATION_1_M(SUB, 0x29)
OPERATION_1_I(SUB, 0x81, 0x05)


OPERATION_1_X(MUL, 0xF7, 0x04)


OPERATION_1_X(DIV, 0xF7, 0x06)


OPERATION_1_I(CMP, 0x81, 0x07)


OPERATION_1_I(JMP, 0xE9, 0x00)


OPERATION_2_C_I(J, 0x80)


// Emitter tests


void Test_Emitter() {
 EMIT_MOV64_R_I(RBX, 0x12345678deadbeefull);
 EMIT_MOV64_RAX_OFF(0x12345678deadbeefull);
 EMIT_MOV64_OFF_RAX(0x12345678deadbeefull);
 EMIT_R_R(MOV, RAX, R10);
 EMIT_M_R(MOV, RAX, R10);
 EMIT_I(JMP, 0x1234);
 EMIT_C_I(J, NZ, 0x1234);
 EMIT_C_I(J, NZ, 0x1234);
 EMIT_C_I(J, NZ, 0x1234);
 EMIT_D_I(ADD, 0x1234578, 0xDEADBEEF);
 EMIT_RIPD_I(ADD, 0x1234578, 0xDEADBEEF);
 for (uint8_t d = RAX; d <= R15; d++) {
        Register destination = (Register)d;
 EMIT_X_R(MUL, destination);
 if ((destination & 7) != RSP) {
 EMIT_X_MD1(MUL, destination, 0x12);
 EMIT_X_MD(MUL, destination, 0x12345678);
 if ((destination & 7) != RBP) {
 EMIT_X_M(MUL, destination);
 EMIT_X_SIB(MUL, destination, X4, R8);
 EMIT_X_SIBD1(MUL, destination, X4, R8, 0x12);
 EMIT_X_SIBD(MUL, destination, X4, R8, 0x12345678);
            }
        }
 EMIT_R_I(ADD, destination, 0xDEADBEEF);
 if ((destination & 7) != RSP) {
 EMIT_MD1_I(ADD, destination, 0x12, 0xDEADBEEF);
 EMIT_MD_I(ADD, destination, 0x12345678, 0xDEAFBEEF);
 if ((destination & 7) != RBP) {
 EMIT_SIB_I(ADD, destination, X4, R8, 0xDEADBEEF);
            }
        }
 EMIT_R_RIPD(ADD, destination, 0x1235678);
 EMIT_R_D(ADD, destination, 0x1235678);
 EMIT_RIPD_R(ADD, 0x1235678, destination);
 EMIT_D_R(ADD, 0x1235678, destination);
 for (uint8_t s = RAX; s <= R15; s++) {
            Register source = (Register)s;
 EMIT_R_R(ADD, destination, source);
 if ((source & 7) != RBP) {
 EMIT_R_SIB(ADD, destination, source, X4, destination);
 EMIT_R_SIBD1(ADD, destination, source, X4, destination, 0x12);
 EMIT_R_SIBD(ADD, destination, source, X4, destination, 0x12345678);
            }
 if ((destination & 7) != RBP) {
 EMIT_SIB_R(ADD, destination, X4, source, source);
 EMIT_SIBD1_R(ADD, destination, X4, source, 0x12, source);
 EMIT_SIBD_R(ADD, destination, X4, source, 0x12345678, source);
            }
 if ((source & 7) != RSP && (source & 7) != RBP) {
 EMIT_R_M(ADD, destination, source);
 EMIT_R_MD1(ADD, destination, source, 0x12);
 EMIT_R_MD(ADD, destination, source, 0x12345678);
            }
 if ((destination & 7) != RSP && (destination & 7) != RBP) {
 EMIT_M_R(ADD, destination, source);
 EMIT_MD1_R(ADD, destination, 0x12, source);
 EMIT_MD_R(ADD, destination, 0x12345678, source);
            }
 if ((source & 7) == RSP) {
 EMIT_R_SIB(ADD, destination, source, X1, RSP);
#if 0
                EmitRex(destination, source);
                EmitAddToRegister();
                EmitIndirectIndexed(destination, source, RSP, X1);
#endif
            }
        }
    }
 DumpCode(""d:\\be\\test.bin"");
}


// String table


// TODO: replace with something beter
uint64_t HashString(char *string, size_t length) {
 static const uint64_t fnv_prime = 0x100000001b3ull;
 static const uint64_t fnv_initializer = 0xcbf29ce484222325ull;
 uint64_t hash = fnv_initializer;
 for (size_t i = 0; i < length; i++) {
        hash ^= string[i];
        hash *= fnv_prime;
    }
 return hash;
}


struct HashedString {
 uint64_t hash;
 char *string;
};


enum {
    MAX_HASHED_STRINGS = 1024,
    MAX_STRING_DATA = 1024 * 1024
};


char string_data[MAX_STRING_DATA];
char *next_string_data = string_data;


HashedString hashed_strings[MAX_HASHED_STRINGS];
size_t hashed_strings_count;


char *InternString(char *string, size_t length) {
 uint64_t hash = HashString(string, length);
 for (size_t i = 0; i < hashed_strings_count; i++) {
 if (hashed_strings[i].hash == hash && strncmp(hashed_strings[i].string, string, length) == 0) {
 return hashed_strings[i].string;
        }
    }
 Assert(hashed_strings_count < MAX_HASHED_STRINGS);
 Assert(next_string_data + length + 1 < string_data + MAX_STRING_DATA);
 char *interned_string = next_string_data;
 memcpy(interned_string, string, length);
    interned_string[length] = 0;
    next_string_data += length + 1;
    hashed_strings[hashed_strings_count].hash = hash;
    hashed_strings[hashed_strings_count].string = interned_string;
    hashed_strings_count++;
 return interned_string;
}


// Symbol tables


enum TypeKind {
    TYPE_UINT64,
    TYPE_INT64,
    TYPE_UINT32,
    TYPE_INT32,
    TYPE_UINT8,
    TYPE_INT8,
    TYPE_ARRAY,
    TYPE_AGGREGATE
};


struct Type;


struct Field {
    Type *type;
 uint32_t offset;
};


struct Type {
    TypeKind kind;
 uint32_t size;
 union {
 struct {
            Type *element;
 size_t length;
        } array;
 struct {
            Field *fields;
 size_t length;
        } aggregate;
    };
};


Type type_uint64 = {TYPE_UINT64, sizeof(uint64_t)};


enum SymbolKind {
    SYMBOL_GLOBAL_VARIABLE,
    SYMBOL_LOCAL_VARIABLE
};


struct Symbol {
    SymbolKind kind;
 char *name;
    Type *type;
 uint32_t offset;
};


enum {
    MAX_GLOBAL_VARIABLES = 1024,
    MAX_LOCAL_VARIABLES = 1024
};


Symbol global_variables[MAX_GLOBAL_VARIABLES];
size_t global_variables_count;
uint32_t global_variables_offset;


Symbol *PushGlobalVariable(char *name, Type *type) {
 Assert(global_variables_count < MAX_GLOBAL_VARIABLES);
    Symbol *global_variable = global_variables + global_variables_count;
    global_variable->kind = SYMBOL_GLOBAL_VARIABLE;
    global_variable->name = name;
    global_variable->type = type;
    global_variable->offset = global_variables_offset;
    global_variables_offset += type->size;
    global_variables_count++;
 return global_variable;
}


Symbol local_variables[MAX_LOCAL_VARIABLES];
size_t local_variables_count;
uint32_t local_variables_offset;


Symbol *PushLocalVariable(char *name, Type *type) {
 Assert(local_variables_count < MAX_LOCAL_VARIABLES);
    Symbol *local_variable = local_variables + local_variables_count;
    local_variable->kind = SYMBOL_LOCAL_VARIABLE;
    local_variable->name = name;
    local_variable->type = type;
    local_variable->offset = local_variables_offset;
    local_variables_offset += type->size;
    local_variables_count++;
 return local_variable;
}


void PopLocalVariables(size_t new_count) {
 Assert(new_count >= 0);
 Assert(new_count <= local_variables_count);
 if (new_count < local_variables_count) {
        local_variables_offset = local_variables[new_count].offset;
    }
    local_variables_count = new_count;
}


Symbol *FindSymbol(char *name) {
 for (int64_t i = local_variables_count - 1; i >= 0; i--) {
 if (local_variables[i].name == name) {
 return local_variables + i;
        }
    }
 for (int64_t i = global_variables_count; i >= 0; i--) {
 if (global_variables[i].name == name) {
 return global_variables + i;
        }
    }
 return 0;
}


// Reader


char *string_if;
char *string_else;
char *string_while;
char *string_uint64;


char current_character;
char *remaining_characters;


void ReadCharacter() {
 Assert(current_character);
    current_character = *remaining_characters;
    remaining_characters++;
}


enum {
    TOKEN_EOF = 0,
    LAST_LITERAL_TOKEN = 127,
    TOKEN_INTEGER,
    TOKEN_IDENTIFIER,
    TOKEN_PRINT,
    TOKEN_IF,
    TOKEN_ELSE,
    TOKEN_WHILE
};


typedef uint8_t Token;


Token current_token;
uint32_t current_token_integer;
char *current_token_identifier;


void ConsumeToken() {
retry:
 switch (current_character) {
 case 0:
            current_token = TOKEN_EOF;
 break;
 case ' ':
 case '\n':
 case '\r':
 case '\t':
 case '\v':
 ReadCharacter();
 goto retry;
 break;
 case 'a':
 case 'A':
 case 'b':
 case 'B':
 case 'c':
 case 'C':
 case 'd':
 case 'D':
 case 'e':
 case 'E':
 case 'f':
 case 'F':
 case 'g':
 case 'G':
 case 'h':
 case 'H':
 case 'i':
 case 'I':
 case 'j':
 case 'J':
 case 'k':
 case 'K':
 case 'l':
 case 'L':
 case 'm':
 case 'M':
 case 'n':
 case 'N':
 case 'o':
 case 'O':
 case 'p':
 case 'P':
 case 'q':
 case 'Q':
 case 'r':
 case 'R':
 case 's':
 case 'S':
 case 't':
 case 'T':
 case 'u':
 case 'U':
 case 'v':
 case 'V':
 case 'w':
 case 'W':
 case 'x':
 case 'X':
 case 'y':
 case 'Y':
 case 'z':
 case 'Z': {
 char *start = remaining_characters - 1;
 ReadCharacter();
 while (isalnum(current_character) || current_character == '_') {
 ReadCharacter();
            }
 char *end = remaining_characters - 1;
 char *string = InternString(start, end - start);
 if (string == string_if) {
                current_token = TOKEN_IF;
            } else if (string == string_else) {
                current_token = TOKEN_ELSE;
            } else if (string == string_while) {
                current_token = TOKEN_WHILE;
            } else {
                current_token = TOKEN_IDENTIFIER;
                current_token_identifier = string;
            }
 break;
        }
 case '=':
 case ';':
 case ':':
 case '{':
 case '}':
 case '(':
 case ')':
 case '+':
 case '-':
 case '*':
 case '/':
 case '^':
            current_token = (Token)current_character;
 ReadCharacter();
 break;
 case '0':
 case '1':
 case '2':
 case '3':
 case '4':
 case '5':
 case '6':
 case '7':
 case '8':
 case '9':
            current_token = TOKEN_INTEGER;
            current_token_integer = current_character - '0';
 ReadCharacter();
 while (isdigit(current_character)) {
                current_token_integer *= 10;
                current_token_integer += current_character - '0';
 ReadCharacter();
            }
 break;
 default:
 Assert(0);
    }
}


void ExpectToken(Token expected_token) {
 Assert(current_token == expected_token);
 ConsumeToken();
}


uint32_t free_register_mask;


void InitializeFreeRegisters() {
    Register available_registers[] = {RCX, RBX, RSI, RDI, R8, R9, R10, R11, R12, R13, R14, R15};
 for (size_t i = 0; i < sizeof(available_registers) / sizeof(*available_registers); i++) {
        free_register_mask |= 1 << available_registers[i];
    }
}


Register AllocateRegister() {
 Assert(free_register_mask != 0);
    DWORD free_register;
 _BitScanForward(&free_register,free_register_mask);
    free_register_mask &= ~(1 << free_register);
 return (Register)free_register;
}


void FreeRegister(Register allocated_register) {
 Assert((free_register_mask & (1 << allocated_register)) == 0);
    free_register_mask |= 1 << allocated_register;
}


enum OperandKind {
    OPERAND_NULL,
    OPERAND_FRAME_OFFSET,
    OPERAND_REGISTER,
    OPERAND_IMMEDIATE,
    OPERAND_ADDRESS
};


struct Operand {
    OperandKind kind;
    Type *type;
 union {
        Register operand_register;
 uint32_t operand_immediate;
 uint32_t operand_frame_offset;
 uint32_t operand_address;
    };
};


void AllocateOperandRegister(Operand *operand) {
 if (operand->kind != OPERAND_REGISTER) {
        operand->kind = OPERAND_REGISTER;
        operand->operand_register = AllocateRegister();
    }
}


void StealOperandRegister(Operand *destination, Operand *source) {
 Assert(source->kind == OPERAND_REGISTER);
    destination->kind = OPERAND_REGISTER;
    destination->operand_register = source->operand_register;
    source->kind = OPERAND_NULL;
}


void FreeOperand(Operand *operand) {
 if (operand->kind == OPERAND_REGISTER) {
 FreeRegister(operand->operand_register);
    }
    operand->kind = OPERAND_NULL;
}


void PatchWithOperandAddress(uint32_t offset, Operand *operand) {
 Assert(operand->kind == OPERAND_ADDRESS);
    *(int32_t *)(next_code - 4 * offset) = (int32_t)(code - next_code - 8) - (uint32_t)operand->operand_address;
}


void EmitOperandToRegister(Operand *operand, Register target_register) {
 if (operand->kind == OPERAND_IMMEDIATE) {
 EMIT_R_I(MOVSX, target_register, operand->operand_immediate);
    } else if (operand->kind == OPERAND_FRAME_OFFSET) {
 Assert(operand->operand_frame_offset <= INT8_MAX);
 EMIT_R_MD1(MOV, target_register, RBP, operand->operand_frame_offset);
    } else if (operand->kind == OPERAND_ADDRESS) {
 EMIT_R_RIPD(MOV, target_register, 0);
 PatchWithOperandAddress(1, operand);
    } else if (operand->kind == OPERAND_REGISTER) {
 if (operand->operand_register != target_register) {
 EMIT_R_R(MOV, target_register, operand->operand_register);
        }
    }
}


void EnsureOperandHasRegister(Operand *operand) {
 if (operand->kind != OPERAND_REGISTER) {
        Register operand_register = AllocateRegister();
 EmitOperandToRegister(operand, operand_register);
        operand->kind = OPERAND_REGISTER;
        operand->operand_register = operand_register;
    }
}


void ParseExpression(Operand *destination);


void ParseAtom(Operand *destination) {
 if (current_token == TOKEN_IDENTIFIER) {
        Symbol *symbol = FindSymbol(current_token_identifier);
 Assert(symbol);
 ConsumeToken();
 if (symbol->kind == SYMBOL_LOCAL_VARIABLE) {
            destination->kind = OPERAND_FRAME_OFFSET;
            destination->operand_frame_offset = symbol->offset;
        } else {
            destination->kind = OPERAND_ADDRESS;
            destination->operand_address = symbol->offset;
        }
    } else if (current_token == TOKEN_INTEGER) {
 ConsumeToken();
        destination->kind = OPERAND_IMMEDIATE;
        destination->operand_immediate = current_token_integer;
    } else if (current_token == '(') {
 ConsumeToken();
 ParseExpression(destination);
 ExpectToken(')');
    } else {
 Assert(0);
    }
}


void EmitMultiply(Operand *destination, Operand *operand) {
 if (destination->kind == OPERAND_IMMEDIATE && operand->kind == OPERAND_IMMEDIATE) {
        destination->operand_immediate *= operand->operand_immediate;
    } else if (operand->kind == OPERAND_IMMEDIATE && IsPowerOfTwo(operand->operand_immediate)) {
 EnsureOperandHasRegister(destination);
 EMIT_R_I1(SHL, destination->operand_register, Log2(operand->operand_immediate));
    } else if (destination->kind == OPERAND_IMMEDIATE && IsPowerOfTwo(destination->operand_immediate)) {
 EnsureOperandHasRegister(operand);
 EMIT_R_I1(SHL, operand->operand_register, Log2(destination->operand_immediate));
 StealOperandRegister(destination, operand);
    } else {
 EmitOperandToRegister(destination, RAX);
 if (operand->kind == OPERAND_FRAME_OFFSET) {
 Assert(operand->operand_frame_offset <= INT8_MAX);
 EMIT_X_MD1(MUL, RBP, operand->operand_frame_offset);
        } else if (operand->kind == OPERAND_ADDRESS) {
 EMIT_X_RIPD(MUL, 0);
 PatchWithOperandAddress(1, operand);
        } else {
 EnsureOperandHasRegister(operand);
 EMIT_X_R(MUL, operand->operand_register);
        }
 AllocateOperandRegister(destination);
 EMIT_R_R(MOV, destination->operand_register, RAX);
    }
}


void EmitDivide(Operand *destination, Operand *operand) {
 if (destination->kind == OPERAND_IMMEDIATE && operand->kind == OPERAND_IMMEDIATE) {
        destination->operand_immediate /= operand->operand_immediate;
    } else if (operand->kind == OPERAND_IMMEDIATE && IsPowerOfTwo(operand->operand_immediate)) {
 EnsureOperandHasRegister(destination);
 EMIT_R_I1(SHR, destination->operand_register, Log2(operand->operand_immediate));
    } else {
 EmitOperandToRegister(destination, RAX);
 if (operand->kind == OPERAND_FRAME_OFFSET) {
 Assert(operand->operand_frame_offset <= INT8_MAX);
 EMIT_X_MD1(DIV, RBP, operand->operand_frame_offset);
        } else if (operand->kind == OPERAND_ADDRESS) {
 EMIT_X_RIPD(DIV, 0);
 PatchWithOperandAddress(1, operand);
        } else {
 EnsureOperandHasRegister(operand);
 EMIT_X_R(DIV, operand->operand_register);
        }
 AllocateOperandRegister(destination);
 EMIT_R_R(MOV, destination->operand_register, RAX);
    }
}


void ParseTerm(Operand *destination) {
 ParseAtom(destination);
 while (current_token == '*' || current_token == '/') {
        Token operator_token = current_token;
 ConsumeToken();
        Operand operand;
 ParseTerm(&operand);
 if (operator_token == '*') {
 EmitMultiply(destination, &operand);
        } else {
 EmitDivide(destination, &operand);
        }
 FreeOperand(&operand);
    }
}


void EmitAdd(Operand *destination, Operand *operand) {
 if (destination->kind == OPERAND_IMMEDIATE && operand->kind == OPERAND_IMMEDIATE) {
        destination->operand_immediate += operand->operand_immediate;
    } else if (destination->kind == OPERAND_IMMEDIATE) {
 EnsureOperandHasRegister(operand);
 EMIT_R_I(ADD, operand->operand_register, destination->operand_immediate);
        destination->kind = OPERAND_REGISTER;
        destination->operand_register = operand->operand_register;
    } else {
 EnsureOperandHasRegister(destination);
 if (operand->kind == OPERAND_IMMEDIATE) {
 EMIT_R_I(ADD, destination->operand_register, operand->operand_immediate);
        } else if (operand->kind == OPERAND_FRAME_OFFSET) {
 Assert(operand->operand_frame_offset <= INT8_MAX);
 EMIT_R_MD1(ADD, destination->operand_register, RBP, operand->operand_frame_offset);
        } else if (operand->kind == OPERAND_ADDRESS) {
 EMIT_R_RIPD(ADD, destination->operand_register, 0);
 PatchWithOperandAddress(1, operand);
        } else {
 Assert(operand->kind == OPERAND_REGISTER);
 EMIT_R_R(ADD, destination->operand_register, operand->operand_register);
        }
    }
}


void EmitSubtract(Operand *destination, Operand *operand) {
 if (destination->kind == OPERAND_IMMEDIATE && operand->kind == OPERAND_IMMEDIATE) {
        destination->operand_immediate -= operand->operand_immediate;
    } else if (destination->kind == OPERAND_IMMEDIATE) {
 EnsureOperandHasRegister(operand);
 EMIT_R_I(ADD, operand->operand_register, -destination->operand_immediate);
        destination->kind = OPERAND_REGISTER;
        destination->operand_register = operand->operand_register;
    } else {
 EnsureOperandHasRegister(destination);
 if (operand->kind == OPERAND_IMMEDIATE) {
 EMIT_R_I(SUB, destination->operand_register, operand->operand_immediate);
        } else if (operand->kind == OPERAND_FRAME_OFFSET) {
 Assert(operand->operand_frame_offset <= INT8_MAX);
 EMIT_R_MD1(SUB, destination->operand_register, RBP, operand->operand_frame_offset);
        } else if (operand->kind == OPERAND_ADDRESS) {
 EMIT_R_RIPD(SUB, destination->operand_register, 0);
 PatchWithOperandAddress(1, operand);
        } else {
 Assert(operand->kind == OPERAND_REGISTER);
 EMIT_R_R(SUB, destination->operand_register, operand->operand_register);
        }
    }
}


void ParseExpression(Operand *destination) {
 ParseTerm(destination);
 while (current_token == '+' || current_token == '-') {
        Token operator_token = current_token;
 ConsumeToken();
        Operand operand;
 ParseTerm(&operand);
 if (operator_token == '+') {
 EmitAdd(destination, &operand);
        } else {
 EmitSubtract(destination, &operand);
        }
 FreeOperand(&operand);
    }
}


Type *ParseType() {
 if (current_token == TOKEN_IDENTIFIER) {
 if (current_token_identifier == string_uint64) {
 ConsumeToken();
 return &type_uint64;
        }
    }
 return 0;
}


void ParseStatementBlock();


void ParseStatement() {
 if (current_token == TOKEN_PRINT) {
 ConsumeToken();
        Operand operand;
 ParseExpression(&operand);
 // printf(""%d"", rcx)
 // rcx = [""%d""], rdx = operand result
 FreeOperand(&operand);
 ExpectToken(';');
    } else if (current_token == TOKEN_IF) {
 ConsumeToken();
 ExpectToken('(');
        Operand operand;
 ParseExpression(&operand);
 ExpectToken(')');
 EnsureOperandHasRegister(&operand);
 EMIT_R_I(CMP, operand.operand_register, 0);
 EMIT_C_I(J, Z, 0);
 uint8_t *end_of_if_jump = next_code;
 uint8_t *if_jump_immediate_address = next_code - 4;
 FreeOperand(&operand);
 ParseStatementBlock();
 if (current_token == TOKEN_ELSE) {
 ConsumeToken();
 EMIT_I(JMP, 0);
            *(uint32_t *)if_jump_immediate_address = (uint32_t)(next_code - end_of_if_jump);
 uint8_t *end_of_else_jump = next_code;
 uint8_t *else_jump_immediate_address = next_code - 4;
 ParseStatementBlock();
            *(uint32_t *)else_jump_immediate_address = (uint32_t)(next_code - end_of_else_jump);
        } else {
            *(uint32_t *)if_jump_immediate_address = (uint32_t)(next_code - end_of_if_jump);
        }
    } else if (current_token == TOKEN_WHILE) {
 ConsumeToken();
 uint8_t *start_of_while = next_code;
 ExpectToken('(');
        Operand operand;
 ParseExpression(&operand);
 ExpectToken(')');
 EnsureOperandHasRegister(&operand);
 EMIT_R_I(CMP, operand.operand_register, 0);
 EMIT_C_I(J, Z, 0);
 uint8_t *end_of_while_jump = next_code;
 uint8_t *while_jump_immediate_address = next_code - 4;
 FreeOperand(&operand);
 ParseStatementBlock();
 EMIT_I(JMP, 0);
        *(uint32_t *)(next_code - 4) = (int32_t)(start_of_while - next_code);
        *(uint32_t *)while_jump_immediate_address = (uint32_t)(next_code - end_of_while_jump);
    }  else if (current_token == TOKEN_IDENTIFIER) {
 char *identifier = current_token_identifier;
 ConsumeToken();
 if (current_token == '=') {
 ConsumeToken();
            Symbol *symbol = FindSymbol(identifier);
 Assert(symbol);
 if (symbol->kind == SYMBOL_LOCAL_VARIABLE) {
 uint32_t local_variable_offset = symbol->offset;
                Operand operand;
 ParseExpression(&operand);
 if (operand.kind == OPERAND_IMMEDIATE) {
 EMIT_MD1_I(MOVSX, RBP, local_variable_offset, operand.operand_immediate);
                } else {
 EnsureOperandHasRegister(&operand);
 EMIT_MD1_R(MOV, RBP, local_variable_offset, operand.operand_register);
                }
 FreeOperand(&operand);
            } else {
 Assert(symbol->kind == SYMBOL_GLOBAL_VARIABLE);
                Operand variable;
                variable.kind = OPERAND_ADDRESS;
                variable.operand_address = symbol->offset;
                Operand operand;
 ParseExpression(&operand);
 if (operand.kind == OPERAND_IMMEDIATE) {
 EMIT_RIPD_I(MOVSX, 0, operand.operand_immediate);
 PatchWithOperandAddress(2, &variable);
                } else {
 EnsureOperandHasRegister(&operand);
 EMIT_RIPD_R(MOV, 0, operand.operand_register);
 PatchWithOperandAddress(1, &variable);
                }
 FreeOperand(&operand);
            }
        } else {
 ExpectToken(':');
            Type *type = ParseType();
 PushLocalVariable(identifier, type);
        }
 ExpectToken(';');
    } else {
 Assert(0);
    }
}


void ParseStatementBlock() {
 uint64_t initial_local_variables_count = local_variables_count;
 ExpectToken('{');
 while (current_token != '}') {
 ParseStatement();
    }
 ConsumeToken();
 PopLocalVariables(initial_local_variables_count);
}


void ParseModule() {
 while (current_token != '{') {
 ExpectToken(TOKEN_IDENTIFIER);
 char *identifier = current_token_identifier;
 ExpectToken(':');
        Type *type = ParseType();
 PushGlobalVariable(identifier, type);
 ExpectToken(';');
    }
 EMIT_MOV64_R_I(RBP, (uint64_t)data);
 ParseStatementBlock();
}


void OpenFileForParsing(const char *filename) {
    HANDLE file = CreateFileA(filename, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
 Assert(file != INVALID_HANDLE_VALUE);
    DWORD file_size = GetFileSize(file, 0);
    HANDLE file_mapping = CreateFileMappingA(file, 0, PAGE_WRITECOPY, 0, 0, 0);
 Assert(file_mapping);
 char *file_memory = (char *)MapViewOfFileEx(file_mapping, FILE_MAP_COPY, 0, 0, 0, 0);
 Assert(file_memory);
 Assert(file_size > 0);
 Assert(file_memory[file_size - 1] == '\n');
    file_memory[file_size - 1] = 0;
    current_character = *file_memory;
    remaining_characters = file_memory + 1;
 ConsumeToken();
}


void InitializeCompiler() {
    data = (uint8_t *)VirtualAlloc(0, 1024 * 1024 * 1024, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
    code = data + 4096;
    next_code = code;
 InitializeFreeRegisters();
    string_if = InternString(""if"", 2);
    string_else = InternString(""else"", 4);
    string_while = InternString(""while"", 5);
    string_uint64 = InternString(""uint64"", 6);
}


void CompileFile(char *source_filename, char *binary_filename) {
    LARGE_INTEGER timer_frequency;
 QueryPerformanceFrequency(&timer_frequency);
    LARGE_INTEGER start_time;
 QueryPerformanceCounter(&start_time);
 OpenFileForParsing(source_filename);
 ParseModule();
    LARGE_INTEGER end_time;
 QueryPerformanceCounter(&end_time);
 uint64_t duration = end_time.QuadPart - start_time.QuadPart;
 char temp[32];
 sprintf(temp, ""Time: %.2fs\n"", (float)duration / (float)timer_frequency.QuadPart);
 OutputDebugStringA(temp);
 DumpCode(binary_filename);
}


int main(int argc, char **argv) {
 InitializeCompiler();


 // CompileFile(""d:\\be\\fib.be"", ""d:\\be\\fib.bin"");
 CompileFile(""d:\\be\\huge_fib.be"", ""d:\\be\\huge_fib.bin"");
 // CompileFile(""d:\\be\\test.be"", ""d:\\be\\test.bin"");
 // CompileFile(""d:\\be\\huge.be"", ""d:\\be\\huge.bin"");


    #if 0
    void (*dummy_function)() = (void(*)())code;
    dummy_function();
    #endif
 return 0;
}"
BuildSceneProcessor.cs,"using UnityEngine;
using UnityEditor;
using System.Collections;
using System.Collections.Generic;


// docs: https://docs.unity3d.com/ScriptReference/AssetModificationProcessor.OnWillSaveAssets.html
public class BuildSceneProcessor : UnityEditor.AssetModificationProcessor
{
 private const string DIALOG_TITLE = ""Add to Build Settings?"";
 private const string DIALOG_MSG = ""Add to build settings for inclusion in future builds?"";
 private const string DIALOG_OK = ""Yes"";
 private const string DIALOG_NO = ""Not now"";


 private static List<string> ignorePaths = new List<string>();


 public static void OnWillCreateAsset(string path)
 {
 if (path.EndsWith("".unity.meta""))
 path = path.Substring(0, path.Length - 5);


        ProcessAssetsForScenes(new string[] { path });
 }


 public static string[] OnWillSaveAssets(string[] paths)
 {
 return ProcessAssetsForScenes(paths);
 }


 private static string[] ProcessAssetsForScenes(string[] paths)
 {
 string scenePath = string.Empty;


 foreach (string path in paths)
 {
 if (path.Contains("".unity""))
 scenePath = path;
 }


 // NOTE: add more logic here if you want to filter for certain paths.
 if (!string.IsNullOrEmpty(scenePath) && !ignorePaths.Contains(scenePath))
            AddSceneToBuildSettings(scenePath);


 // unity only saves the paths that you return here, so we always pass through everything we received.
 return paths;
 }


 private static void AddSceneToBuildSettings(string scenePath)
 {
 List<EditorBuildSettingsScene> scenes = new List<EditorBuildSettingsScene>(EditorBuildSettings.scenes);


 // only bother adding scenes we don't have already.
 foreach (EditorBuildSettingsScene scene in scenes)
 {
 if (scene.path == scenePath)
 return;
 }


 if (EditorUtility.DisplayDialog(DIALOG_TITLE, DIALOG_MSG, DIALOG_OK, DIALOG_NO))
 {
 EditorBuildSettingsScene newScene = new EditorBuildSettingsScene();
            newScene.path = scenePath;
            newScene.enabled = true;


            scenes.Add(newScene);
            EditorBuildSettings.scenes = scenes.ToArray();
 }
 else
 {
            ignorePaths.Add(scenePath);
 }
 }
}"
highlight.js,"import {Pos} from ""../src/model""


function rangeFromTransform(tr) {
 let from, to
 for (let i = 0; i < tr.steps.length; i++) {
 let step = tr.steps[i], map = tr.maps[i]
 let stepFrom = map.map(step.from || step.pos, -1).pos
 let stepTo = map.map(step.to || step.pos, 1).pos
 from = from ? map.map(from, -1).pos.min(stepFrom) : stepFrom
 to = to ? map.map(to, 1).pos.max(stepTo) : stepTo
 }
 return {from, to}
}


function findOffset(marks, pos) {
 // FIXME could use a binary search
 for (let i = 0; i < marks.length; i++)
 if (marks[i].from.cmp(pos) >= 0) return i
 return marks.length
}


export function highlightWord(pm, word) {
 let marks = []
 function markTextblock(node, path, dest) {
 node.forEach((child, start, end) => {
 // FIXME doesn't detect the word when it spans a mark boundary
 if (child.isText) for (let pos = child.text.indexOf(word); pos != -1; pos = child.text.indexOf(word, pos + word.length)) {
 let from = new Pos(path.slice(), start + pos)
 dest.push(pm.markRange(from, from.move(word.length), {className: ""found""}))
 }
 })
 }


 pm.doc.nodesBetween(null, null, (node, path) => {
 if (node.isTextblock) {
 markTextblock(node, path, marks)
 return false
 }
 })


 pm.on(""transform"", tr => {
 let {from, to} = rangeFromTransform(tr)
 from = new Pos(from.path, 0); to = new Pos(to.path, tr.doc.path(to.path).size)


 marks = marks.filter(m => m.from)
 let start = findOffset(marks, from), end = findOffset(marks, to)
 for (let i = start; i < end; i++) pm.removeRange(marks[i])
 let newMarks = marks.slice(0, start)
 
 pm.doc.nodesBetween(from, to, (node, path) => {
 if (node.isTextblock) {
 // FIXME clear old marks
 markTextblock(node, path, newMarks)
 return false
 }
 })
 marks = newMarks.concat(marks.slice(end))
 })
}"
export_mastodon_followers.py,"###############################################################################
# A tool for exporting Mastodon followers
# Author: Zero
# Last update: 2022-02-09
###############################################################################
# Usage
#
# 1. Save this code as `export_mastodon_followers.py` in your computer.
#
# 2. Edit it, note that there are three places need to be changed:
#
#   a. <your_access_token_here> (line 32)
#           You can get your access token by: Settings -> Development ->
#       NEW APPLICATION -> fill in an application name -> SUBMIT -> click your
#       application name -> you will see your access token.
#
#   b. <mastodon.example> (line 33)
#           Replace it with the domain address of the instance you are using.
#
#   c. <:id> (line 33)
#           When you click one's avatar on Mastodon web UI, you can see the url
#       is in this format: `https://<mastodon.example>/web/accounts/<:id>`, the
#       last string of numbers is <:id>.
#
# 3. Execute this python file, and deal with the output as you like. For example,
#       in Linux, you can `python export_mastodon_followers.py > followers_list`.
###############################################################################


import requests
import re


headers = {'Authorization': 'Bearer <your_access_token_here>'}
url = 'https://<mastodon.example>/api/v1/accounts/<:id>/followers'


i = 1


while 1:
 fl = requests.get(url, headers = headers)
 fj = fl.json()
 for e in fj:
 acct = e[""acct""]
 print(str(i) + '    ' + acct)
 i = i + 1
 if (not 'Link' in fl.headers) or (not 'rel=""next""' in fl.headers['Link']):
 break
 else:
 next_url = re.match(r""\<(.*?)\>"", fl.headers['Link']).groups()[0]
 url = next_url
 "
next.config.js,"const path = require('path')
const loaderUtils = require('loader-utils')


const hashOnlyIdent = (context, _, exportName) => {
 const result = loaderUtils
 .getHashDigest(
 Buffer.from(
 `filePath:${path
 .relative(context.rootContext, context.resourcePath)
 .replace(/\\+/g, '/')}#className:${exportName}`
 ),
 'md4',
 'base64',
 6
 )
 .replace(/^(-?\d|--)/, '_$1')
 .replaceAll('+', '_')
 .replaceAll('/', '_')


 return result
}


/** @type {import('next').NextConfig} */
const nextConfig = {
 reactStrictMode: true,
 sassOptions: {
 includePaths: [path.join(__dirname, 'styles')],
 },
 webpack: (config, { buildId, dev, isServer, defaultLoaders, webpack }) => {
 const rules = config.module.rules
 .find((rule) => typeof rule.oneOf === 'object')
 .oneOf.filter((rule) => Array.isArray(rule.use))


 if (!dev)
 rules.forEach((rule) => {
 rule.use.forEach((moduleLoader) => {
 if (
 moduleLoader.loader?.includes('css-loader') &&
 !moduleLoader.loader?.includes('postcss-loader')
 )
 moduleLoader.options.modules.getLocalIdent = hashOnlyIdent
 })
 })


 return config
 },
}


module.exports = nextConfig"
prompt-for-password.js,"/**
 * This is an example of app that uses an ecrypted NeDB database. It prompts the
 * user for a password, decrypts the database, displays any existing records,
 * promtps the user for a new record to store, encrypts that record, then exits.
 * The password must be given each time the app is started.
 */


const crypto = require('crypto')
const inquirer = require('inquirer')
const scrypt = require('scryptsy')
const nedb = require('nedb-promises')


// A salt is required for scrypt to derive an encryption key from a password. A
// salt is a random value used to mitigate rainbow tables. It does not need to
// be kept secret, but it needs to be consitent as only the same password and
// salt combination will result in the same key. In this example, the same salt
// is used for all instances of this app, which means that the encrypted
// database is portable. But this also makes this app more susceptible to
// rainbow tables.
const dbSalt = Buffer.from('GagZgR/G2isc0IbKKYyFLg==')


// Alternatively, you can generate a salt on the first run of the app and store
// it somewhere. This will make the app more resilient to rainbow tables, but
// the encrypted database will no longer be portable.


// This is the main function. It will be called at the end of the file.
async function run() {
 // Propmpt the user for the database encryption password. This, along with the
 // salt, will be used by scrypt to generate an encryption key for the database.
 // The same password must be used each time the app runs. If the password is
 // lost or forgotten, then the database cannot be decrypted or recovered.
 const {dbPass} = await inquirer.prompt([
 {
 name: 'dbPass',
 type: 'password',
 message: 'Database password:',
 },
 ])


 // scrypt uses the password, salt, and other parameters to derive the
 // encryption key. The other parameters determine how much time it takes the
 // CPU to derive the key, which mitigates brute force attacks, except for the
 // last parameter which specifies the length of the key in bytes. A change to
 // any of these parameters will result in a different key.
 const key = scrypt(dbPass, dbSalt, 32768, 8, 1, 32)


 // We're using nedb-promises so that we can await the database operations, but
 // regular nedb works too.
 const db = nedb.create({
 filename: 'example.db',


 // This is the encryption function. It takes plaintext, which is JSON,
 // encrypts it with the derived key, and returns the encrypted ciphertext as
 // a Base 64 string. A random IV is generated and stored for each record to
 // mitigate padding attacks. Note that you don't need to return JSON; any
 // string will do.
 afterSerialization(plaintext) {
 const iv = crypto.randomBytes(16)
 const aes = crypto.createCipheriv('aes-256-cbc', key, iv)
 let ciphertext = aes.update(plaintext)
 ciphertext = Buffer.concat([iv, ciphertext, aes.final()])
 return ciphertext.toString('base64')
 },


 // This is the decryption function. It takes the encrypted ciphertext,
 // decrypts it with the stored IV and derived key, and returns the decrypted
 // plaintext, which is JSON. Note that this function must return JSON, since
 // that is what NeDB expects.
 beforeDeserialization(ciphertext) {
 const ciphertextBytes = Buffer.from(ciphertext, 'base64')
 const iv = ciphertextBytes.slice(0, 16)
 const data = ciphertextBytes.slice(16)
 const aes = crypto.createDecipheriv('aes-256-cbc', key, iv)
 let plaintextBytes = Buffer.from(aes.update(data))
 plaintextBytes = Buffer.concat([plaintextBytes, aes.final()])
 return plaintextBytes.toString()
 },
 })


 // In the event that the wrong password is entered, when NeDB tries to decrypt
 // the records, it will be given garbage (i.e. not JSON) so it will return an
 // error indicating the the database is corrupt.


 // Display the currently stored values, if any, which were decrypted from the
 // database file.
 console.log('Current values stored in database: ')
 const rows = await db.find()
 for (const row of rows) {
 console.log(`${row.date}: ${row.value}`)
 }


 // Prompt for a new value to store, which is stored along with a timestamp.
 console.log('Store a new value in the database.')
 const {value} = await inquirer.prompt([
 {
 name: 'value',
 type: 'input',
 message: 'Value:',
 },
 ])


 await db.insert({value, date: new Date()})


 console.log('Value stored. Restart the app to see the values.')
}


// Run the async main function. If there are any errors, report them and close
// the process with an exit code.
run().catch(err => {
 console.error(err)
 process.exitCode = err.code || 1
})
/**
 * This is an example of app that uses an ecrypted NeDB database. It prompts the
 * user for a password, decrypts the database, displays any existing records,
 * promtps the user for a new record to store, encrypts that record, then exits.
 * The password must be given each time the app is started.
 */


const crypto = require('crypto')
const keytar = require('keytar')
const inquirer = require('inquirer')
const scrypt = require('scryptsy')
const nedb = require('nedb-promises')


// A salt is required for scrypt to derive an encryption key from a password. A
// salt is a random value used to mitigate rainbow tables. It does not need to
// be kept secret, but it needs to be consitent as only the same password and
// salt combination will result in the same key. In this example, the same salt
// is used for all instances of this app, which means that the encrypted
// database is portable. But this also makes this app more susceptible to
// rainbow tables.
const dbSalt = Buffer.from('GagZgR/G2isc0IbKKYyFLg==')


// Alternatively, you can generate a salt on the first run of the app and store
// it somewhere. This will make the app more resilient to rainbow tables, but
// the encrypted database will no longer be portable.


// This is the main function. It will be called at the end of the file.
async function run() {
 // Retrieve the database encryption password from the system keychain. If no
 // password exists in the keychain, prompt the user for one, then store it in
 // the keychain. This, along with the salt, will be used by scrypt to generate
 // an encryption key for the database. The same password must be used each
 // time the app runs. If the password is lost or forgotten, then the database
 // cannot be decrypted or recovered.
 let dbPass = await keytar.getPassword('nedb-example', 'dbPass')
 if (dbPass == null) {
 const {userDBPass} = await inquirer.prompt([
 {
 name: 'userDBPass',
 type: 'password',
 message: 'Database password:',
 },
 ])


 dbPass = userDBPass


 await keytar.setPassword('nedb-example', 'dbPass', dbPass)
 }


 // scrypt uses the password, salt, and other parameters to derive the
 // encryption key. The other parameters determine how much time it takes the
 // CPU to derive the key, which mitigates brute force attacks, except for the
 // last parameter which specifies the length of the key in bytes. A change to
 // any of these parameters will result in a different key.
 const key = scrypt(dbPass, dbSalt, 32768, 8, 1, 32)


 // We're using nedb-promises so that we can await the database operations, but
 // regular nedb works too.
 const db = nedb.create({
 filename: 'example.db',


 // This is the encryption function. It takes plaintext, which is JSON,
 // encrypts it with the derived key, and returns the encrypted ciphertext as
 // a Base 64 string. A random IV is generated and stored for each record to
 // mitigate padding attacks. Note that you don't need to return JSON; any
 // string will do.
 afterSerialization(plaintext) {
 const iv = crypto.randomBytes(16)
 const aes = crypto.createCipheriv('aes-256-cbc', key, iv)
 let ciphertext = aes.update(plaintext)
 ciphertext = Buffer.concat([iv, ciphertext, aes.final()])
 return ciphertext.toString('base64')
 },


 // This is the decryption function. It takes the encrypted ciphertext,
 // decrypts it with the stored IV and derived key, and returns the decrypted
 // plaintext, which is JSON. Note that this function must return JSON, since
 // that is what NeDB expects.
 beforeDeserialization(ciphertext) {
 const ciphertextBytes = Buffer.from(ciphertext, 'base64')
 const iv = ciphertextBytes.slice(0, 16)
 const data = ciphertextBytes.slice(16)
 const aes = crypto.createDecipheriv('aes-256-cbc', key, iv)
 let plaintextBytes = Buffer.from(aes.update(data))
 plaintextBytes = Buffer.concat([plaintextBytes, aes.final()])
 return plaintextBytes.toString()
 },
 })


 // In the event that the wrong password is entered, when NeDB tries to decrypt
 // the records, it will be given garbage (i.e. not JSON) so it will return an
 // error indicating the the database is corrupt.


 // Display the currently stored values, if any, which were decrypted from the
 // database file.
 console.log('Current values stored in database: ')
 const rows = await db.find()
 for (const row of rows) {
 console.log(`${row.date}: ${row.value}`)
 }


 // Prompt for a new value to store, which is stored along with a timestamp.
 console.log('Store a new value in the database.')
 const {value} = await inquirer.prompt([
 {
 name: 'value',
 type: 'input',
 message: 'Value:',
 },
 ])


 await db.insert({value, date: new Date()})


 console.log('Value stored. Restart the app to see the values.')
}


// Run the async main function. If there are any errors, report them and close
// the process with an exit code.
run().catch(err => {
 console.error(err)
 process.exitCode = err.code || 1
})"
renew_certificates.py,"from os import listdir, system
from os.path import join
from subprocess import run, PIPE
import logging
import re
from datetime import datetime, timedelta


logging.basicConfig(format='%(asctime)s - %(levelname)s - %(message)s', 
 level=logging.INFO,
 filename='/root/renew_certificates.log',
 filemode='w')


BASE_DIR = '/etc/letsencrypt/live'
CERT_FILE = 'fullchain.pem'
KEY_FILE = 'privkey.pem'
COMBINED_FILE = 'cert_key.pem'


DOMAINS = listdir(BASE_DIR)




def certificate_expires_soon(domain):
 try:
 logging.info('Testing certificate for domain ""%s""', domain)
 
 cmd = ['openssl', 'x509', '-in', join(BASE_DIR, domain, CERT_FILE), '-text', '-noout']
 openssl_out = run(cmd, stdout=PIPE, stderr=PIPE, universal_newlines=True)
 
 if openssl_out.returncode is not 0:
 logging.error(
 'Command ""%s"" failed with return code %d', ' '.join(cmd), openssl_out.returncode)
 logging.error('Captured stdout: %s', openssl_out.stdout)
 logging.error('Captured stderr: %s', openssl_out.stderr)
 sys.exit(1)
 
 valid_until, = re.match(
 r'.*Not After : (.*?)\n.*', openssl_out.stdout, flags=re.DOTALL).groups()
 valid_until = datetime.strptime(valid_until, '%b %d %H:%M:%S %Y %Z')
 time_left = valid_until - datetime.now()
 
 logging.info('Valid until: %s', valid_until)
 logging.info('Time left: %s', time_left)
 logging.info('Requires renewal: %s', time_left < timedelta(days=1))
 
 return time_left < timedelta(days=1)
 
 except:
 logging.exception('Testing certificate for domain ""%s"" failed!', domain)
 sys.exit(1)




if any(certificate_expires_soon(domain) for domain in DOMAINS):
 logging.info('At least one certificate is about to expire')
 
 # Renew certificate
 cmd = ['letsencrypt', 'renew', '--agree-tos']
 logging.info('Executing ""%s""', ' '.join(cmd))
 letsencrypt_out = run(cmd, universal_newlines=True)
 
 if letsencrypt_out.returncode is not 0:
 logging.error(
 'Command ""%s"" failed with return code %d', ' '.join(cmd), letsencrypt_out.returncode)
 sys.exit(1)


 for domain in DOMAINS:
 # Generate combined file for haproxy
 cmd = 'cat %s %s > %s' % (
 join(BASE_DIR, domain, CERT_FILE), 
 join(BASE_DIR, domain, KEY_FILE), 
 join(BASE_DIR, domain, COMBINED_FILE))
 logging.info('Executing ""%s""', cmd)
 returncode = system(cmd)
 
 if returncode is not 0:
 logging.error('Command ""%s"" failed with return code %d', cmd, returncode)
 sys.exit(1)


 # Restart haproxy
 cmd = ['service', 'haproxy', 'restart']
 logging.info('Executing ""%s""', ' '.join(cmd))
 service_out = run(cmd, universal_newlines=True)


 if service_out.returncode is not 0:
 logging.error(
 'Command ""%s"" failed with return code %d', ' '.join(cmd), service_out.returncode)
 sys.exit(1)
 
 logging.info('Success!')


else:
 logging.info('No certificate is about to expire')"
simple_names.py,"import re
import idaapi
import sark
import abc




class IDATracker(idaapi.UI_Hooks):
 __metaclass__ = abc.ABCMeta


 def __init__(self):
 super(IDATracker, self).__init__()


 def updating_actions(self, ctx=idaapi.action_update_ctx_t()):
 if ctx.form_type == idaapi.BWN_DISASM:
 self.on_ea(ctx.cur_ea, ctx)


 @abc.abstractmethod
 def on_ea(self, ea, ctx):
 return NotImplemented




def get_base_name(function):
 true_name = function.demangled
 match = re.search(r'([\w]+)\(', true_name)
 if not match:
 return
 return match.group(1)


def hint_function(ea):
 try:
 function = sark.Function(ea)
 except sark.exceptions.SarkNoFunction:
 return
 base_name = get_base_name(function)
 function.lines.next().comments.posterior = 'Base name: {}'.format(base_name)




class FunctionHinter(IDATracker):
 def __init__(self):
 super(FunctionHinter, self).__init__()


 self.current_ea = None


 def on_ea(self, ea, ctx):
 if sark.is_same_function(self.current_ea, ea):
 return


 hint_function(ea)
 self.current_ea = ea




hinter = FunctionHinter()
hinter.hook()"
PBEWITHMD5andDES_cipher.py,"from Crypto.Hash import MD5
from Crypto.Cipher import DES
import base64
import random
import sys




def randomBytes(n):
 return bytearray(random.getrandbits(8) for i in range(n))




def jdkPBE_cipher_PBEWITHMD5andDES(password, plaintext):
 bs = 8
 _iterations = 1000


 data = bytes(plaintext.encode())
 padding = bs - (len(data) % bs)
 data += bytes((chr(padding) * padding).encode())


 salt = randomBytes(bs)


 hasher = MD5.new()
 hasher.update(bytearray(password.encode()))
 hasher.update(salt)
 result = hasher.digest()


 for i in range(1, _iterations):
 hasher = MD5.new()
 hasher.update(result)
 result = hasher.digest()


 encoder = DES.new(result[:bs], DES.MODE_CBC, result[bs:bs*2])
 encrypted = encoder.encrypt(data)
 return salt+encrypted




def jdkPBE_decipher_PBEWITHMD5andDES(password, data_to_decrypt):
 bs = 8
 _iterations = 1000
 salt = data_to_decrypt[:bs]
 data = data_to_decrypt[bs:]


 hasher = MD5.new()
 hasher.update(bytearray(password.encode()))
 hasher.update(bytearray(salt))
 result = hasher.digest()


 for i in range(1, _iterations):
 hasher = MD5.new()
 hasher.update(result)
 result = hasher.digest()


 encoder = DES.new(result[:bs], DES.MODE_CBC, result[bs:bs*2])
 decrypted = encoder.decrypt(bytes(data))


 length = len(decrypted)
 unpadding = int(decrypted[length-1])


 if length - unpadding > 0:
 return decrypted[:(length - unpadding)].decode()
 else:
 return decrypted.decode()




def jdkPBE_decipher(ciphername, password, src):
 if ciphername == ""PBEWITHMD5andDES"":
 return jdkPBE_decipher_PBEWITHMD5andDES(password, base64.b64decode(src))
 else:
 raise Exception('unable to decode with {}'.format(ciphername))




def jdkPBE_cipher(ciphername, password, src):
 if ciphername == ""PBEWITHMD5andDES"":
 return base64.b64encode(
 jdkPBE_cipher_PBEWITHMD5andDES(password, src)).decode()
 else:
 raise Exception('unable to encode with {}'.format(ciphername))




if ""__main__"" == __name__:


 if len(sys.argv) == 2 and sys.argv[1] == 't':
 _password = 'strangepassword'
 _cypherdata = 'ZJCmwXlI2Uybx+GwocCD5GxmScwLHDWKM9IO7PXkX4' \
 '1lAhkN3wAWV/8q9jeV7K0dFKo4/NWphE37YiLga2RT' \
 'uWlWh5Jvxv6s'
 _plaintext_to_encrypt = 'João Alves was here'


 _encrypted = jdkPBE_cipher('PBEWITHMD5andDES',
 _password,
 _plaintext_to_encrypt)
 print('Encrypting [{}] with password [{}] '
 'using PBEWITHMD5andDES -> [{}]'
              .format(_plaintext_to_encrypt, _password, _encrypted))


 _encrypted2 = jdkPBE_cipher('PBEWITHMD5andDES',
 _password,
 _plaintext_to_encrypt)
 _decrypted2 = jdkPBE_decipher('PBEWITHMD5andDES',
 _password,
 _encrypted2)
 print('Encrypting and Decrypting the [{}] with password [{}] '
 'using PBEWITHMD5andDES -> [{}]'
              .format(_plaintext_to_encrypt, _password, _decrypted2))


 _decrypt_cypher = jdkPBE_decipher('PBEWITHMD5andDES',
 _password,
 _cypherdata)
 print('Decrypting [{}] with password [{}] '
 'using PBEWITHMD5andDES -> [{}]'
              .format(_cypherdata, _password, _decrypt_cypher))
 exit(0)


 if len(sys.argv) < 5:
 print('''Args: operation ciphername password msg
Ex. to encrypt: e PBEWITHMD5andDES simplepass ""Test""
Ex. to decrypt: d PBEWITHMD5andDES simplepass pkRuP5Q6b6ttjEdSF0IBbw==
        ''')
 exit(1)


 operation = sys.argv[1]
 ciphername = sys.argv[2]
 password = sys.argv[3]
 src = sys.argv[4]


 if operation == ""e"":
 msg = jdkPBE_cipher(ciphername, password, src)
 print(msg)
 if operation == ""d"":
 msg = jdkPBE_decipher(ciphername, password, src)
 print(msg)"
c-vtable.c,"#include <stdio.h>


/* class definitions */
typedef struct Base
{
 void (**vtable)();
 int _x;
} Base;


typedef struct Child
{
 void (**vtable)();
/* begin base class slice */
 int _x;
/* end base class slice */
 int _y;
} Child;


/* class method implementations */
void Base_ToString(Base const* obj) { printf(""Base: (%d)\n"", obj->_x); }
void Child_ToString(Child const* obj) { printf(""Base: (%d,%d)\n"", obj->_x, obj->_y); }


/* soley method pointer */
void (*fn_ptr)();


/* vtable implementation */
enum { Call_ToString };
void (*Base_Vtable[])() = { Base_ToString };
void (*Child_Vtable[])() = { [Call_ToString] = Child_ToString }; /* gcc designated inits */


/* virtual method implementation */
void ToString(Base const* obj)
{
 obj->vtable[Call_ToString](obj);
}


int main()
{
 /* pick the vtable for objects at compile time */
 Base base = {Base_Vtable, 123};
 Child child = {Child_Vtable, 456, 789};
 Child object = {NULL, 12, 14};
 Base* a = &base;
 Base* b = (Base*)&child;
 Base* c = (Base*)&object;
 
 /* call the virtual methods */
 ToString(a);
 ToString(b);
 
 fn_ptr = Child_ToString;
 fn_ptr(c);
 
 return 0;
}"
Disable Page Visibility API.user.js,"// ==UserScript==
// @name         Disable Page Visibility API
// @namespace    http://tampermonkey.net/
// @version      0.1
// @description  Disables JS events on whole page focus/unfocus. Usefull to prevent ads stop when switching to another tab.
// @author       Louis Chanouha
// @match        *://*/*
// @grant        none
// ==/UserScript==


// Sourced from: https://stackoverflow.com/questions/47660653/chrome-extension-how-to-disable-page-visibility-api
// Tested on Google Chrome 64 / Tampermonkey (24/03/2018)


for (event_name of [""visibilitychange"", ""webkitvisibilitychange"", ""blur""]) {
 window.addEventListener(event_name, function(event) {
 event.stopImmediatePropagation();
 }, true);
}"
jit.cpp,"#include <AK/DistinctNumeric.h>
#include <AK/NonnullOwnPtr.h>
#include <AK/Vector.h>
#include <LibMain/Main.h>
#include <sys/mman.h>


// JS::Bytecode::Executable (jitme)
// 1:
//[   0] Store $5
//[  20] LoadImmediate 0
//[  40] SetLocal 0
//[  60] Load $5
//[  80] LoadImmediate undefined
//[  a0] Store $6
//[  c0] Jump @4
// 2:
// 3:
//[   0] LoadImmediate undefined
//[  20] Jump @5
// 4:
//[   0] GetLocal 0
//[  20] Store $7
//[  40] LoadImmediate 100000000
//[  60] LessThan $7
//[  80] JumpConditional true:@3 false:@6
// 5:
//[   0] Store $6
//[  20] GetLocal 0
//[  40] Increment
//[  58] SetLocal 0
//[  78] Jump @4
// 6:
//[   0] Load $6
//[  20] Jump @2


struct Value {
    u64 value { 0 };
};


AK_TYPEDEF_DISTINCT_NUMERIC_GENERAL(size_t, VMRegister);
AK_TYPEDEF_DISTINCT_NUMERIC_GENERAL(size_t, VMLocal);


struct Instruction {
 enum class Type {
        LoadImmediate,
        Load,
        Store,
        SetLocal,
        GetLocal,
        Increment,
        LessThan,
        Jump,
        JumpConditional,
        Exit,
    };


    Type type {};


protected:
 explicit Instruction(Type type)
        : type(type)
    {
    }
};


struct BasicBlock {
    Vector<NonnullOwnPtr<Instruction>> instructions;


 // Offset into the instruction stream where this code block starts.
 size_t offset { 0 };


 // Offsets into the instruction stream where we have RIP-relative jump offsets to here that need patching.
    Vector<size_t> jumps_to_here;


 template<typename T, typename... Args>
 void append(Args&&... args)
    {
        instructions.empend(make<T>(forward<Args>(args)...));
    }


 void dump() const
    {
 for (size_t i = 0; i < instructions.size(); ++i) {
 dbgln(""    [{}] {}"", i, to_underlying(instructions[i]->type));
        }
    }
};


struct LoadImmediate : public Instruction {
 LoadImmediate(Value value)
        : Instruction(Type::LoadImmediate)
        , value(value)
    {
    }


    Value value;
};


struct Store : public Instruction {
 Store(VMRegister reg)
        : Instruction(Type::Store)
        , reg(reg)
    {
    }


    VMRegister reg;
};


struct Load : public Instruction {
 Load(VMRegister reg)
        : Instruction(Type::Load)
        , reg(reg)
    {
    }


    VMRegister reg;
};


struct SetLocal : public Instruction {
 SetLocal(VMLocal local)
        : Instruction(Type::SetLocal)
        , local(local)
    {
    }


    VMLocal local;
};


struct GetLocal : public Instruction {
 GetLocal(VMLocal local)
        : Instruction(Type::GetLocal)
        , local(local)
    {
    }


    VMLocal local;
};


struct Increment : public Instruction {
 Increment()
        : Instruction(Type::Increment)
    {
    }
};


struct LessThan : public Instruction {
 LessThan(VMRegister lhs)
        : Instruction(Type::LessThan)
        , lhs(lhs)
    {
    }


    VMRegister lhs;
};


struct Exit : public Instruction {
 Exit()
        : Instruction(Type::Exit)
    {
    }
};


struct Jump : public Instruction {
 Jump(BasicBlock& target)
        : Instruction(Type::Jump)
        , target(target)
    {
    }


    BasicBlock& target;
};


struct JumpConditional : public Instruction {
 JumpConditional(BasicBlock& true_target, BasicBlock& false_target)
        : Instruction(Type::JumpConditional)
        , true_target(true_target)
        , false_target(false_target)
    {
    }


    BasicBlock& true_target;
    BasicBlock& false_target;
};


struct VM {
    Vector<Value> registers;
    Vector<Value> locals;


 void dump() const
    {
 dbgln(""Registers:"");
 for (size_t i = 0; i < registers.size(); ++i) {
 dbgln(""    [{}] {}"", i, registers[i].value);
        }
 dbgln(""Locals:"");
 for (size_t i = 0; i < locals.size(); ++i) {
 dbgln(""    [{}] {}"", i, locals[i].value);
        }
    }
};


struct Program {
    Vector<NonnullOwnPtr<BasicBlock>> blocks;


    BasicBlock& make_block()
    {
        blocks.append(make<BasicBlock>());
 return *blocks.last();
    }


 void dump() const
    {
 for (size_t i = 0; i < blocks.size(); ++i) {
 dbgln(""Block {}:"", i + 1);
            blocks[i]->dump();
        }
    }
};


struct Executable {
 void* code { nullptr };
 size_t code_size { 0 };


 void run(VM& vm)
    {
 // RDI: VM&
 // RSI: Value* registers
 // RDX: Value* locals
 typedef void (*JittedFunction)(VM&, Value* registers, Value* locals);
        (*(JittedFunction)code)(vm, vm.registers.data(), vm.locals.data());
    }
};


struct Assembler {
 Assembler(Vector<u8>& output)
        : m_output(output)
    {
    }


    Vector<u8>& m_output;


 enum class Reg {
        GPR0 = 0, // RAX
        GPR1 = 1, // RCX


        RegisterArrayBase = 6, // RSI
        LocalsArrayBase = 2,   // RDX
    };


 struct Operand {
 enum class Type {
            Reg,
            Imm64,
            Mem64BaseAndOffset,
        };


        Type type {};


        Reg reg {};
        u64 offset_or_immediate { 0 };


 static Operand Register(Reg reg)
        {
            Operand operand;
            operand.type = Type::Reg;
            operand.reg = reg;
 return operand;
        }


 static Operand Imm64(u64 imm64)
        {
            Operand operand;
            operand.type = Type::Imm64;
            operand.offset_or_immediate = imm64;
 return operand;
        }


 static Operand Mem64BaseAndOffset(Reg base, u64 offset)
        {
            Operand operand;
            operand.type = Type::Mem64BaseAndOffset;
            operand.reg = base;
            operand.offset_or_immediate = offset;
 return operand;
        }
    };


 void mov(Operand dst, Operand src)
    {
 if (dst.type == Operand::Type::Reg && src.type == Operand::Type::Reg) {
 emit8(0x48);
 emit8(0x89);
 emit8(0xc0 | (to_underlying(dst.reg) << 3) | to_underlying(src.reg));
 return;
        }


 if (dst.type == Operand::Type::Reg && src.type == Operand::Type::Imm64) {
 emit8(0x48);
 emit8(0xb8 | to_underlying(dst.reg));
 emit64(src.offset_or_immediate);
 return;
        }


 if (dst.type == Operand::Type::Mem64BaseAndOffset && src.type == Operand::Type::Reg) {
 emit8(0x48);
 emit8(0x89);
 emit8(0x80 | (to_underlying(src.reg) << 3) | to_underlying(dst.reg));
 emit32(dst.offset_or_immediate);
 return;
        }


 if (dst.type == Operand::Type::Reg && src.type == Operand::Type::Mem64BaseAndOffset) {
 emit8(0x48);
 emit8(0x8b);
 emit8(0x80 | (to_underlying(dst.reg) << 3) | to_underlying(src.reg));
 emit32(src.offset_or_immediate);
 return;
        }


 VERIFY_NOT_REACHED();
    }


 void emit8(u8 value)
    {
        m_output.append(value);
    }


 void emit32(u32 value)
    {
        m_output.append((value >> 0) & 0xff);
        m_output.append((value >> 8) & 0xff);
        m_output.append((value >> 16) & 0xff);
        m_output.append((value >> 24) & 0xff);
    }


 void emit64(u64 value)
    {
        m_output.append((value >> 0) & 0xff);
        m_output.append((value >> 8) & 0xff);
        m_output.append((value >> 16) & 0xff);
        m_output.append((value >> 24) & 0xff);
        m_output.append((value >> 32) & 0xff);
        m_output.append((value >> 40) & 0xff);
        m_output.append((value >> 48) & 0xff);
        m_output.append((value >> 56) & 0xff);
    }


 void load_immediate64(Reg dst, u64 imm)
    {
 mov(Operand::Register(dst), Operand::Imm64(imm));
    }


 void store_vm_register(VMRegister dst, Reg src)
    {
 mov(Operand::Mem64BaseAndOffset(Reg::RegisterArrayBase, dst.value() * sizeof(Value)), Operand::Register(src));
    }


 void load_vm_register(Reg dst, VMRegister src)
    {
 mov(Operand::Register(dst), Operand::Mem64BaseAndOffset(Reg::RegisterArrayBase, src.value() * sizeof(Value)));
    }


 void store_vm_local(VMLocal dst, Reg src)
    {
 mov(Operand::Mem64BaseAndOffset(Reg::LocalsArrayBase, dst.value() * sizeof(Value)), Operand::Register(src));
    }


 void load_vm_local(Reg dst, VMLocal src)
    {
 mov(Operand::Register(dst), Operand::Mem64BaseAndOffset(Reg::LocalsArrayBase, src.value() * sizeof(Value)));
    }


 void increment(Reg dst)
    {
 emit8(0x48);
 emit8(0xff);
 emit8(0xc0 | to_underlying(dst));
    }


 void less_than(Reg dst, Reg src)
    {
 // cmp src, dst
 emit8(0x48);
 emit8(0x39);
 emit8(0xc0 | (to_underlying(src) << 3) | to_underlying(dst));


 // setl dst
 emit8(0x0f);
 emit8(0x9c);
 emit8(0xc0 | to_underlying(dst));


 // movzx dst, dst
 emit8(0x48);
 emit8(0x0f);
 emit8(0xb6);
 emit8(0xc0 | (to_underlying(dst) << 3) | to_underlying(dst));
    }


 void jump(BasicBlock& target)
    {
 // jmp target (RIP-relative 32-bit offset)
 emit8(0xe9);
        target.jumps_to_here.append(m_output.size());
 emit32(0xdeadbeef);
    }


 void jump_conditional(Reg reg, BasicBlock& true_target, BasicBlock& false_target)
    {
 // if reg == 0, jump to false_target, else jump to true_target
 // cmp reg, 0
 emit8(0x48);
 emit8(0x83);
 emit8(0xf8);
 emit8(0x00 | to_underlying(reg));


 // jz false_target (RIP-relative 32-bit offset)
 emit8(0x0f);
 emit8(0x84);
        false_target.jumps_to_here.append(m_output.size());
 emit32(0xdeadbeef);


 // jmp true_target (RIP-relative 32-bit offset)
 jump(true_target);
    }


 void exit()
    {
 // ret
 emit8(0xc3);
    }
};


struct JIT {
    Vector<u8> m_output;
    Assembler m_assembler { m_output };


 void compile_load_immediate(LoadImmediate const& instruction)
    {
        m_assembler.load_immediate64(Assembler::Reg::GPR0, instruction.value.value);
        m_assembler.store_vm_register(VMRegister { 0 }, Assembler::Reg::GPR0);
    }


 void compile_load(Load const& instruction)
    {
        m_assembler.load_vm_register(Assembler::Reg::GPR0, instruction.reg);
        m_assembler.store_vm_register(VMRegister { 0 }, Assembler::Reg::GPR0);
    }


 void compile_store(Store const& instruction)
    {
        m_assembler.load_vm_register(Assembler::Reg::GPR0, VMRegister { 0 });
        m_assembler.store_vm_register(instruction.reg, Assembler::Reg::GPR0);
    }


 void compile_get_local(GetLocal const& instruction)
    {
        m_assembler.load_vm_local(Assembler::Reg::GPR0, instruction.local);
        m_assembler.store_vm_register(VMRegister { 0 }, Assembler::Reg::GPR0);
    }


 void compile_set_local(SetLocal const& instruction)
    {
        m_assembler.load_vm_register(Assembler::Reg::GPR0, VMRegister { 0 });
        m_assembler.store_vm_local(instruction.local, Assembler::Reg::GPR0);
    }


 void compile_increment(Increment const&)
    {
        m_assembler.load_vm_register(Assembler::Reg::GPR0, VMRegister { 0 });
        m_assembler.increment(Assembler::Reg::GPR0);
        m_assembler.store_vm_register(VMRegister { 0 }, Assembler::Reg::GPR0);
    }


 void compile_less_than(LessThan const& instruction)
    {
        m_assembler.load_vm_register(Assembler::Reg::GPR0, instruction.lhs);
        m_assembler.load_vm_register(Assembler::Reg::GPR1, VMRegister { 0 });


        m_assembler.less_than(Assembler::Reg::GPR0, Assembler::Reg::GPR1);


        m_assembler.store_vm_register(VMRegister { 0 }, Assembler::Reg::GPR0);
    }


 void compile_jump(Jump const& instruction)
    {
        m_assembler.jump(instruction.target);
    }


 void compile_jump_conditional(JumpConditional const& instruction)
    {
        m_assembler.load_vm_register(Assembler::Reg::GPR0, VMRegister { 0 });
        m_assembler.jump_conditional(Assembler::Reg::GPR0, instruction.true_target, instruction.false_target);
    }


 void compile_exit(Exit const&)
    {
        m_assembler.exit();
    }


 static Executable compile(Program const& program)
    {
        JIT jit;


 for (auto& block : program.blocks) {
            block->offset = jit.m_output.size();
 for (auto& instruction : block->instructions) {
 switch (instruction->type) {
 case Instruction::Type::LoadImmediate:
                    jit.compile_load_immediate(static_cast<LoadImmediate&>(*instruction));
 break;
 case Instruction::Type::Load:
                    jit.compile_load(static_cast<Load&>(*instruction));
 break;
 case Instruction::Type::Store:
                    jit.compile_store(static_cast<Store&>(*instruction));
 break;
 case Instruction::Type::SetLocal:
                    jit.compile_set_local(static_cast<SetLocal&>(*instruction));
 break;
 case Instruction::Type::GetLocal:
                    jit.compile_get_local(static_cast<GetLocal&>(*instruction));
 break;
 case Instruction::Type::Increment:
                    jit.compile_increment(static_cast<Increment&>(*instruction));
 break;
 case Instruction::Type::LessThan:
                    jit.compile_less_than(static_cast<LessThan&>(*instruction));
 break;
 case Instruction::Type::Jump:
                    jit.compile_jump(static_cast<Jump&>(*instruction));
 break;
 case Instruction::Type::JumpConditional:
                    jit.compile_jump_conditional(static_cast<JumpConditional&>(*instruction));
 break;
 case Instruction::Type::Exit:
                    jit.compile_exit(static_cast<Exit&>(*instruction));
 break;
 default:
 VERIFY_NOT_REACHED();
                }
            }
        }


 for (auto& block : program.blocks) {
 for (auto& jump : block->jumps_to_here) {
 auto offset = block->offset - jump - 4;
                jit.m_output[jump + 0] = (offset >> 0) & 0xff;
                jit.m_output[jump + 1] = (offset >> 8) & 0xff;
                jit.m_output[jump + 2] = (offset >> 16) & 0xff;
                jit.m_output[jump + 3] = (offset >> 24) & 0xff;
            }
        }


 write(STDOUT_FILENO, jit.m_output.data(), jit.m_output.size());


 auto* executable_memory = mmap(nullptr, jit.m_output.size(), PROT_READ | PROT_WRITE | PROT_EXEC, MAP_ANONYMOUS | MAP_PRIVATE, 0, 0);
 VERIFY(executable_memory != MAP_FAILED);


 memcpy(executable_memory, jit.m_output.data(), jit.m_output.size());


 return Executable {
            .code = executable_memory,
            .code_size = jit.m_output.size(),
        };
    }
};


ErrorOr<int> serenity_main(Main::Arguments)
{
 auto program = Program {};
 auto& block1 = program.make_block();
 auto& block2 = program.make_block();
 auto& block3 = program.make_block();
 auto& block4 = program.make_block();
 auto& block5 = program.make_block();
 auto& block6 = program.make_block();


    block1.append<Store>(VMRegister { 5 });
    block1.append<LoadImmediate>(Value(0));
    block1.append<SetLocal>(VMLocal(0));
    block1.append<Load>(VMRegister(5));
    block1.append<LoadImmediate>(Value(0));
    block1.append<Store>(VMRegister(6));
    block1.append<Jump>(block4);


    block2.append<Exit>();


    block3.append<LoadImmediate>(Value(0));
    block3.append<Jump>(block5);


    block4.append<GetLocal>(VMLocal(0));
    block4.append<Store>(VMRegister(7));
    block4.append<LoadImmediate>(Value(100000000));
    block4.append<LessThan>(VMRegister(7));
    block4.append<JumpConditional>(block3, block6);


    block5.append<Store>(VMRegister(6));
    block5.append<GetLocal>(VMLocal(0));
    block5.append<Increment>();
    block5.append<SetLocal>(VMLocal(0));
    block5.append<Jump>(block4);


    block6.append<Load>(VMRegister(6));
    block6.append<Jump>(block2);


    program.dump();


 auto vm = VM {};
    vm.registers.resize(8);
    vm.locals.resize(1);


 auto executable = JIT::compile(program);
    executable.run(vm);


#if 0
    auto* current_block = &block1;
    size_t instruction_index = 0;


    for (;;) {
        if (instruction_index >= current_block->instructions.size()) {
            break;
        }
        auto& instruction = current_block->instructions[instruction_index];
        switch (instruction->type) {
        case Instruction::Type::LoadImmediate:
            vm.registers[0].value = static_cast<LoadImmediate&>(*instruction).value.value;
            break;
        case Instruction::Type::Load:
            vm.registers[0].value = vm.registers[static_cast<Load&>(*instruction).reg.value()].value;
            break;
        case Instruction::Type::Store:
            vm.registers[static_cast<Store&>(*instruction).reg.value()].value = vm.registers[0].value;
            break;
        case Instruction::Type::SetLocal:
            vm.locals[static_cast<SetLocal&>(*instruction).local.value()].value = vm.registers[0].value;
            break;
        case Instruction::Type::GetLocal:
            vm.registers[0].value = vm.locals[static_cast<GetLocal&>(*instruction).local.value()].value;
            break;
        case Instruction::Type::Increment:
            vm.registers[0].value += 1;
            break;
        case Instruction::Type::LessThan:
            vm.registers[0].value = vm.registers[static_cast<LessThan&>(*instruction).lhs.value()].value < vm.registers[0].value;
            break;
        case Instruction::Type::Jump:
            current_block = &static_cast<Jump&>(*instruction).target;
            instruction_index = 0;
            continue;
        case Instruction::Type::JumpConditional:
            if (vm.registers[0].value) {
                current_block = &static_cast<JumpConditional&>(*instruction).true_target;
            } else {
                current_block = &static_cast<JumpConditional&>(*instruction).false_target;
            }
            instruction_index = 0;
            continue;
        case Instruction::Type::Exit:
            vm.dump();
            return 0;
        default:
            VERIFY_NOT_REACHED();
        }


        ++instruction_index;
    }
#endif


    vm.dump();


 return 0;
}"
chatgpt-code-widener.js,"const styleSheet = document.createElement('style')
document.head.appendChild(styleSheet)
styleSheet.textContent = '.text-base { min-width: 100% !important; }'
{
 ""name"": ""ChatGPT Code Widener"",
 ""version"": ""0.0.2"",
 ""manifest_version"": 3,
 ""description"": ""ChatGPT Code Widener"",
 ""content_scripts"": [
    {
 ""matches"": [""https://chat.openai.com/*""],
 ""js"": [""chatgpt-code-widener.js""],
 ""all_frames"": true,
 ""run_at"": ""document_idle""
    }
  ]
}"
unionenum.py,"""""""
Enum union based on and compatible with the standard library's `enum`.
""""""


# MIT License
#
# Copyright (c) 2020 Paolo Lammens
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.


import enum
import itertools as itt
import operator
from functools import reduce
from typing import Literal, Union


import more_itertools as mitt




AUTO = object()




class UnionEnumMeta(enum.EnumMeta):
 """"""
    The metaclass for enums which are the union of several sub-enums.

    Union enums have the _subenums_ attribute which is a tuple of the enums forming the
    union.
    """"""


 # noinspection PyProtectedMember
 @classmethod
 def make_union(
 mcs, *subenums: enum.EnumMeta, name: Union[str, Literal[AUTO], None] = AUTO
    ) -> enum.EnumMeta:
 """"""
        Create an enum whose set of members is the union of members of several enums.

        Order matters: where two members in the union have the same value, they will
        be considered as aliases of each other, and the one appearing in the first
        enum in the sequence will be used as the canonical member (the aliases will
        be associated to this enum member).

        :param subenums: Sequence of sub-enums to make a union of.
        :param name: Name to use for the enum class. AUTO will result in a combination
                     of the names of all subenums, None will result in ""UnionEnum"".
        :return: An enum class which is the union of the given subenums.
 
        Example (using the :func:`enum_union` alias defined below):
 
        >>> class EnumA(enum.Enum):
        ...    A = 1
        >>> class EnumB(enum.Enum):
        ...    B = 2
        ...    ALIAS = 1
        >>> UnionAB = enum_union(EnumA, EnumB)
        >>> UnionAB.__members__
        mappingproxy({'A': <EnumA.A: 1>, 'B': <EnumB.B: 2>, 'ALIAS': <EnumA.A: 1>})
 
        >>> list(UnionAB)
        [<EnumA.A: 1>, <EnumB.B: 2>]
 
        >>> EnumA.A in UnionAB
        True
 
        >>> EnumB.ALIAS in UnionAB
        True
 
        >>> isinstance(EnumB.B, UnionAB)
        True
 
        >>> issubclass(UnionAB, enum.Enum)
        True
 
        >>> class EnumC(enum.Enum):
        ...    C = 3
        >>> enum_union(UnionAB, EnumC) == enum_union(EnumA, EnumB, EnumC)
        True
 
        >>> UnionABC = enum_union(UnionAB, EnumC)
        >>> UnionABC.__members__
        mappingproxy({'A': <EnumA.A: 1>,
                      'B': <EnumB.B: 2>,
                      'ALIAS': <EnumA.A: 1>,
                      'C': <EnumC.C: 3>})
 
        >>> set(UnionAB).issubset(UnionABC)
        True
        """"""
 subenums = mcs._normalize_subenums(subenums)
 mcs._check_duplicates(subenums)


 class UnionEnum(enum.Enum, metaclass=mcs):
 pass


 union_enum = UnionEnum
 union_enum._subenums_ = subenums


 # If aliases are defined, the canonical member will be the one that appears
 # first in the sequence of subenums; dict union keeps the last key so we have
 # to do it in reverse.
 # Dict union might be inefficient for large numbers of
 # subenums, but this is intended to be used with ""manual-scale"" numbers of
 # enums (2, 3, 5 or so) and being an operator it's a better match for reduce
 # since it's a pure function and won't mutate any of the dictionaries.
 union_enum._value2member_map_ = value2member_map = reduce(
 operator.or_,  # dict union (PEP 584)
            (subenum._value2member_map_ for subenum in reversed(subenums)),
            {},  # identity element
        )
 # union of the _member_map_'s but using the canonical member always:
 union_enum._member_map_ = member_map = {
 name: value2member_map[member.value]
 for name, member in itt.chain.from_iterable(
 subenum._member_map_.items() for subenum in subenums
            )
        }
 # only include canonical aliases in _member_names_
 union_enum._member_names_ = list(
 mitt.unique_everseen(
 itt.chain.from_iterable(subenum._member_names_ for subenum in subenums),
 key=member_map.__getitem__,
            )
        )


 # set the __name__ attribute of the enum
 if name is AUTO:
 name = (
 """".join(subenum.__name__.removesuffix(""Enum"") for subenum in subenums)
 + ""UnionEnum""
            )
 UnionEnum.__name__ = name
 elif name is not None:
 UnionEnum.__name__ = name
 else:
 pass # keep default name (""UnionEnum"")


 return union_enum


 def __repr__(cls):
 return f""<union enum of {cls._subenums_}>""


 def __instancecheck__(cls, instance):
 return any(isinstance(instance, subenum) for subenum in cls._subenums_)


 def __eq__(cls, other):
 """"""Equality based on the tuple of subenums (order-sensitive).""""""
 if not isinstance(other, UnionEnumMeta):
 return NotImplemented
 return cls._subenums_ == other._subenums_


 @classmethod
 def _normalize_subenums(mcs, subenums):
 """"""Remove duplicate subenums and flatten nested unions""""""
 # we will need to collapse at most one level of nesting, with the inductive
 # hypothesis that any previous unions are already flat
 subenums = mitt.collapse(
            (e._subenums_ if isinstance(e, mcs) else e for e in subenums),
 base_type=enum.EnumMeta,
        )
 subenums = mitt.unique_everseen(subenums)
 return tuple(subenums)


 @classmethod
 def _check_duplicates(mcs, subenums):
 names, duplicates = set(), set()
 for subenum in subenums:
 for name in subenum.__members__:
                (duplicates if name in names else names).add(name)
 if duplicates:
 raise ValueError(f""Found duplicate member names: {duplicates}"")




# alias
enum_union = UnionEnumMeta.make_union




def extend_enum(base_enum: enum.EnumMeta):
 """"""
    Enum class decorator to ""extend"" an enum by computing the union with the given enum.

    This is equivalent to ``ExtendedEnum = enum_union(BaseEnum, Extension)``, where
    ``BaseEnum`` is the ``base_enum`` parameter and ``Extension`` is the decorated
    enum.

    :param base_enum: The base enum to be extended.
    :return: The union of ``base_enum`` and the decorated enum.


    Example:

    >>> class BaseEnum(enum.Enum):
    ...     A = 1
    ...
    >>> @extend_enum(BaseEnum)
    ... class ExtendedEnum(enum.Enum):
    ...     ALIAS = 1
    ...     B = 2
    >>> ExtendedEnum.__members__
    mappingproxy({'A': <BaseEnum.A: 1>,
                  'ALIAS': <BaseEnum.A: 1>,
                  'B': <ExtendedEnum.B: 2>})
    """"""


 def decorator(extension_enum: enum.EnumMeta):
 return enum_union(base_enum, extension_enum)


 return decorator"
unionenum.py,"""""""
Enum union based on and compatible with the standard library's `enum`.
""""""


# MIT License
#
# Copyright (c) 2020 Paolo Lammens
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the ""Software""), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.


import enum
import itertools as itt
import operator
from functools import reduce
from typing import Literal, Union


import more_itertools as mitt




AUTO = object()




class UnionEnumMeta(enum.EnumMeta):
 """"""
    The metaclass for enums which are the union of several sub-enums.

    Union enums have the _subenums_ attribute which is a tuple of the enums forming the
    union.
    """"""


 # noinspection PyProtectedMember
 @classmethod
 def make_union(
 mcs, *subenums: enum.EnumMeta, name: Union[str, Literal[AUTO], None] = AUTO
    ) -> enum.EnumMeta:
 """"""
        Create an enum whose set of members is the union of members of several enums.

        Order matters: where two members in the union have the same value, they will
        be considered as aliases of each other, and the one appearing in the first
        enum in the sequence will be used as the canonical member (the aliases will
        be associated to this enum member).

        :param subenums: Sequence of sub-enums to make a union of.
        :param name: Name to use for the enum class. AUTO will result in a combination
                     of the names of all subenums, None will result in ""UnionEnum"".
        :return: An enum class which is the union of the given subenums.
 
        Example (using the :func:`enum_union` alias defined below):
 
        >>> class EnumA(enum.Enum):
        ...    A = 1
        >>> class EnumB(enum.Enum):
        ...    B = 2
        ...    ALIAS = 1
        >>> UnionAB = enum_union(EnumA, EnumB)
        >>> UnionAB.__members__
        mappingproxy({'A': <EnumA.A: 1>, 'B': <EnumB.B: 2>, 'ALIAS': <EnumA.A: 1>})
 
        >>> list(UnionAB)
        [<EnumA.A: 1>, <EnumB.B: 2>]
 
        >>> EnumA.A in UnionAB
        True
 
        >>> EnumB.ALIAS in UnionAB
        True
 
        >>> isinstance(EnumB.B, UnionAB)
        True
 
        >>> issubclass(UnionAB, enum.Enum)
        True
 
        >>> class EnumC(enum.Enum):
        ...    C = 3
        >>> enum_union(UnionAB, EnumC) == enum_union(EnumA, EnumB, EnumC)
        True
 
        >>> UnionABC = enum_union(UnionAB, EnumC)
        >>> UnionABC.__members__
        mappingproxy({'A': <EnumA.A: 1>,
                      'B': <EnumB.B: 2>,
                      'ALIAS': <EnumA.A: 1>,
                      'C': <EnumC.C: 3>})
 
        >>> set(UnionAB).issubset(UnionABC)
        True
        """"""
 subenums = mcs._normalize_subenums(subenums)
 mcs._check_duplicates(subenums)


 class UnionEnum(enum.Enum, metaclass=mcs):
 pass


 union_enum = UnionEnum
 union_enum._subenums_ = subenums


 # If aliases are defined, the canonical member will be the one that appears
 # first in the sequence of subenums; dict union keeps the last key so we have
 # to do it in reverse.
 # Dict union might be inefficient for large numbers of
 # subenums, but this is intended to be used with ""manual-scale"" numbers of
 # enums (2, 3, 5 or so) and being an operator it's a better match for reduce
 # since it's a pure function and won't mutate any of the dictionaries.
 union_enum._value2member_map_ = value2member_map = reduce(
 operator.or_,  # dict union (PEP 584)
            (subenum._value2member_map_ for subenum in reversed(subenums)),
            {},  # identity element
        )
 # union of the _member_map_'s but using the canonical member always:
 union_enum._member_map_ = member_map = {
 name: value2member_map[member.value]
 for name, member in itt.chain.from_iterable(
 subenum._member_map_.items() for subenum in subenums
            )
        }
 # only include canonical aliases in _member_names_
 union_enum._member_names_ = list(
 mitt.unique_everseen(
 itt.chain.from_iterable(subenum._member_names_ for subenum in subenums),
 key=member_map.__getitem__,
            )
        )


 # set the __name__ attribute of the enum
 if name is AUTO:
 name = (
 """".join(subenum.__name__.removesuffix(""Enum"") for subenum in subenums)
 + ""UnionEnum""
            )
 UnionEnum.__name__ = name
 elif name is not None:
 UnionEnum.__name__ = name
 else:
 pass # keep default name (""UnionEnum"")


 return union_enum
 
 def __hash__(cls):
 """"""Hash based on the tuple of subenums (order-sensitive).""""""
 return hash(cls._subenums_)
 
 def __repr__(cls):
 return f""<union enum of {cls._subenums_}>""


 def __instancecheck__(cls, instance):
 return any(isinstance(instance, subenum) for subenum in cls._subenums_)


 def __eq__(cls, other):
 """"""Equality based on the tuple of subenums (order-sensitive).""""""
 if not isinstance(other, UnionEnumMeta):
 return NotImplemented
 return cls._subenums_ == other._subenums_


 @classmethod
 def _normalize_subenums(mcs, subenums):
 """"""Remove duplicate subenums and flatten nested unions""""""
 # we will need to collapse at most one level of nesting, with the inductive
 # hypothesis that any previous unions are already flat
 subenums = mitt.collapse(
            (e._subenums_ if isinstance(e, mcs) else e for e in subenums),
 base_type=enum.EnumMeta,
        )
 subenums = mitt.unique_everseen(subenums)
 return tuple(subenums)


 @classmethod
 def _check_duplicates(mcs, subenums):
 names, duplicates = set(), set()
 for subenum in subenums:
 for name in subenum.__members__:
                (duplicates if name in names else names).add(name)
 if duplicates:
 raise ValueError(f""Found duplicate member names: {duplicates}"")




# alias
enum_union = UnionEnumMeta.make_union




def extend_enum(base_enum: enum.EnumMeta):
 """"""
    Enum class decorator to ""extend"" an enum by computing the union with the given enum.

    This is equivalent to ``ExtendedEnum = enum_union(BaseEnum, Extension)``, where
    ``BaseEnum`` is the ``base_enum`` parameter and ``Extension`` is the decorated
    enum.

    :param base_enum: The base enum to be extended.
    :return: The union of ``base_enum`` and the decorated enum.


    Example:

    >>> class BaseEnum(enum.Enum):
    ...     A = 1
    ...
    >>> @extend_enum(BaseEnum)
    ... class ExtendedEnum(enum.Enum):
    ...     ALIAS = 1
    ...     B = 2
    >>> ExtendedEnum.__members__
    mappingproxy({'A': <BaseEnum.A: 1>,
                  'ALIAS': <BaseEnum.A: 1>,
                  'B': <ExtendedEnum.B: 2>})
    """"""


 def decorator(extension_enum: enum.EnumMeta):
 return enum_union(base_enum, extension_enum)


 return decorator"
editor_plugin.js,"// http://tinymce.moxiecode.com/wiki.php/API3:class.tinymce.Plugin


(function() {


 tinymce.create('tinymce.plugins.WRAP', {
 /**
		 * Initializes the plugin, this will be executed after the plugin has been created.
		 * This call is done before the editor instance has finished its initialization so use the onInit event
		 * of the editor instance to intercept that event.
		 *
		 * @param {tinymce.Editor} ed Editor instance that the plugin is initialized in.
		 * @param {string} url Absolute URL to where the plugin is located.
		 */
 init : function(ed, url) {


 //this command will be executed when the button in the toolbar is clicked
 ed.addCommand('mceWRAP', function() {


 selection = tinyMCE.activeEditor.selection.getContent();


 //prompt for a tag to use
 //tag = prompt('Tag:');
 //tinyMCE.activeEditor.selection.setContent('<' + tag + '>' + selection + '</' + tag + '>');


 tinyMCE.activeEditor.selection.setContent('<div class=""classy-div"">' + selection + '</div>');


 });


 ed.addButton('WRAP', {
 title : 'WRAP.desc',
 cmd : 'mceWRAP',
 //image : url + '/your-icon.gif'
 image : 'http://mdawg123.wikispaces.com/i/icon_16_gear.gif'
 });


 },


 });


 // Register plugin
 tinymce.PluginManager.add('WRAP', tinymce.plugins.WRAP);
})();


<?php
/*
Plugin Name: MCE Wrapper
Plugin URI: http://trepmal.com/
Description: TinyMCE button that wraps selection in given tag
Author: Kailey Lampert
Version: 1.0
Author URI: http://kaileylampert.com/

Copyright (C) 2011  Kailey Lampert

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/


add_action( 'init', 'mce_wrapper_init', 9);
function mce_wrapper_init() {
 if (is_admin())
 new mcewrapper();
}


class mcewrapper {


	var $pluginname = 'WRAP';
	var $internalVersion = 600;


 /**
	 * mcewrapper::mcewrapper()
	 * the constructor
	 *
	 * @return void
	 */
 function mcewrapper()  {


 // Modify the version when tinyMCE plugins are changed.
		add_filter('tiny_mce_version', array (&$this, 'change_tinymce_version') );


 // init process for button control
		add_action('init', array (&$this, 'addbuttons') );


	}


 /**
	 * mcewrapper::addbuttons()
	 *
	 * @return void
	 */
 function addbuttons() {


 // Don't bother doing this stuff if the current user lacks permissions
 if ( !current_user_can('edit_posts') && !current_user_can('edit_pages') )
 return;


 // Add only in Rich Editor mode
 if ( get_user_option('rich_editing') == 'true') {


 // add the button for wp2.5 in a new way
			add_filter(""mce_external_plugins"", array (&$this, 'add_tinymce_plugin' ));
			add_filter('mce_buttons', array (&$this, 'register_button' ), 0);
		}
	}


 /**
	 * mcewrapper::register_button()
	 * used to insert button in wordpress 2.5x editor
	 *
	 * @return $buttons
	 */
 function register_button($buttons) {


		array_push($buttons, 'separator', $this->pluginname );


 return $buttons;
	}


 /**
	 * mcewrapper::add_tinymce_plugin()
	 * Load the TinyMCE plugin : editor_plugin.js
	 *
	 * @return $plugin_array
	 */
 function add_tinymce_plugin($plugin_array) {


 $plugin_array[$this->pluginname] =  plugins_url( 'editor_plugin.js', __FILE__ );


 return $plugin_array;
	}


 /**
	 * mcewrapper::change_tinymce_version()
	 * A different version will rebuild the cache
	 *
	 * @return $version
	 */
 function change_tinymce_version($version) {
 $version = $version + $this->internalVersion;
 return $version;
	}




}"
admin.py,"from django.contrib.admin import ModelAdmin


from .paginator import LargeTablePaginator




class MyTableAdmin(ModelAdmin):
    ...
 paginator = LargeTablePaginator
 show_full_result_count = False # Recommended to avoid another count()
    ...
 
from django.core.paginator import Paginator
from django.db import connection, transaction, OperationalError
from django.utils.functional import cached_property




class LargeTablePaginator(Paginator):
 """"""
    Combination of ideas from:
     - https://gist.github.com/safar/3bbf96678f3e479b6cb683083d35cb4d
     - https://medium.com/@hakibenita/optimizing-django-admin-paginator-53c4eb6bfca3

    Overrides the count method of QuerySet objects to avoid timeouts.
    - Try to get the real count limiting the queryset execution time to 150 ms.
    - If count takes longer than 150 ms the database kills the query and raises OperationError. In that case,
    get an estimate instead of actual count when not filtered (this estimate can be stale and hence not fit for
    situations where the count of objects actually matter).
    - If any other exception occured fall back to default behaviour.
    """"""


 @cached_property
 def count(self):
 """"""
        Returns an estimated number of objects, across all pages.
        """"""
 try:
 with transaction.atomic(), connection.cursor() as cursor:
 # Limit to 150 ms
 cursor.execute('SET LOCAL statement_timeout TO 5;')
 return super().count
 except OperationalError:
 pass


 if not self.object_list.query.where:
 try:
 with transaction.atomic(), connection.cursor() as cursor:
 # Obtain estimated values (only valid with PostgreSQL)
 cursor.execute(
 ""SELECT reltuples FROM pg_class WHERE relname = %s"",
                        [self.object_list.query.model._meta.db_table]
                    )
 estimate = int(cursor.fetchone()[0])
 return estimate
 except Exception:
 # If any other exception occurred fall back to default behaviour
 pass
 return super().count"
pydantic_handle_geometry.py,"import logging
from enum import Enum
from typing import Dict, Optional, Union


import geoalchemy2.shape
from geoalchemy2 import WKBElement
from pydantic import BaseModel, Field, validator
from shapely.geometry import Point, asShape
from shapely.geometry.base import BaseGeometry


logger = logging.getLogger(__name__)




class EPSG(int, Enum):
 WGS84 = 4326
 WEBM = 3857 # web-mercator: projected from WGS84




def shape_to_wkb(
 shape: Union[BaseGeometry, WKBElement], srid: EPSG = EPSG.WGS84
) -> Optional[WKBElement]:
 if isinstance(shape, BaseGeometry):
 return geoalchemy2.shape.from_shape(shape, srid=EPSG(srid).value)
 elif isinstance(shape, WKBElement):
 return shape
 else:
 return None




def wkb_to_shape(wkb: Union[WKBElement, BaseGeometry]) -> Optional[BaseGeometry]:
 if isinstance(wkb, WKBElement):
 return geoalchemy2.shape.to_shape(wkb)
 elif isinstance(wkb, BaseGeometry):
 return wkb
 else:
 return None




def create_geom(v, values) -> Point:
 if v is not None:
 try:
 if isinstance(v, list):
 return Point(*v)
 elif isinstance(v, dict):
 return asShape(v)
 elif hasattr(v, ""__geo_interface__""):
 pass # v is already a geometry
 return v
 except Exception as e:
 logger.debug(f""Failed creating geom: v={v} -- {e}"")
 else:
 try:
 lon = values.get(""lon"", None)
 lat = values.get(""lat"", None)
 if lon is not None and lat is not None:
 return Point(lon, lat)
 else:
 return None
 except Exception as e:
 logger.debug(f""Failed creating geom: v={v} -- {e}"")




def dump_geom(cls, v) -> Dict:
 if isinstance(v, dict):
 return v
 else:
 return getattr(wkb_to_shape(v), ""__geo_interface__"", None)




class PlaceBase(BaseModel):
 class Config:
 allow_population_by_field_name = True
 arbitrary_types_allowed = True


 name: Optional[str]
 type: Optional[str]
 source: Optional[str]
 address: Optional[str]
 lon: Optional[float] = Field(None, alias=""longitude"")
 lat: Optional[float] = Field(None, alias=""latitude"")




class Place(PlaceBase):
 name: str
 type: str
 source: str




class PlaceCreateIn(PlaceBase):
 type: str
 source: str
 external_id: Optional[str] = Field(None, alias=""id"")
 geom: Optional[Point] = Field(None, alias=""point"")


 _validate_geom = validator(""geom"", pre=True, always=True, allow_reuse=True)(
 create_geom
    )




class PlaceOut(PlaceBase):
 class Config:
 allow_population_by_field_name = True
 arbitrary_types_allowed = True


 id: int
 name: str
 type: str
 geom: Optional[Dict]


 _validate_geom = validator(""geom"", pre=True, allow_reuse=True)(dump_geom)"
CopyFilelistAb.user.js,"// ==UserScript==
// @name        New script - animebytes.tv
// @namespace   Violentmonkey Scripts
// @match       https://animebytes.tv/torrents.php*
// @grant       none
// @version     1.1
// @author      -
// @description 11/10/2023, 4:38:44 PM
// ==/UserScript==
(async()=>{
async function getFromAPI(page = 1) {
 let group_id = document.querySelector(`input[name=""thread""]`).value;
 let torrent_key = document.querySelector(""head > link[href*='rss_torrents_all']"").href.split(""/"")
 torrent_key = torrent_key[torrent_key.length - 1]
 let username = document.querySelector(""a.username"").innerText
 let api_url = `https://animebytes.tv/scrape.php?torrent_pass=${torrent_key}&username=${username}&hentai=0&type=anime&tags=abg-${group_id}&page=${page}`
 let group = (await (await fetch(api_url)).json()).Groups.find(e => e.ID == Number(group_id))
 // cope harder lol
 if (!group) {
 return getFromAPI(page + 1)
 }
 return group
}
function copyFilelist(tid) {
 let torrent = data.Torrents.find(e => e.ID == tid);
 let finalstring = """"
 for (let file of torrent.FileList) {
 finalstring += `${file.filename}\t${file.size}\n`
 }
 navigator.clipboard.writeText(finalstring)
 console.log(finalstring)
}


function spawnButtons() {
 document.querySelectorAll(`ul[id*=""tabs_""]`).forEach(e => {
 let tid = e.id.split(""_"")[1]
 let child = document.createElement(""li"")
 let btn = document.createElement(""a"")
 btn.innerText = ""Copy Filelist""
 btn.href = ""#""
 btn.onclick = () => { copyFilelist(Number(tid)) }
 child.appendChild(btn)
 e.appendChild(child)
 })
}


let data = await getFromAPI()
spawnButtons()
})()"
